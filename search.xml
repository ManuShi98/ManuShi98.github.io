<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018青岛区域赛游记&amp;退役记</title>
    <url>/2018/11/06/2018%E9%9D%92%E5%B2%9B%E5%8C%BA%E5%9F%9F%E8%B5%9B%E6%B8%B8%E8%AE%B0&amp;%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    <content><![CDATA[<p>拖了这么久，想想还是写一下游记吧，也算写下自己2年ACM生涯的一个句号。<br><span id="more"></span></p>
<h3 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h3><p>下午出发去青岛，路上和lyc打了一套SEERC，结果。。签到题就卡了？思路上就出现了很大的问题。最后我3个小时才写完了签到题emmmm。写完还发现lyc和lx都买了晚饭就我没买，只好勉为其难买了高铁45的套餐。。当时感觉自己状态是真的不好，因为大三开始几门8周的课作业太过密集，从开学开始6-7周只有做做训练题维持状态的样子，水平掉的非常厉害。晚上本来想写几道dp结果写了一道思路对但疯狂TLE，而且开始有了点重感冒的迹象，就跟lx开始摸鱼。。买了个感冒灵就玩了会刚买的空洞骑士，吃完药再跟lx看了会电视就睡了</p>
<h3 id="Day1-热身赛"><a href="#Day1-热身赛" class="headerlink" title="Day1 热身赛"></a>Day1 热身赛</h3><p>早上起来喉咙痛的一批，不过感觉比昨天好多了，然后就是热身赛（虽然好像没什么可写的。。）前两道一眼秒，第三道主办方玩压力测试结果自爆了。题目是道提答题，10道题中6-7道是会的，所以枚举剩下8-16种答案提交就行（上交一发过太强了）。但主办方好像高估了大家的能力？好多60发提交的直接把评测机搞炸了。。最后45分钟我们看了看最后一道感觉不可做就丢了，事实证明的确非常麻烦，思路很好想，但证明其正确性却需要许多思考才行。回宾馆看了看模板就早早休息了。</p>
<h3 id="Day2-正赛"><a href="#Day2-正赛" class="headerlink" title="Day2 正赛"></a>Day2 正赛</h3><p>早上起来感冒基本好了，感觉感冒灵效果不错。正赛开始后老样子我从前看，lx从后看，lyc中间开始。A题看着是个规律题，但是公式不好推（赛后有人说是拉格朗日插值？感觉很合理）B题意类似给定一个试卷，每个题有一个正确答案，连边表示a和b要选一样，现在给定连边，多次询问，每次告诉你若从图中删掉一条连边，最多能做对几道题。当时考虑图1e5点，询问1e5感觉图上log不现实，大概率是O(1)的算法。当时考虑是个强连通分量/可撤销并查集/LCT中的一种，但没细想想。这时lx说M水题就上去和lyc切了结果lx给了个假算法emmm，不过还好最后他们还是解决了问题，当时我看完了C，问的是对一个二进制串，进行两次操作，每次翻转一段连续的串，问从A串到B串有几种翻法（位置不同，操作顺序不同算不同的方法）分类讨论了下就1A了。然后lx读完J，题意是给了n个物品的价值，你买了m个，你不知道自己有多少钱，但你的策略是从左到右你钱够了买，问你最多拥有的钱，不可能输出impossible，无限大输出rich man。显然m=n判断不出来，rich man。同时由于0元一定可以买，所以若你买完m个后面还有0，输出impossible。不然取前m个然后+最小值-1.玄学的时候来了，lx写了一遍，WA。我写了一遍WA。浪费了大量的时间。这不出意外就是我的锅了，我写代码的时候常常会出现细节考虑不周到的的问题，这次又犯了。最后lyc写J，我和lx看D，E。D是告诉你一个n位数，m位数（但不知道是几），给你了n*m个数，表示每位乘积。毒瘤的地方在于它输入是字符串并没有分开，所以你只能猜测可能的划分方法。我当时思路是立刻想到了，枚举a第一位还原b，然后再带回去还原a（注意检验）。但是写完TLE？？现在也不知道怎么回事。E思路我也马上想到了思路，二分答案贪心计算，遗憾的是lx实现的时候没注意到爆了ll，需要__int128，WA到了最后，遗憾打铁。<br>虽然比赛过程非常痛苦，但是比完我的心情却很平静。Granbluefantasy在这场比赛之后也正式解散了。我们分别去了CCPC秦皇岛（铜），ICPC徐州（银），ICPC青岛（铁），账面看着还行，但我知道实际上我们的实力和其他学校仍有非常大的差距，和自身学校ddl的队伍也有一些差距，在徐州能拿银侥幸因素占了很大一部分。细细想来，虽然不愿意承认，但我觉得今年我退步了不少，比赛中对着一些不可做题钻牛角尖的毛病没改好，自己还因为学了许多“高深”的数据结构而沾沾自喜，结果参加的三场比赛，我连模板都没拿出来过。为了学这些，还扔了以前vp cf的习惯，搞得思维略有些僵硬，导致了今年Granbluefantasy并不好的成绩。<br>不论如何，都结束了。真的很想向dll那样再来一年，但我的绩点告诉我，到此为止了，该准备考研了。想起了post icpc上叉姐姐那句“送君千里，终须一别”，ACM与我，也终于到了告别的日子。</p>
<p>再见了，ACM</p>
]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>比赛总结</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 1001 狼抓兔子(网络流最小割转对偶图最短路)</title>
    <url>/2018/05/16/BZOJ%20-%201001%20%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90(%E7%BD%91%E7%BB%9C%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E8%BD%AC%E5%AF%B9%E5%81%B6%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意可得我们要求一个网络流的最小割。但由于dinic时间复杂度是O(EV^2)，显然对于这张图来说边数会达到10^6以上，所以dinic的时间复杂度是不满足我们的要求的。所以我们学习一个O(nlogn)的姿势——网络流最小割转对偶图最短路。对偶图的概念摸<a href="https://baike.baidu.com/item/%E5%AF%B9%E5%81%B6%E5%9B%BE/10506149?fr=aladdin">这里</a>。通过观察我们能发现对偶图中的环即对应着原图的割，但直接用对偶图环的性质我们并没有什么高效的算法。所以我们在建图过程中稍作修改，我们这样对样例建图：<br><img src="https://i.loli.net/2020/12/14/QcBPL9XfAvhVrCx.png" alt="bzoj1001"><br>我们先在左上角的源点和右下角的汇点连一条线，如上图，然后再建对偶图。这时比较对偶图的性质显然可以知道对偶图中0到1的最短路即为最小割，运用spfa或dijkstra堆优化就能做到O(nlogn)。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2000005</span>,MAXM=<span class="number">6000005</span>;</span><br><span class="line"><span class="keyword">int</span> head[MAXN],nxt[MAXM],to[MAXM],len[MAXM],edgecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[edgecnt]=v;</span><br><span class="line">    len[edgecnt]=w;</span><br><span class="line">    nxt[edgecnt]=head[u];</span><br><span class="line">    head[u]=edgecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p1,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.first&gt;p2.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> dist[MAXN],N;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)dist[i]=INF;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;,cmp&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; temp=pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> now=temp.second,dis=temp.first;</span><br><span class="line">        <span class="keyword">if</span>(dist[now]&lt;dis)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];~i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[now]+len[i]&lt;dist[to[i]])&#123;</span><br><span class="line">                dist[to[i]]=dist[now]+len[i];</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dist[to[i]],to[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,cost;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="built_in">ms</span>(head,<span class="number">-1</span>);</span><br><span class="line">        edgecnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>||m==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;m)m=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">1</span>;z&lt;m;z++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(z==<span class="number">1</span>)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ans);</span><br><span class="line">                <span class="keyword">int</span> t;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">                <span class="keyword">if</span>(t&lt;ans)ans=t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            N=(n<span class="number">-1</span>)*(m<span class="number">-1</span>)*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cost);</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;2*j&lt;&lt;endl;</span></span><br><span class="line">                        <span class="built_in">addedge</span>(<span class="number">0</span>,<span class="number">2</span>*j,cost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i==n<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;2*((m-1)*(i-1)+j)+1&lt;&lt;&quot; &quot;&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">                        <span class="built_in">addedge</span>(<span class="number">2</span>*((m<span class="number">-1</span>)*(i<span class="number">-1</span>)+j)+<span class="number">1</span>,<span class="number">1</span>,cost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;2*((m-1)*(i-1)+j)+1&lt;&lt;&quot; &quot;&lt;&lt;2*((m-1)*i+j)&lt;&lt;endl;</span></span><br><span class="line">                        <span class="built_in">addedge</span>(<span class="number">2</span>*((m<span class="number">-1</span>)*(i<span class="number">-1</span>)+j)+<span class="number">1</span>,<span class="number">2</span>*((m<span class="number">-1</span>)*i+j),cost);</span><br><span class="line">                        <span class="built_in">addedge</span>(<span class="number">2</span>*((m<span class="number">-1</span>)*i+j),<span class="number">2</span>*((m<span class="number">-1</span>)*(i<span class="number">-1</span>)+j)+<span class="number">1</span>,cost);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cost);</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;2*((m-1)*j+i+1)+1&lt;&lt;&quot; &quot;&lt;&lt;1&lt;&lt;endl;</span></span><br><span class="line">                        <span class="built_in">addedge</span>(<span class="number">2</span>*((m<span class="number">-1</span>)*j+i+<span class="number">1</span>)+<span class="number">1</span>,<span class="number">1</span>,cost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i==m<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;2*((m-1)*j+i)&lt;&lt;endl;</span></span><br><span class="line">                        <span class="built_in">addedge</span>(<span class="number">0</span>,<span class="number">2</span>*((m<span class="number">-1</span>)*j+i),cost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;2*((m-1)*j+i)&lt;&lt;&quot; &quot;&lt;&lt;2*((m-1)*j+i+1)+1&lt;&lt;endl;</span></span><br><span class="line">                        <span class="built_in">addedge</span>(<span class="number">2</span>*((m<span class="number">-1</span>)*j+i),<span class="number">2</span>*((m<span class="number">-1</span>)*j+i+<span class="number">1</span>)+<span class="number">1</span>,cost);</span><br><span class="line">                        <span class="built_in">addedge</span>(<span class="number">2</span>*((m<span class="number">-1</span>)*j+i+<span class="number">1</span>)+<span class="number">1</span>,<span class="number">2</span>*((m<span class="number">-1</span>)*j+i),cost);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">-1</span>;j++)&#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cost);</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;2*((m-1)*i+j)&lt;&lt;&quot; &quot;&lt;&lt;2*((m-1)*i+j)+1&lt;&lt;endl;</span></span><br><span class="line">                    <span class="built_in">addedge</span>(<span class="number">2</span>*((m<span class="number">-1</span>)*i+j),<span class="number">2</span>*((m<span class="number">-1</span>)*i+j)+<span class="number">1</span>,cost);</span><br><span class="line">                    <span class="built_in">addedge</span>(<span class="number">2</span>*((m<span class="number">-1</span>)*i+j)+<span class="number">1</span>,<span class="number">2</span>*((m<span class="number">-1</span>)*i+j),cost);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dijkstra</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>2017-2018 ACM-ICPC, Asia Daejeon Regional Contest(训练日常)</title>
    <url>/2018/08/31/2017-2018%20ACM-ICPC,%20Asia%20Daejeon%20Regional%20Contest(%E8%AE%AD%E7%BB%83%E6%97%A5%E5%B8%B8)/</url>
    <content><![CDATA[<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>CF Rank: 60/273<br>emmmm这比赛的题非常友好啊？我们队5个小时<del>没法摸鱼</del>有题可做，A题好像是个树形dp，L是个枚举时间最短路？算了有空再补吧。。<br><span id="more"></span></p>
<h3 id="Problem-A-Broadcast-Stations"><a href="#Problem-A-Broadcast-Stations" class="headerlink" title="Problem A Broadcast Stations"></a>Problem A Broadcast Stations</h3><p>Unsolved</p>
<h3 id="Problem-B-Connect3"><a href="#Problem-B-Connect3" class="headerlink" title="Problem B Connect3"></a>Problem B Connect3</h3><p>Solved By shuzijun (+,4:08)</p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个4*4棋盘，黑色先手，且必须放在给定的(1,x)位置上，之后只有下面有棋子时，上面才能放棋子。比如放(3,1)时，(2,1),(1,1)都需要已经放过棋子。取胜的条件与井字棋类似，横，竖，斜有连续的三个就是胜利。要求你找出白色方最后一手放在(a,b)位置上就能取得胜利的不同的局面有多少种。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>暴搜即可</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rush() int T;scanf(<span class="meta-string">&quot;%d&quot;</span>,&amp;T);int kase=1;while(T--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;ll ans=<span class="number">0</span>,flag=<span class="number">1</span>;<span class="keyword">char</span> c;c=<span class="built_in">getchar</span>();<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)flag=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;ans=ans*<span class="number">10</span>+(ll)(c-<span class="string">&#x27;0&#x27;</span>);c=<span class="built_in">getchar</span>();&#125;<span class="keyword">return</span> ans*flag;&#125;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll x,ll y,ll mod)</span></span>&#123;ll ans=<span class="number">1</span>;<span class="keyword">while</span>(y)&#123;<span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; vis;</span><br><span class="line"><span class="keyword">int</span> a,b,ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j]==x)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[j][i]==x)</span><br><span class="line">                cnt++;</span><br><span class="line">            <span class="keyword">else</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="number">0</span>][<span class="number">0</span>]==x&amp;&amp;mp[<span class="number">0</span>][<span class="number">0</span>]==mp[<span class="number">1</span>][<span class="number">1</span>]&amp;&amp;mp[<span class="number">1</span>][<span class="number">1</span>]==mp[<span class="number">2</span>][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="number">1</span>][<span class="number">1</span>]==x&amp;&amp;mp[<span class="number">1</span>][<span class="number">1</span>]==mp[<span class="number">2</span>][<span class="number">2</span>]&amp;&amp;mp[<span class="number">2</span>][<span class="number">2</span>]==mp[<span class="number">3</span>][<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="number">0</span>][<span class="number">1</span>]==x&amp;&amp;mp[<span class="number">0</span>][<span class="number">1</span>]==mp[<span class="number">1</span>][<span class="number">2</span>]&amp;&amp;mp[<span class="number">1</span>][<span class="number">2</span>]==mp[<span class="number">2</span>][<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="number">1</span>][<span class="number">0</span>]==x&amp;&amp;mp[<span class="number">1</span>][<span class="number">0</span>]==mp[<span class="number">2</span>][<span class="number">1</span>]&amp;&amp;mp[<span class="number">2</span>][<span class="number">1</span>]==mp[<span class="number">3</span>][<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="number">0</span>][<span class="number">3</span>]==x&amp;&amp;mp[<span class="number">0</span>][<span class="number">3</span>]==mp[<span class="number">1</span>][<span class="number">2</span>]&amp;&amp;mp[<span class="number">1</span>][<span class="number">2</span>]==mp[<span class="number">2</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="number">0</span>][<span class="number">2</span>]==x&amp;&amp;mp[<span class="number">0</span>][<span class="number">2</span>]==mp[<span class="number">1</span>][<span class="number">1</span>]&amp;&amp;mp[<span class="number">1</span>][<span class="number">1</span>]==mp[<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="number">1</span>][<span class="number">2</span>]==x&amp;&amp;mp[<span class="number">1</span>][<span class="number">2</span>]==mp[<span class="number">2</span>][<span class="number">1</span>]&amp;&amp;mp[<span class="number">2</span>][<span class="number">1</span>]==mp[<span class="number">3</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(mp[<span class="number">1</span>][<span class="number">3</span>]==x&amp;&amp;mp[<span class="number">1</span>][<span class="number">3</span>]==mp[<span class="number">2</span>][<span class="number">2</span>]&amp;&amp;mp[<span class="number">2</span>][<span class="number">2</span>]==mp[<span class="number">3</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gethash</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res=res*<span class="number">3</span>+mp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;!mp[i<span class="number">-1</span>][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            mp[i][j]=x;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">judge</span>(x))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x==<span class="number">2</span>&amp;&amp;i==a&amp;&amp;j==b)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> now=<span class="built_in">gethash</span>();</span><br><span class="line">                    <span class="keyword">if</span>(!vis[now])</span><br><span class="line">                        vis[now]=<span class="literal">true</span>,ans++;</span><br><span class="line">                &#125;</span><br><span class="line">                mp[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(x==<span class="number">1</span>?<span class="number">2</span>:<span class="number">1</span>);</span><br><span class="line">            mp[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;x&gt;&gt;a&gt;&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="keyword">sizeof</span> mp);</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        vis.<span class="built_in">clear</span>();</span><br><span class="line">        mp[<span class="number">0</span>][x<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        a--,b--;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">2</span>);</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Problem-C-Game-Map"><a href="#Problem-C-Game-Map" class="headerlink" title="Problem C Game Map"></a>Problem C Game Map</h3><p>Solved By ManuShi (+,1:00)</p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定一张无向图，定义一种合法路径为路径上后一个点的度数严格大于前一个点的度数。为长度最长的合法路径长度是多少</p>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>对度数排序，从度数小的点往度数大的点更新即可</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>,MAXM=<span class="number">600005</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> deg[MAXN],ans[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id,deg;</span><br><span class="line">&#125;N[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node n1,node n2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1.deg&lt;n2.deg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">ms</span>(deg,<span class="number">0</span>),<span class="built_in">ms</span>(ans,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">            deg[u]++,deg[v]++;</span><br><span class="line">            N[u].deg++,N[v].deg++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)N[i].id=i;</span><br><span class="line">        <span class="built_in">sort</span>(N,N+n,cmp);</span><br><span class="line">        <span class="keyword">int</span> maxs=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> now=N[i].id;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G[now].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> go=G[now][j];</span><br><span class="line">                <span class="keyword">if</span>(deg[go]&gt;deg[now])&#123;</span><br><span class="line">                    ans[go]=<span class="built_in">max</span>(ans[go],ans[now]+<span class="number">1</span>);</span><br><span class="line">                    maxs=<span class="built_in">max</span>(ans[go],maxs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxs+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Problem-D-Happy-Number"><a href="#Problem-D-Happy-Number" class="headerlink" title="Problem D Happy Number"></a>Problem D Happy Number</h3><p>Solved By ManuShi (+1,00:23)</p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>定义f(x)为各位数字的平方的和。如果多次操作能变成1，那么就是happy number，不然就不是happy number</p>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>初始数字为1,000,000,000，但是注意到平方的和最多也就81*9，开个1000的数组判判有没有循环就行</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=n%<span class="number">10</span>;</span><br><span class="line">        sum+=num*num;</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        <span class="built_in">ms</span>(vis,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> now=<span class="built_in">getsum</span>(n);</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="number">1</span>&amp;&amp;!vis[now])&#123;</span><br><span class="line">            vis[now]=<span class="number">1</span>;</span><br><span class="line">            now=<span class="built_in">getsum</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;HAPPY\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;UNHAPPY\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Problem-E-How-Many-to-Be-Happy"><a href="#Problem-E-How-Many-to-Be-Happy" class="headerlink" title="Problem E How Many to Be Happy?"></a>Problem E How Many to Be Happy?</h3><p>Upsolved By ManuShi</p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>问对于每条边来说，让其变成图的最小生成树中的边最少需要移走几条边，输出求和后的答案</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>若要使得该边在最小生成树中，我们要保证u,v的两端的子图不能通过其他比当前边小的边来联通，也就是我们要求的答案即是图中比当前边长度小的所有边所构成图的最小割（边容量为1）。所以考虑枚举所有边，以图中比当前边长度小的所有边来建图，以边的端点为源点汇点跑最大流。<del>好像是是2.5*10^9的算法啊，怎么跑的这么快</del></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">105</span>,MAXM=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> head[MAXN],nxt[MAXM],cap[MAXM],to[MAXM],edgecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[edgecnt]=v;</span><br><span class="line">    cap[edgecnt]=w;</span><br><span class="line">    nxt[edgecnt]=head[u];</span><br><span class="line">    head[u]=edgecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> level[MAXN],cur[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ms</span>(level,<span class="number">-1</span>);</span><br><span class="line">    level[u]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];~i;i=nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(cap[i]&gt;<span class="number">0</span>&amp;&amp;level[v]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                level[v]=level[now]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> t,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)<span class="keyword">return</span> f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=cur[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(cap[i]&gt;<span class="number">0</span>&amp;&amp;level[to[i]]&gt;level[u])&#123;</span><br><span class="line">            <span class="keyword">int</span> d=<span class="built_in">dfs</span>(to[i],t,<span class="built_in">min</span>(f,cap[i]));</span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                cap[i]-=d;</span><br><span class="line">                cap[i^<span class="number">1</span>]+=d;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> f;</span><br><span class="line">        <span class="built_in">bfs</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)cur[i]=head[i];</span><br><span class="line">        <span class="keyword">if</span>(level[t]&lt;<span class="number">0</span>)<span class="keyword">return</span> flow;</span><br><span class="line">        <span class="keyword">while</span>((f=<span class="built_in">dfs</span>(s,t,INTINF))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            flow+=f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="built_in">edge</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w):<span class="built_in">u</span>(u),<span class="built_in">v</span>(v),<span class="built_in">w</span>(w)&#123;&#125;</span><br><span class="line">&#125;E[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            E[i]=<span class="built_in">edge</span>(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">ms</span>(head,<span class="number">-1</span>);</span><br><span class="line">            edgecnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=j&amp;&amp;E[i].w&gt;E[j].w)&#123;</span><br><span class="line">                    <span class="built_in">addedge</span>(E[j].u,E[j].v,<span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">addedge</span>(E[j].v,E[j].u,<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">addedge</span>(E[j].v,E[j].u,<span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">addedge</span>(E[j].u,E[j].v,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=<span class="built_in">dinic</span>(E[i].u,E[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Problem-F-Philosopher’s-Walk"><a href="#Problem-F-Philosopher’s-Walk" class="headerlink" title="Problem F Philosopher’s Walk"></a>Problem F Philosopher’s Walk</h3><p>Solved By shuzijun (+2,02:12)</p>
<h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>边长都是2的k次幂，每个正方形都是前面4个拼接而成（具体见题目图片）。从左下角开始走，给定步数len和k，问走len步最后位置的坐标</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>这题是shuzijun写的我思路也不是太确定，理论上来说因为正方形的放置方法是固定的，那么我们可以考虑递归，dfs要判断正方形是如何放置的，然后返回一个偏移量累加应该就可以了。。吧？</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rush() int T;scanf(<span class="meta-string">&quot;%d&quot;</span>,&amp;T);int kase=1;while(T--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;ll ans=<span class="number">0</span>,flag=<span class="number">1</span>;<span class="keyword">char</span> c;c=<span class="built_in">getchar</span>();<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)flag=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;ans=ans*<span class="number">10</span>+(ll)(c-<span class="string">&#x27;0&#x27;</span>);c=<span class="built_in">getchar</span>();&#125;<span class="keyword">return</span> ans*flag;&#125;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll x,ll y,ll mod)</span></span>&#123;ll ans=<span class="number">1</span>;<span class="keyword">while</span>(y)&#123;<span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> flag,<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> &amp;posx,<span class="keyword">int</span> &amp;posy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">                posy=posy+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                posx=posx+<span class="number">1</span>;</span><br><span class="line">                posy=posy+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">4</span>)</span><br><span class="line">                posx=posx+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">4</span>)</span><br><span class="line">                posy=posy+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                posx=posx+<span class="number">1</span>;</span><br><span class="line">                posy=posy+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">                posx=posx+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">                posx=posx<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                posx=posx<span class="number">-1</span>;</span><br><span class="line">                posy=posy<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">4</span>)</span><br><span class="line">                posy=posy<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">4</span>)</span><br><span class="line">                posx=posx<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                posx=posx<span class="number">-1</span>;</span><br><span class="line">                posy=posy<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">2</span>)</span><br><span class="line">                posy=posy<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num=(m<span class="number">-1</span>)/(n*n/<span class="number">4</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">            flag=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            posy=posy+n/<span class="number">2</span>;</span><br><span class="line">            m-=(n*n/<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            posx=posx+n/<span class="number">2</span>;</span><br><span class="line">            posy=posy+n/<span class="number">2</span>;</span><br><span class="line">            m-=(n*n/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">3</span>;</span><br><span class="line">            posx=posx+n<span class="number">-1</span>;</span><br><span class="line">            posy=posy+n/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            m-=(n*n/<span class="number">4</span>*<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">2</span>;</span><br><span class="line">            posx=posx+n/<span class="number">2</span>;</span><br><span class="line">            m-=(n*n/<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">2</span>;</span><br><span class="line">            posx=posx+n/<span class="number">2</span>;</span><br><span class="line">            posy=posy+n/<span class="number">2</span>;</span><br><span class="line">            m-=(n*n/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">4</span>;</span><br><span class="line">            posx=posx+n/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            posy=posy+n<span class="number">-1</span>;</span><br><span class="line">            m-=(n*n/<span class="number">4</span>*<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">            flag=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">3</span>;</span><br><span class="line">            posx=posx-n/<span class="number">2</span>;</span><br><span class="line">            m-=(n*n/<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">3</span>;</span><br><span class="line">            posx=posx-n/<span class="number">2</span>;</span><br><span class="line">            posy=posy-n/<span class="number">2</span>;</span><br><span class="line">            m-=(n*n/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            posx=posx-n/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            posy=posy-n+<span class="number">1</span>;</span><br><span class="line">            m-=(n*n/<span class="number">4</span>*<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">            flag=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">4</span>;</span><br><span class="line">            posy=posy-n/<span class="number">2</span>;</span><br><span class="line">            m-=(n*n/<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">4</span>;</span><br><span class="line">            posx=posx-n/<span class="number">2</span>;</span><br><span class="line">            posy=posy-n/<span class="number">2</span>;</span><br><span class="line">            m-=(n*n/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">2</span>;</span><br><span class="line">            posx=posx-n+<span class="number">1</span>;</span><br><span class="line">            posy=posy-n/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            m-=(n*n/<span class="number">4</span>*<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(flag,n/<span class="number">2</span>,m,posx,posy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> posx=<span class="number">1</span>,posy=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(flag,n,m,posx,posy);</span><br><span class="line">        cout&lt;&lt;posx&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;posy&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Problem-G-Rectilinear-Regions"><a href="#Problem-G-Rectilinear-Regions" class="headerlink" title="Problem G Rectilinear Regions"></a>Problem G Rectilinear Regions</h3><p>Solved By ManuShi (+1,04:30)</p>
<h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>给定两根直线（具体见题目中图片），问蓝色在红色上面时交的面积有多少，求个数和面积和</p>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>题目表示拐点坐标两两不同，大力扫描线就完事了，注意两边非封闭区域面积不计</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">    ll x,y,id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> point &amp;p1)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;p1.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;P[<span class="number">50005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>,lastx;</span><br><span class="line">        ll ay,by;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;ay);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%I64d%I64d&quot;</span>,&amp;P[cnt].x,&amp;P[cnt].y);</span><br><span class="line">            P[cnt++].id=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;by);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%I64d%I64d&quot;</span>,&amp;P[cnt].x,&amp;P[cnt].y);</span><br><span class="line">            P[cnt++].id=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(P,P+cnt);</span><br><span class="line">        <span class="keyword">int</span> flag=by&gt;ay?<span class="number">0</span>:<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1 blue up,2 red up,1 start,2 end</span></span><br><span class="line">        ll area=<span class="number">0</span>,tarea=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(P[i].id==<span class="number">1</span>&amp;&amp;P[i].y&lt;ay)&#123;</span><br><span class="line">                    flag=<span class="number">2</span>;</span><br><span class="line">                    by=P[i].y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(P[i].id==<span class="number">1</span>)by=P[i].y;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(P[i].id==<span class="number">0</span>&amp;&amp;P[i].y&gt;by)&#123;</span><br><span class="line">                    flag=<span class="number">2</span>;</span><br><span class="line">                    ay=P[i].y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(P[i].id==<span class="number">0</span>)ay=P[i].y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(P[i].id==<span class="number">1</span>&amp;&amp;P[i].y&gt;ay)&#123;</span><br><span class="line">                    area+=(P[i].x-lastx)*(by-ay);</span><br><span class="line">                    tarea+=(P[i].x-lastx)*(by-ay);</span><br><span class="line">                    by=P[i].y,lastx=P[i].x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(P[i].id==<span class="number">1</span>&amp;&amp;P[i].y&lt;ay)&#123;</span><br><span class="line">                    flag=<span class="number">2</span>;</span><br><span class="line">                    area+=(P[i].x-lastx)*(by-ay);</span><br><span class="line">                    tarea=<span class="number">0</span>;</span><br><span class="line">                    by=P[i].y;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(P[i].id==<span class="number">0</span>&amp;&amp;P[i].y&lt;by)&#123;</span><br><span class="line">                    area+=(P[i].x-lastx)*(by-ay);</span><br><span class="line">                    tarea+=(P[i].x-lastx)*(by-ay);</span><br><span class="line">                    ay=P[i].y,lastx=P[i].x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(P[i].id==<span class="number">0</span>&amp;&amp;P[i].y&gt;by)&#123;</span><br><span class="line">                    flag=<span class="number">2</span>;</span><br><span class="line">                    area+=(P[i].x-lastx)*(by-ay);</span><br><span class="line">                    tarea=<span class="number">0</span>;</span><br><span class="line">                    ay=P[i].y;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(flag==<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(P[i].id==<span class="number">1</span>&amp;&amp;P[i].y&gt;ay)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    by=P[i].y,lastx=P[i].x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(P[i].id==<span class="number">1</span>)&#123;</span><br><span class="line">                    by=P[i].y;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(P[i].id==<span class="number">0</span>&amp;&amp;P[i].y&lt;by)&#123;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    ay=P[i].y,lastx=P[i].x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(P[i].id==<span class="number">0</span>)&#123;</span><br><span class="line">                    ay=P[i].y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%I64d %I64d\n&quot;</span>,num,area-tarea);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Problem-H-Rock-Paper-Scissors"><a href="#Problem-H-Rock-Paper-Scissors" class="headerlink" title="Problem H Rock Paper Scissors"></a>Problem H Rock Paper Scissors</h3><p>Solved By ManuShi (+,02:04)</p>
<h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>给定两个石头剪刀布序列，问怎么放第二个序列能使赢得次数尽可能多，最多是多少。</p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>刚做过字符串循环匹配就给我来这个=_=，显然这个题常规的字符串数据结构是搞不了的（因为它有可能不是完全匹配的啊，常规数据结构只能算完全匹配的算不了匹配了几个）。那么考虑反转第二个字符串，然后对3种字符分别使用fft匹配。卷积形式为A[j]*B[i-j],我们每次设要匹配的字符为1，不要的为0，这样只有1*1时才会对答案有贡献，这样最后乘积c[i]就是我们要的每个位置的匹配个数。FFT以后对答案求和取个最大值就行</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">262145</span>;<span class="comment">//1&lt;&lt;n</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real,image;</span><br><span class="line">    <span class="built_in">Complex</span>()&#123;real=<span class="number">0</span>,image=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> real)&#123;<span class="keyword">this</span>-&gt;real=real,image=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> real,<span class="keyword">double</span> image)&#123;<span class="keyword">this</span>-&gt;real=real,<span class="keyword">this</span>-&gt;image=image;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(c.real+real,c.image+image);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> -(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real-c.real,image-c.image);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> *(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(c.real*real-c.image*image,c.real*image+c.image*real);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> *(<span class="keyword">double</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real*x,image*x);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> /(<span class="keyword">double</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real/x,image/x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Complex <span class="title">rev</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real,-image);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex *a, <span class="keyword">int</span> n,Complex *com)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k)&lt;n)k++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;k;j++)<span class="keyword">if</span> (i&amp;(<span class="number">1</span> &lt;&lt; j))t |= (<span class="number">1</span> &lt;&lt; (k - j - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (i&lt;t)<span class="built_in">swap</span>(a[i], a[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>;l &lt;= n;l *= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = l / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (Complex *p = a;p&lt;a + n;p += l) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">				Complex t = com[n / l*i] * p[m + i];</span><br><span class="line">				p[m + i] = p[i] - t;</span><br><span class="line">				p[i]=p[i]+t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Complex omega[MAXN], iomega[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		omega[i] = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2</span> * PI / n*i), <span class="built_in">sin</span>(<span class="number">2</span> * PI / n*i));</span><br><span class="line">		iomega[i] = omega[i].<span class="built_in">rev</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dft</span><span class="params">(Complex *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fft</span>(a, n,omega);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idft</span><span class="params">(Complex *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fft</span>(a, n,iomega);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)a[i] =a[i]/ n;</span><br><span class="line">&#125;</span><br><span class="line">Complex a[MAXN], b[MAXN],c[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN],B[MAXN];</span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="keyword">char</span> strb[MAXN],stra[MAXN];</span><br><span class="line"><span class="keyword">char</span> win[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFlag</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(win[i]==ch)<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    win[<span class="number">0</span>]=<span class="string">&#x27;R&#x27;</span>,win[<span class="number">1</span>]=<span class="string">&#x27;S&#x27;</span>,win[<span class="number">2</span>]=<span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="built_in">ms</span>(A,<span class="number">0</span>),<span class="built_in">ms</span>(B,<span class="number">0</span>),<span class="built_in">ms</span>(ans,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,strb);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stra);</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&lt;(m+n))len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">init</span>(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">0</span>;w&lt;<span class="number">3</span>;w++)&#123;</span><br><span class="line">            <span class="keyword">int</span> go=(w+<span class="number">1</span>)%<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">getFlag</span>(strb[i])==go)B[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> B[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">getFlag</span>(stra[i])==w+<span class="number">1</span>)A[m-i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> A[m-i<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)a[i]=<span class="built_in">Complex</span>(A[i],<span class="number">0</span>),b[i]=<span class="built_in">Complex</span>(B[i],<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">dft</span>(a,len),<span class="built_in">dft</span>(b,len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)c[i]=a[i]*b[i];</span><br><span class="line">            <span class="built_in">idft</span>(c,len);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                ans[i]+=(<span class="keyword">int</span>)(c[i].real+<span class="number">0.5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxs=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            maxs=<span class="built_in">max</span>(maxs,ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxs);</span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;n;i++)if()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Problem-I-Slot-Machines"><a href="#Problem-I-Slot-Machines" class="headerlink" title="Problem I Slot Machines"></a>Problem I Slot Machines</h3><p>Solved By Shuzijun (+2,03:24)</p>
<h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>给定一个序列，要求找到以k开始，p为循环节的循环部分并且要求p+k最小</p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>反转字符串跑getNext，循环节就是i-next[i]</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rush() int T;scanf(<span class="meta-string">&quot;%d&quot;</span>,&amp;T);int kase=1;while(T--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span>&#123;ll ans=<span class="number">0</span>,flag=<span class="number">1</span>;<span class="keyword">char</span> c;c=<span class="built_in">getchar</span>();<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)flag=<span class="number">-1</span>;c=<span class="built_in">getchar</span>();&#125;<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;ans=ans*<span class="number">10</span>+(ll)(c-<span class="string">&#x27;0&#x27;</span>);c=<span class="built_in">getchar</span>();&#125;<span class="keyword">return</span> ans*flag;&#125;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll x,ll y,ll mod)</span></span>&#123;ll ans=<span class="number">1</span>;<span class="keyword">while</span>(y)&#123;<span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> next1[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next1[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">-1</span>||p[j]==p[k])</span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">/*if(p[j]!=p[k])*/</span></span><br><span class="line">            next1[j]=k;</span><br><span class="line">            <span class="comment">/*else next1[j]=next1[k];*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> k=next1[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            p[i]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">memset</span>(next1,<span class="number">0</span>,<span class="keyword">sizeof</span> next1);</span><br><span class="line">        <span class="built_in">reverse</span>(p,p+n);</span><br><span class="line">        <span class="built_in">getNext</span>();</span><br><span class="line">        <span class="keyword">int</span> ans=INF;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,c=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nc=i-next1[i];</span><br><span class="line">            <span class="keyword">int</span> nl=n-i;</span><br><span class="line">            <span class="keyword">if</span>(nc+nl&lt;ans)</span><br><span class="line">            &#123;</span><br><span class="line">                l=nl,c=nc,ans=nc+nl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nc+nl==ans&amp;&amp;nc&lt;c)</span><br><span class="line">            &#123;</span><br><span class="line">                l=nl,c=nc,ans=nc+nl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Problem-J-Strongly-Matchable"><a href="#Problem-J-Strongly-Matchable" class="headerlink" title="Problem J Strongly Matchable"></a>Problem J Strongly Matchable</h3><p>Unsolved</p>
<h3 id="Problem-K-Untangling-Chain"><a href="#Problem-K-Untangling-Chain" class="headerlink" title="Problem K Untangling Chain"></a>Problem K Untangling Chain</h3><p>Solved By ManuShi (+,02:49)</p>
<h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4><p>给定一个操作序列，每个操作(a,b)a代表走a，b代表走完a后接下来向左向右。让你重设a使得所有线段不相交</p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>维护当前走过的minx,miny,maxx,maxy。显然走到这样一个长方形外面下步往左往右都不会碰到，可以理解为一圈一圈往外跑</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> dir[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">int</span> maxx=<span class="number">0</span>,minx=<span class="number">0</span>,maxy=<span class="number">0</span>,miny=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;num,&amp;dir[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//0-&gt;right,1-&gt;down,2-&gt;left,3-&gt;up</span></span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>,nowx=<span class="number">0</span>,nowy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i)<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(now)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,maxx-nowx+<span class="number">1</span>);</span><br><span class="line">                nowx=maxx+<span class="number">1</span>;</span><br><span class="line">                maxx=nowx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,nowy-miny+<span class="number">1</span>);</span><br><span class="line">                nowy=miny<span class="number">-1</span>;</span><br><span class="line">                miny=nowy;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,nowx-minx+<span class="number">1</span>);</span><br><span class="line">                nowx=minx<span class="number">-1</span>;</span><br><span class="line">                minx=nowx;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,maxy-nowy+<span class="number">1</span>);</span><br><span class="line">                nowy=maxy+<span class="number">1</span>;</span><br><span class="line">                maxy=nowy;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dir[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                now=(now<span class="number">-1</span>+<span class="number">4</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dir[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                now=(now+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Problem-L-Vacation-Plans"><a href="#Problem-L-Vacation-Plans" class="headerlink" title="Problem L Vacation Plans"></a>Problem L Vacation Plans</h3><p>Unsolved</p>
]]></content>
      <categories>
        <category>训练日常</category>
      </categories>
      <tags>
        <tag>训练日常</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 1014 火星人prefix(Splay+二分+Hash)</title>
    <url>/2018/10/01/BZOJ%20-%201014%20%E7%81%AB%E6%98%9F%E4%BA%BAprefix(Splay+%E4%BA%8C%E5%88%86+Hash)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于无修改的LCP，常用的算法是后缀数组/二分+Hash。但当场景转换为带修改的LCP查询时，后缀数组就无能为力了，因为这样每次都要重建一次后缀数组才能知道LCP的值。但对于二分+Hash来说，我们只要能够知道一段字符串的hash即可，而Hash值显然是可以用Splay维护的，同时Splay也同时支持插入和修改操作。对于题目要求的三种操作，我们这样实现：</p>
<ol>
<li>查询操作：二分长度，令两个位置为x,y。我们查找排行为x-1和x+len的两个节点，令其为pre和nxt。将pre splay到根(pre-&gt;splay())，nxt splay到pre的儿子(nxt-&gt;splay(pre))。那么nxt的左儿子就是我们需要的区间。由于旋转操作时维护了Hash值，所以我们直接取该节点上维护的Hash值就是这段区间的Hash值。对于y的Hash值同理，然后比较Hash值就能判断两个字符串是否相等。</li>
<li>插入操作：查找排行为x和x+1的两个节点，x splay到根，x+1 splay到x的儿子，对x+1的左儿子直接插入即可</li>
<li>修改操作：找到排行为x的节点直接修改</li>
</ol>
<p>需要注意的是由于使用Splay时我们通常会插入头尾两个辅助节点，我们maintain Hash值的时候不能把这两个值算上。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">150005</span>;</span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line">ull num[MAXN];</span><br><span class="line">ull seed[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    seed[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)seed[i]=seed[i<span class="number">-1</span>]*<span class="number">27</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">memoryPool</span>&#123;</span></span><br><span class="line">    T buf[MAXN],*tail,*ret[MAXN];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tail=buf,top=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top?ret[--top]:tail++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retnode</span><span class="params">(T *rub)</span></span>&#123;</span><br><span class="line">        ret[top++]=rub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayTree</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">        node *child[<span class="number">2</span>],*parent,**root;</span><br><span class="line">        <span class="keyword">int</span> sizes,tsz,useful;</span><br><span class="line">        <span class="comment">//tags</span></span><br><span class="line">        ull val,hashs;</span><br><span class="line">        <span class="built_in">node</span>()&#123;</span><br><span class="line">            child[<span class="number">0</span>]=child[<span class="number">1</span>]=<span class="literal">NULL</span>,parent=<span class="literal">NULL</span>;</span><br><span class="line">            sizes=<span class="number">1</span>,tsz=<span class="number">1</span>,hashs=<span class="number">0</span>,useful=<span class="number">1</span>,val=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">node</span>(node *parent,node **root,ull val):<span class="built_in">parent</span>(parent),<span class="built_in">root</span>(root),<span class="built_in">val</span>(val)&#123;</span><br><span class="line">            child[<span class="number">0</span>]=child[<span class="number">1</span>]=<span class="literal">NULL</span>,sizes=<span class="number">1</span>,tsz=<span class="number">1</span>,hashs=val,useful=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parent-&gt;child[<span class="number">0</span>]==<span class="keyword">this</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span></span>&#123;</span><br><span class="line">            sizes=<span class="number">1</span>,hashs=val,tsz=useful?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(child[<span class="number">0</span>])&#123;</span><br><span class="line">                sizes+=child[<span class="number">0</span>]-&gt;sizes,tsz+=child[<span class="number">0</span>]-&gt;tsz;</span><br><span class="line">                <span class="keyword">if</span>(child[<span class="number">0</span>]-&gt;useful)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(useful)hashs=child[<span class="number">0</span>]-&gt;hashs*<span class="number">27</span>+hashs;</span><br><span class="line">                    <span class="keyword">else</span> hashs=child[<span class="number">0</span>]-&gt;hashs;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    hashs=child[<span class="number">0</span>]-&gt;hashs*<span class="number">27</span>+hashs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(child[<span class="number">1</span>])&#123;</span><br><span class="line">                sizes+=child[<span class="number">1</span>]-&gt;sizes,tsz+=child[<span class="number">1</span>]-&gt;tsz;</span><br><span class="line">                <span class="keyword">if</span>(child[<span class="number">1</span>]-&gt;useful)&#123;</span><br><span class="line">                    hashs=hashs*seed[child[<span class="number">1</span>]-&gt;sizes]+child[<span class="number">1</span>]-&gt;hashs;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    hashs=hashs*seed[child[<span class="number">1</span>]-&gt;tsz]+child[<span class="number">1</span>]-&gt;hashs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rotates</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x=<span class="built_in">relation</span>();</span><br><span class="line">            node *oldparent=parent;</span><br><span class="line">            <span class="keyword">if</span>(oldparent-&gt;parent)oldparent-&gt;parent-&gt;child[oldparent-&gt;<span class="built_in">relation</span>()]=<span class="keyword">this</span>;</span><br><span class="line">            parent=oldparent-&gt;parent,oldparent-&gt;child[x]=child[x^<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(child[x^<span class="number">1</span>])child[x^<span class="number">1</span>]-&gt;parent=oldparent;</span><br><span class="line">            child[x^<span class="number">1</span>]=oldparent,oldparent-&gt;parent=<span class="keyword">this</span>,oldparent-&gt;<span class="built_in">maintain</span>(),<span class="built_in">maintain</span>();</span><br><span class="line">            <span class="keyword">if</span>(!parent)*root=<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(node *target=<span class="literal">NULL</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(parent!=target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(parent-&gt;parent==target)<span class="built_in">rotates</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(parent-&gt;<span class="built_in">relation</span>()==<span class="built_in">relation</span>())parent-&gt;<span class="built_in">rotates</span>(),<span class="built_in">rotates</span>();</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">rotates</span>(),<span class="built_in">rotates</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ranks</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !child[<span class="number">0</span>]?<span class="number">0</span>:child[<span class="number">0</span>]-&gt;sizes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;*root;</span><br><span class="line">    memoryPool&lt;node&gt; mp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mp.<span class="built_in">init</span>(),root=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clr</span><span class="params">(node *v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v-&gt;child[<span class="number">0</span>])<span class="built_in">clr</span>(v-&gt;child[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(v-&gt;child[<span class="number">1</span>])<span class="built_in">clr</span>(v-&gt;child[<span class="number">1</span>]);</span><br><span class="line">        mp.<span class="built_in">retnode</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//shouldn&#x27;t splay for selecting segment</span></span><br><span class="line">    <span class="function">node* <span class="title">findByRank</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        node *v=root;</span><br><span class="line">        <span class="keyword">while</span>(k!=v-&gt;<span class="built_in">ranks</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;v-&gt;<span class="built_in">ranks</span>())v=v-&gt;child[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span> k-=v-&gt;<span class="built_in">ranks</span>()+<span class="number">1</span>,v=v-&gt;child[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inserts</span><span class="params">(ull val,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        node *pre=<span class="built_in">findByRank</span>(pos);</span><br><span class="line">        pre-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        node *nxt=<span class="built_in">findByRank</span>(pos+<span class="number">1</span>);</span><br><span class="line">        nxt-&gt;<span class="built_in">splay</span>(pre);</span><br><span class="line">        node *v=mp.<span class="built_in">newnode</span>();</span><br><span class="line">        v-&gt;child[<span class="number">0</span>]=v-&gt;child[<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">        v-&gt;parent=nxt,v-&gt;val=val,v-&gt;hashs=val,v-&gt;root=&amp;root,v-&gt;useful=<span class="number">1</span>,v-&gt;sizes=<span class="number">1</span>,v-&gt;tsz=<span class="number">1</span>;</span><br><span class="line">        nxt-&gt;child[<span class="number">0</span>]=v;</span><br><span class="line">        nxt-&gt;<span class="built_in">maintain</span>(),pre-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(ull val,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        node *v=<span class="built_in">findByRank</span>(pos);</span><br><span class="line">        v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        v-&gt;val=val;</span><br><span class="line">        v-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">node* <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> tl,<span class="keyword">int</span> tr,node *parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        node *v=mp.<span class="built_in">newnode</span>();</span><br><span class="line">        v-&gt;parent=parent,v-&gt;val=v-&gt;hashs=num[mid],v-&gt;root=&amp;root;</span><br><span class="line">        v-&gt;child[<span class="number">0</span>]=v-&gt;child[<span class="number">1</span>]=<span class="literal">NULL</span>,v-&gt;sizes=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid==tl||mid==tr)v-&gt;useful=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;useful=<span class="number">1</span>;</span><br><span class="line">        v-&gt;tsz=v-&gt;useful;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;mid)v-&gt;child[<span class="number">0</span>]=<span class="built_in">build</span>(l,mid<span class="number">-1</span>,tl,tr,v);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)v-&gt;child[<span class="number">1</span>]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r,tl,tr,v);</span><br><span class="line">        v-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        ull hashx=<span class="number">0</span>,hashy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!len)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        node *pre=<span class="built_in">findByRank</span>(x<span class="number">-1</span>);</span><br><span class="line">        pre-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        node *nxt=<span class="built_in">findByRank</span>(x+len);</span><br><span class="line">        nxt-&gt;<span class="built_in">splay</span>(pre);</span><br><span class="line">        hashx=nxt-&gt;child[<span class="number">0</span>]-&gt;hashs;</span><br><span class="line">        pre=<span class="built_in">findByRank</span>(y<span class="number">-1</span>);</span><br><span class="line">        pre-&gt;<span class="built_in">splay</span>();</span><br><span class="line">        nxt=<span class="built_in">findByRank</span>(y+len);</span><br><span class="line">        nxt-&gt;<span class="built_in">splay</span>(pre);</span><br><span class="line">        hashy=nxt-&gt;child[<span class="number">0</span>]-&gt;hashs;</span><br><span class="line">        <span class="keyword">return</span> hashx==hashy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Splay;</span><br><span class="line"><span class="keyword">char</span> cmd[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">gets</span>(str))&#123;</span><br><span class="line">        Splay.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">int</span> q,len=<span class="built_in">strlen</span>(str),temp,x,y;</span><br><span class="line">        num[<span class="number">0</span>]=<span class="number">0</span>,num[len+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)num[i+<span class="number">1</span>]=str[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        Splay.root=Splay.<span class="built_in">build</span>(<span class="number">0</span>,len+<span class="number">1</span>,<span class="number">0</span>,len+<span class="number">1</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;q;z++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,cmd);</span><br><span class="line">            <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                <span class="keyword">int</span> lb=<span class="number">0</span>,ub=len-<span class="built_in">max</span>(x,y)+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(lb&lt;ub)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(lb+ub+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(Splay.<span class="built_in">judge</span>(x,y,mid))lb=mid;</span><br><span class="line">                    <span class="keyword">else</span> ub=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lb);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;temp,cmd);</span><br><span class="line">                Splay.<span class="built_in">modify</span>((ull)(cmd[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>),temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;temp,cmd);</span><br><span class="line">                Splay.<span class="built_in">inserts</span>((ull)(cmd[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>),temp);</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        Splay.<span class="built_in">clr</span>(Splay.root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>平衡树</category>
        <category>Splay</category>
      </categories>
      <tags>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Template</title>
    <url>/2022/03/18/Algorithm%20Template/</url>
    <content><![CDATA[<p>Algorithm Template for Leetcoder user <a href="https://leetcode.com/ManuShi98/">ManuShi98</a>, Codeforces user <a href="https://codeforces.com/profile/KihoMaaya">KihoMaaya</a> and <a href="https://codeforces.com/profile/ManuShi">ManuShi</a>. </p>
<span id="more"></span>
<h1 id="Interval-Query"><a href="#Interval-Query" class="headerlink" title="Interval Query"></a>Interval Query</h1><h2 id="Fenwick-Binary-Index-Tree"><a href="#Fenwick-Binary-Index-Tree" class="headerlink" title="Fenwick(Binary Index Tree)"></a>Fenwick(Binary Index Tree)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Index should start from 1, size should be least 2 larger than real size.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fenwick</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;T&gt; fenw;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function">T <span class="title">lowbit</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((x)&amp;(-x));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">fenwick</span>(<span class="keyword">int</span> _n):<span class="built_in">n</span>(_n) &#123;</span><br><span class="line">        fenw.<span class="built_in">resize</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, T v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x&lt;n) &#123;</span><br><span class="line">            fenw[x]+=v;</span><br><span class="line">            x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        T v = <span class="built_in">T</span>();</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            v += fenw[x];</span><br><span class="line">            x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Segment-Tree-with-lazy-strategy"><a href="#Segment-Tree-with-lazy-strategy" class="headerlink" title="Segment Tree with lazy strategy"></a>Segment Tree with lazy strategy</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">segmentTreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> left, right, length;</span><br><span class="line">    <span class="comment">// Values that should be maintain</span></span><br><span class="line">    T value;</span><br><span class="line">    T lazyValue;</span><br><span class="line">    <span class="built_in">segmentTreeNode</span>() &#123;</span><br><span class="line">        left = <span class="number">-1</span>, right = <span class="number">-1</span>;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">        lazyValue = <span class="number">0</span>;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left &gt;= <span class="number">0</span> &amp;&amp; right &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">segmentTree</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> lazyOn;</span><br><span class="line">    <span class="keyword">bool</span> initReady;</span><br><span class="line">    vector&lt;segmentTreeNode&lt;T&gt; &gt; tree;</span><br><span class="line">    <span class="comment">// READ THIS VECTOR AS DATA</span></span><br><span class="line">    vector&lt;T&gt; nums;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lson</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rson</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (root&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write code here for push up operation.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        tree[root].value = tree[<span class="built_in">lson</span>(root)].value+tree[<span class="built_in">lson</span>(root)].length*tree[<span class="built_in">lson</span>(root)].lazyValue+tree[<span class="built_in">rson</span>(root)].value+tree[<span class="built_in">rson</span>(root)].length*tree[<span class="built_in">rson</span>(root)].lazyValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Write code here for lazy tag push down.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        tree[<span class="built_in">lson</span>(root)].lazyValue+=tree[root].lazyValue;</span><br><span class="line">        tree[<span class="built_in">rson</span>(root)].lazyValue+=tree[root].lazyValue;</span><br><span class="line">        tree[root].value = tree[root].value + tree[root].length*tree[root].lazyValue;</span><br><span class="line">        tree[root].lazyValue = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">segmentTree</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;lazyOn = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;initReady = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">segmentTree</span>(<span class="keyword">int</span> size, <span class="keyword">int</span> left, <span class="keyword">int</span> right, vector&lt;T&gt; nums, <span class="keyword">bool</span> lazyOn = <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(size, left, right, nums, lazyOn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> left, <span class="keyword">int</span> right, vector&lt;T&gt; nums, <span class="keyword">bool</span> lazyOn = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">        tree.<span class="built_in">resize</span>(size*<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;lazyOn = lazyOn;</span><br><span class="line">        <span class="keyword">this</span>-&gt;initReady = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(initReady==<span class="literal">true</span>);</span><br><span class="line">        tree[root].left = left, tree[root].right = right;</span><br><span class="line">        tree[root].length = right-left+<span class="number">1</span>;</span><br><span class="line">        tree[root].value = <span class="number">0</span>;</span><br><span class="line">        tree[root].lazyValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == right) &#123;</span><br><span class="line">            <span class="comment">// Write code here, base case with interval length 1.</span></span><br><span class="line">            tree[root].value = nums[left];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">lson</span>(root), left, mid);</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">rson</span>(root), mid+<span class="number">1</span>, right);</span><br><span class="line">            <span class="built_in">pushUp</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateInterval</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, T val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">updateInterval</span>(<span class="number">1</span>, left, right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// interval update with lazy tag;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateInterval</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right, T val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(initReady==<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right) &#123;</span><br><span class="line">            <span class="comment">// Write code here, update logic</span></span><br><span class="line">            <span class="keyword">if</span>(lazyOn) &#123;</span><br><span class="line">                tree[root].lazyValue += val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[root].left==tree[root].right) &#123;</span><br><span class="line">                    tree[root].value += val;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lazyOn) &#123;</span><br><span class="line">            <span class="built_in">pushDown</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (tree[root].left+tree[root].right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (left&lt;=mid) &#123;</span><br><span class="line">            <span class="built_in">updateInterval</span>(<span class="built_in">lson</span>(root), left, right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right&gt;mid) &#123;</span><br><span class="line">            <span class="built_in">updateInterval</span>(<span class="built_in">rson</span>(root), left, right, val);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushUp</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updatePoint</span><span class="params">(<span class="keyword">int</span> pos, T val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">updatePoint</span>(<span class="number">1</span>, pos, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// point update</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updatePoint</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> pos, T val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(initReady == <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">updateInterval</span>(<span class="number">1</span>, pos, pos, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;=tree[root].left&amp;&amp;tree[root].right&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">return</span> tree[root].value+tree[root].lazyValue*tree[root].length;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(lazyOn) &#123;</span><br><span class="line">                <span class="built_in">pushDown</span>(root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = (tree[root].left+tree[root].right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            T sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(left&lt;=mid) &#123;</span><br><span class="line">                sum+=<span class="built_in">query</span>(<span class="built_in">lson</span>(root), left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;mid) &#123;</span><br><span class="line">                sum+=<span class="built_in">query</span>(<span class="built_in">rson</span>(root), left, right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;tree.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            cerr&lt;&lt;<span class="string">&quot;index:&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">            cerr&lt;&lt;<span class="string">&quot;left:&quot;</span>&lt;&lt;tree[i].left&lt;&lt;endl;</span><br><span class="line">            cerr&lt;&lt;<span class="string">&quot;right:&quot;</span>&lt;&lt;tree[i].right&lt;&lt;endl;</span><br><span class="line">            cerr&lt;&lt;<span class="string">&quot;value:&quot;</span>&lt;&lt;tree[i].value&lt;&lt;endl;</span><br><span class="line">            cerr&lt;&lt;<span class="string">&quot;lazyTag:&quot;</span>&lt;&lt;tree[i].lazyValue&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h1><h1 id="Number-Theory"><a href="#Number-Theory" class="headerlink" title="Number Theory"></a>Number Theory</h1><h2 id="Modular"><a href="#Modular" class="headerlink" title="Modular"></a>Modular</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This template is based on tourist&#x27;s template&lt;Modular&gt;</span></span><br><span class="line"><span class="comment">// Used for modular calculation</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MOD = <span class="number">998244353L</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mint</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span>&amp; x, <span class="keyword">long</span> <span class="keyword">long</span>&amp; y)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>) &#123;</span><br><span class="line">            x=<span class="number">1</span>, y=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">extgcd</span>(b, a%b, y, x);</span><br><span class="line">        y-=a/b*x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line">    <span class="built_in">Mint</span>() &#123;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Mint</span>(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp;x) &#123;</span><br><span class="line">        value = <span class="built_in">normalize</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Mint</span>(<span class="keyword">const</span> Mint &amp;x) &#123;</span><br><span class="line">        value = x.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">normalize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> v = x%MOD;</span><br><span class="line">        <span class="keyword">if</span>(v&lt;<span class="number">0</span>)v+=MOD;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    Mint&amp; <span class="keyword">operator</span> +=(<span class="keyword">const</span> Mint&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span>((value+=other.value)&gt;=MOD) &#123;</span><br><span class="line">            value-=MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mint&amp; <span class="keyword">operator</span> -=(<span class="keyword">const</span> Mint&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span>((value-=other.value)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            value+=MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    Mint&amp; <span class="keyword">operator</span> +=(<span class="keyword">const</span> U&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>+=<span class="built_in">Mint</span>(other);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    Mint&amp; <span class="keyword">operator</span> -=(<span class="keyword">const</span> U&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-=<span class="built_in">Mint</span>(other);    </span><br><span class="line">    &#125;</span><br><span class="line">    Mint&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mint&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mint <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Mint</span>(-value);</span><br><span class="line">    &#125;</span><br><span class="line">    Mint&amp; <span class="keyword">operator</span>*= (<span class="keyword">const</span> Mint&amp; rhs) &#123;</span><br><span class="line">        value = <span class="built_in">normalize</span>(value*rhs.value);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    Mint&amp; <span class="keyword">operator</span>*= (<span class="keyword">const</span> U&amp; other) &#123;</span><br><span class="line">        Mint <span class="built_in">tmp</span>(other);</span><br><span class="line">        value = <span class="built_in">normalize</span>(value*tmp.value);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Mint <span class="title">inv</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// value and MOD should be coprime</span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">gcd</span>(value, MOD)==<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x, y;</span><br><span class="line">        <span class="built_in">extgcd</span>(value, MOD, x, y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Mint</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    Mint&amp; <span class="keyword">operator</span> /=(<span class="keyword">const</span> Mint&amp; other) &#123;</span><br><span class="line">        Mint tmp = other.<span class="built_in">inv</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>*=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Mint&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> value==other.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> Mint&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> value!=other.value;</span><br><span class="line">    &#125;</span><br><span class="line">    Mint <span class="keyword">operator</span> +(<span class="keyword">const</span> Mint&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Mint</span>(value+other.value);</span><br><span class="line">    &#125;</span><br><span class="line">    Mint <span class="keyword">operator</span> -(<span class="keyword">const</span> Mint&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Mint</span>(value-other.value);</span><br><span class="line">    &#125;</span><br><span class="line">    Mint <span class="keyword">operator</span> *(<span class="keyword">const</span> Mint&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Mint</span>(value*other.value);</span><br><span class="line">    &#125;</span><br><span class="line">    Mint <span class="keyword">operator</span> /(<span class="keyword">const</span> Mint&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Mint</span>(<span class="built_in">Mint</span>(value)*other.<span class="built_in">inv</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    Mint <span class="title">power</span><span class="params">(<span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(b&gt;=<span class="number">0</span>);</span><br><span class="line">        Mint x=value, res=<span class="number">1</span>;</span><br><span class="line">        T p = b;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p&amp;<span class="number">1</span>)res*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">to_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>模版</category>
      </categories>
      <tags>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 1047 理想的正方形(单调队列)</title>
    <url>/2018/08/28/BZOJ%20-%201047%20%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2(%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与poj 3690的处理方法非常相似，先利用单调队列处理行长度为n的段的最大最小值，储存在一个数组里，然后在对处理完的数列纵向再跑一次长度为n的单调队列。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1105</span>,MAXSIZE=<span class="number">1000005</span>;</span><br><span class="line"><span class="comment">//flag=0-&gt;min,1=max</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">monoqueue</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    T arr[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> head,tail;</span><br><span class="line">    <span class="built_in">monoqueue</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">monoqueue</span>(<span class="keyword">int</span> flag):<span class="built_in">flag</span>(flag)&#123;</span><br><span class="line">        head=<span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;arr[tail]&lt;x)tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;tail&amp;&amp;arr[tail]&gt;x)tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[++tail]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sz</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail-head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head=<span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tail==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[head+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">monoqueue&lt;<span class="keyword">int</span>&gt; <span class="title">rowmax</span><span class="params">(<span class="number">1</span>)</span>,<span class="title">rowmin</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">colmax</span><span class="params">(<span class="number">1</span>)</span>,<span class="title">colmin</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> mat[MAXN][MAXN],maxrow[MAXN][MAXN],minrow[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> a,b,n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;mat[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q,qmax,qmin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;n;j++)&#123;</span><br><span class="line">                rowmax.<span class="built_in">push</span>(mat[i][j]);</span><br><span class="line">                rowmin.<span class="built_in">push</span>(mat[i][j]);</span><br><span class="line">                q.<span class="built_in">push</span>(mat[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            maxrow[i][j<span class="number">-1</span>]=rowmax.<span class="built_in">top</span>();</span><br><span class="line">            minrow[i][j<span class="number">-1</span>]=rowmin.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">for</span>(;j&lt;b;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rowmax.<span class="built_in">top</span>()==q.<span class="built_in">front</span>())rowmax.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(rowmin.<span class="built_in">top</span>()==q.<span class="built_in">front</span>())rowmin.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(mat[i][j]);</span><br><span class="line">                rowmax.<span class="built_in">push</span>(mat[i][j]);</span><br><span class="line">                rowmin.<span class="built_in">push</span>(mat[i][j]);</span><br><span class="line">                maxrow[i][j]=rowmax.<span class="built_in">top</span>();</span><br><span class="line">                minrow[i][j]=rowmin.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            rowmax.<span class="built_in">clear</span>();</span><br><span class="line">            rowmin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff=INTINF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&lt;b;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;n;i++)&#123;</span><br><span class="line">                colmax.<span class="built_in">push</span>(maxrow[i][j]);</span><br><span class="line">                colmin.<span class="built_in">push</span>(minrow[i][j]);</span><br><span class="line">                qmax.<span class="built_in">push</span>(maxrow[i][j]);</span><br><span class="line">                qmin.<span class="built_in">push</span>(minrow[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            diff=<span class="built_in">min</span>(diff,colmax.<span class="built_in">top</span>()-colmin.<span class="built_in">top</span>());</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;a;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(colmax.<span class="built_in">top</span>()==qmax.<span class="built_in">front</span>())colmax.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(colmin.<span class="built_in">top</span>()==qmin.<span class="built_in">front</span>())colmin.<span class="built_in">pop</span>();</span><br><span class="line">                qmax.<span class="built_in">pop</span>(),qmin.<span class="built_in">pop</span>();</span><br><span class="line">                qmax.<span class="built_in">push</span>(maxrow[i][j]);</span><br><span class="line">                qmin.<span class="built_in">push</span>(minrow[i][j]);</span><br><span class="line">                colmax.<span class="built_in">push</span>(maxrow[i][j]);</span><br><span class="line">                colmin.<span class="built_in">push</span>(minrow[i][j]);</span><br><span class="line">                diff=<span class="built_in">min</span>(diff,colmax.<span class="built_in">top</span>()-colmin.<span class="built_in">top</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            colmax.<span class="built_in">clear</span>();</span><br><span class="line">            colmin.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span>(!qmax.<span class="built_in">empty</span>())qmax.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(!qmin.<span class="built_in">empty</span>())qmin.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,diff);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>单调队列</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 1503 郁闷的出纳员</title>
    <url>/2018/03/06/BZOJ%20-%201503%20%E9%83%81%E9%97%B7%E7%9A%84%E5%87%BA%E7%BA%B3%E5%91%98/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>A操作由于是对全局节点增加一个值，显然暴力修改不可行，我们考虑使用一个temp保存A和S对数据的加减。由于有一个temp，所以I操作我们需要插入的val改为val-temp。对S，我们插入一个暂时的min-temp，然后删除左子树，然后删除之前插入的那个点。F命令使用FindByRank函数，略微修改下内部参数即可（因为原来是第k多）。本题要注意BZOJ该题使用cin，cout会RE。<br><span id="more"></span></p>
<h3 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h3><p>参考了Menci和xehoth的splay模板。吐槽一下这模板怎么删子树是直接改指针的啊？下面的节点直接不回收了。。虽然速度是很快就是了。之前写过一个旋转式的Treap，Splay与它唯一的不同就是Splay操作了，所以这里就记了个内存静态化和Splay操作。</p>
<h4 id="内存静态化"><a href="#内存静态化" class="headerlink" title="内存静态化"></a>内存静态化</h4><p>避免了new指针导致空间占用过大的问题<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> MAXSIZE&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryPool</span> &#123;</span></span><br><span class="line">	T buf[MAXSIZE], *tail, *ext[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		tail = buf, top = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T* <span class="title">newnode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top ? ext[--top] : tail++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">retnode</span><span class="params">(T* rub)</span> </span>&#123;</span><br><span class="line">		ext[top++] = rub;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Splay操作"><a href="#Splay操作" class="headerlink" title="Splay操作"></a>Splay操作</h4><p>Splay在求前趋，后继，插入，删除的时候都要把修改的节点旋转到根上，使得每个操作的期望复杂度都是log。下面定义目标节点为根（或者是任意你想旋转的节点）的父亲。Splay分三种情况：</p>
<ol>
<li>祖父节点为目标节点直接旋转上去</li>
<li>祖父和父亲的左右儿子关系和父亲与自己左右儿子关系相同，先旋转父亲，再旋转自己</li>
<li>不然自己做两次旋转</li>
</ol>
<p>为什么要分2，3的情况？事实上这被称作Splay的双旋，是保证期望时间复杂度为log的重要基础。具体见<a href="https://www.cnblogs.com/noip/archive/2013/05/31/3111169.html">伸展树splay单旋PK双旋</a>。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://oi.men.ci/splay-template/">Splay 模板 + 详细注释</a><br><a href="https://blog.xehoth.cc/Splay/">Splay 学习笔记</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> MAXSIZE&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryPool</span> &#123;</span></span><br><span class="line">	T buf[MAXSIZE], *tail, *ext[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		tail = buf, top = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T* <span class="title">newnode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top ? ext[--top] : tail++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">retnode</span><span class="params">(T* rub)</span> </span>&#123;</span><br><span class="line">		ext[top++] = rub;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">		node *child[<span class="number">2</span>], *parent, **root;</span><br><span class="line">		<span class="keyword">int</span> value, cnt, sizes;</span><br><span class="line">		<span class="built_in">node</span>() &#123; child[<span class="number">0</span>] = child[<span class="number">1</span>] = <span class="literal">NULL</span>; &#125;;</span><br><span class="line">		<span class="built_in">node</span>(node *parent, <span class="keyword">int</span> value, node **root) :<span class="built_in">parent</span>(parent), <span class="built_in">root</span>(root), <span class="built_in">value</span>(value) &#123;</span><br><span class="line">			child[<span class="number">0</span>] = child[<span class="number">1</span>] = <span class="literal">NULL</span>, cnt = sizes = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">relation</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> parent-&gt;child[<span class="number">0</span>] == <span class="keyword">this</span> ? <span class="number">0</span> : <span class="number">1</span>; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(MemoryPool&lt;node, MAXN&gt; &amp;pool)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (child[<span class="number">0</span>])pool.<span class="built_in">retnode</span>(child[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">if</span> (child[<span class="number">1</span>])pool.<span class="built_in">retnode</span>(child[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			sizes = cnt;</span><br><span class="line">			<span class="keyword">if</span> (child[<span class="number">0</span>])sizes += child[<span class="number">0</span>]-&gt;sizes;</span><br><span class="line">			<span class="keyword">if</span> (child[<span class="number">1</span>])sizes += child[<span class="number">1</span>]-&gt;sizes;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">rotates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> x = <span class="built_in">relation</span>();</span><br><span class="line">			node *oldParent = parent;</span><br><span class="line">			<span class="keyword">if</span> (oldParent-&gt;parent)oldParent-&gt;parent-&gt;child[oldParent-&gt;<span class="built_in">relation</span>()] = <span class="keyword">this</span>;</span><br><span class="line">			parent = oldParent-&gt;parent, oldParent-&gt;child[x] = child[x ^ <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (child[x ^ <span class="number">1</span>])child[x ^ <span class="number">1</span>]-&gt;parent = oldParent;</span><br><span class="line">			child[x ^ <span class="number">1</span>] = oldParent, oldParent-&gt;parent = <span class="keyword">this</span>, oldParent-&gt;<span class="built_in">maintain</span>(), <span class="built_in">maintain</span>();</span><br><span class="line">			<span class="keyword">if</span> (!parent)*root = <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(node *targetNode = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (parent != targetNode) &#123;</span><br><span class="line">				<span class="keyword">if</span> (parent-&gt;parent == targetNode)<span class="built_in">rotates</span>();</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">relation</span>() == <span class="built_in">relation</span>())parent-&gt;<span class="built_in">rotates</span>(), <span class="built_in">rotates</span>();</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">rotates</span>(), <span class="built_in">rotates</span>();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">node* <span class="title">preNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">splay</span>();</span><br><span class="line">			<span class="keyword">if</span> (!child[<span class="number">0</span>])<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				node *v = child[<span class="number">0</span>];</span><br><span class="line">				<span class="keyword">while</span> (v-&gt;child[<span class="number">1</span>])v = v-&gt;child[<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">return</span> v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">node* <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="built_in">splay</span>();</span><br><span class="line">			<span class="keyword">if</span> (!child[<span class="number">1</span>])<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				node *v = child[<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">while</span> (v-&gt;child[<span class="number">0</span>])v = v-&gt;child[<span class="number">0</span>];</span><br><span class="line">				<span class="keyword">return</span> v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">ranks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> !child[<span class="number">0</span>] ? <span class="number">0</span> : child[<span class="number">0</span>]-&gt;sizes;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;*root;</span><br><span class="line">	MemoryPool&lt;node, MAXN&gt; pool;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		root = <span class="literal">NULL</span>, pool.<span class="built_in">init</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">node* <span class="title">findNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		node *v = root;</span><br><span class="line">		<span class="keyword">while</span> (v&amp;&amp;v-&gt;value != value)v = (value&lt;v-&gt;value) ? v-&gt;child[<span class="number">0</span>] : v-&gt;child[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> !v ? <span class="literal">NULL</span> : (v-&gt;<span class="built_in">splay</span>(), v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">node* <span class="title">inserts</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		node *v = <span class="built_in">findNode</span>(value);</span><br><span class="line">		<span class="keyword">if</span> (v) &#123;</span><br><span class="line">			v-&gt;cnt++, v-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">			<span class="keyword">return</span> v;</span><br><span class="line">		&#125;</span><br><span class="line">		node **target = &amp;root, *parent = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span> (*target)parent = *target, parent-&gt;sizes++, target = (value&lt;parent-&gt;value) ? &amp;parent-&gt;child[<span class="number">0</span>] : &amp;parent-&gt;child[<span class="number">1</span>];</span><br><span class="line">		*target = pool.<span class="built_in">newnode</span>(), (**target) = <span class="built_in">node</span>(parent, value, &amp;root), (*target)-&gt;<span class="built_in">splay</span>();</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deletes</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; <span class="built_in">deletes</span>(<span class="built_in">findNode</span>(value)); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deletes</span><span class="params">(node *v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (v-&gt;cnt != <span class="number">1</span>) &#123;</span><br><span class="line">			v-&gt;<span class="built_in">splay</span>(), v-&gt;cnt--, v-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">		<span class="keyword">if</span> (!v-&gt;child[<span class="number">0</span>] &amp;&amp; !v-&gt;child[<span class="number">1</span>])root = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!v-&gt;child[<span class="number">0</span>]&amp;&amp;v-&gt;child[<span class="number">1</span>])v-&gt;child[<span class="number">1</span>]-&gt;parent = <span class="literal">NULL</span>, root = v-&gt;child[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!v-&gt;child[<span class="number">1</span>] &amp;&amp; v-&gt;child[<span class="number">0</span>])v-&gt;child[<span class="number">0</span>]-&gt;parent = <span class="literal">NULL</span>, root = v-&gt;child[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			node *pre = v-&gt;<span class="built_in">preNode</span>(), *nexts = v-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">			pre-&gt;<span class="built_in">splay</span>(), nexts-&gt;<span class="built_in">splay</span>(pre), nexts-&gt;child[<span class="number">0</span>]-&gt;<span class="built_in">del</span>(pool);</span><br><span class="line">			pool.<span class="built_in">retnode</span>(nexts-&gt;child[<span class="number">0</span>]), nexts-&gt;child[<span class="number">0</span>] = <span class="literal">NULL</span>, nexts-&gt;<span class="built_in">maintain</span>(), pre-&gt;<span class="built_in">maintain</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		pool.<span class="built_in">retnode</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ranks</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		node *v = <span class="built_in">findNode</span>(value);</span><br><span class="line">		<span class="keyword">if</span> (v)<span class="keyword">return</span> v-&gt;<span class="built_in">ranks</span>();</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			v = <span class="built_in">inserts</span>(value);</span><br><span class="line">			<span class="keyword">int</span> ans = v-&gt;<span class="built_in">ranks</span>();</span><br><span class="line">			<span class="built_in">deletes</span>(v);</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">node* <span class="title">getByRanks</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		node *v = root;</span><br><span class="line">		<span class="keyword">while</span> (!(v-&gt;<span class="built_in">ranks</span>() &lt; k &amp;&amp; v-&gt;<span class="built_in">ranks</span>() + v-&gt;cnt &gt;= k)) v = (k &lt;= v-&gt;<span class="built_in">ranks</span>() ? v-&gt;child[<span class="number">0</span>] : (k -= v-&gt;<span class="built_in">ranks</span>() + v-&gt;cnt, v-&gt;child[<span class="number">1</span>]));</span><br><span class="line">		<span class="keyword">return</span> v-&gt;<span class="built_in">splay</span>(), v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">preNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		node *v = <span class="built_in">findNode</span>(val);</span><br><span class="line">		<span class="keyword">if</span> (v)<span class="keyword">return</span> v-&gt;<span class="built_in">preNode</span>()-&gt;value;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			v = <span class="built_in">inserts</span>(val);</span><br><span class="line">			<span class="keyword">int</span> ans = v-&gt;<span class="built_in">preNode</span>()-&gt;value;</span><br><span class="line">			<span class="built_in">deletes</span>(val);</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">nextNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		node *v = <span class="built_in">findNode</span>(val);</span><br><span class="line">		<span class="keyword">if</span> (v)<span class="keyword">return</span> v-&gt;<span class="built_in">nextNode</span>()-&gt;value;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			v = <span class="built_in">inserts</span>(val);</span><br><span class="line">			<span class="keyword">int</span> ans = v-&gt;<span class="built_in">nextNode</span>()-&gt;value;</span><br><span class="line">			<span class="built_in">deletes</span>(val);</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>, op, ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> ch;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot; %c%d&quot;</span>, &amp;ch, &amp;op);</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (op &gt;= m)<span class="built_in">inserts</span>(op-temp);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;A&#x27;</span>)temp += op;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">				temp -= op;</span><br><span class="line">				node *v = <span class="built_in">inserts</span>(m - temp);</span><br><span class="line">				v-&gt;<span class="built_in">splay</span>();</span><br><span class="line">				<span class="keyword">if</span> (v-&gt;child[<span class="number">0</span>])ans += v-&gt;child[<span class="number">0</span>]-&gt;sizes, pool.<span class="built_in">retnode</span>(v-&gt;child[<span class="number">0</span>]);</span><br><span class="line">				v-&gt;child[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="built_in">deletes</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (!root||op&gt;root-&gt;sizes)<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getByRanks</span>(root-&gt;sizes - op+<span class="number">1</span>)-&gt;value + temp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;sp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">		sp.<span class="built_in">init</span>();</span><br><span class="line">		sp.<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>平衡树</category>
        <category>Splay</category>
      </categories>
      <tags>
        <tag>Splay</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 1143 祭祀river(Dilworth定理)</title>
    <url>/2018/08/15/BZOJ%20-%201143%20%E7%A5%AD%E7%A5%80river(Dilworth%E5%AE%9A%E7%90%86)/</url>
    <content><![CDATA[<p>Dilworth定理学习笔记<br><span id="more"></span></p>
<h3 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h3><p>偏序关系，见<a href="https://zh.wikipedia.org/wiki/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB">维基百科-偏序关系</a><br>偏序集，见<a href="https://baike.baidu.com/item/%E5%81%8F%E5%BA%8F%E9%9B%86">百度百科-偏序集</a><br>链，反链，极大链，极大反链，最大链，最大反链，Dilworth定理，见<a href="http://www.cnblogs.com/fstang/archive/2013/03/31/2991220.html">链-反链-Dilworth定理</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由Dilworth定理可知，我们本题需要计算该有向图中的最长反链（即要求一个最大的集合，其中元素两两不可比较，也就是题中的两两不能通过水流到达），而最长反链就是最小链覆盖。现在问题变成了：如何求一个图的最小链覆盖？我们先考虑一个弱化的问题：如何求一个图的不可相交的最小链覆盖？（即链与链没有交）我们考虑开始的时候每个点都是独立的，割裂的一条路径。然后我们建立一个二分图，将每个点拆成两个点，当有一条a到b的路径时，我们对a到b’连一条边。（为什么是二分图？可以理解为一个点的入度和出度都只能为1，这样保证就是一条链，不然可能就是一个Y字型）。我们不难发现每次增加一条匹配的时候，图中的链就少了一条，那么显然最小链覆盖=原来的节点数-匹配的个数。不过该题中，没有要求链不可相交（因为不要求链是连续的）。因为数据范围只有100，考虑使用floyd进行传递闭包，这样我们就能知道那些点相互可达，这样就变成了可以选“连续的链”的最小链覆盖，也就是我们之前解决的弱化的问题。这样这道题的最终思路就很清晰了：flyod求传递闭包，二分图匹配求最小链覆盖，dilworth定理将其转化成最长反链也就是本题的答案。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">105</span>,MAXM=<span class="number">1005</span>,MAXV=<span class="number">405</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> V;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[MAXV];</span><br><span class="line"><span class="keyword">int</span> match[MAXV];</span><br><span class="line"><span class="keyword">bool</span> used[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    used[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[v].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=G[v][i],w=match[u];</span><br><span class="line">        <span class="keyword">if</span>(w&lt;<span class="number">0</span>||(!used[w]&amp;&amp;<span class="built_in">dfs</span>(w)))&#123;</span><br><span class="line">            match[v]=u;</span><br><span class="line">            match[u]=v;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite_matching</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ms</span>(match,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=V;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(match[v]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">ms</span>(used,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(v))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i][j]|(dp[i][k]&amp;dp[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="built_in">ms</span>(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            dp[u][v]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">floyd</span>();</span><br><span class="line">        V=<span class="number">2</span>*n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])G[i].<span class="built_in">push_back</span>(j+n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tcnt=<span class="built_in">bipartite_matching</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-tcnt);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 2038 小Z的袜子</title>
    <url>/2017/11/13/BZOJ%20-%202038%20%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h4><p>莫队算法是一种解决一系列无修改的区间查询问题的算法。对于区间查询问题，我们通常使用线段树。但是考虑这样一个问题：对[l,r]区间内的计算至少重复三次数的个数。这样的问题如果使用线段树需要在节点上维护区间内数字的个数，而这样维护显然并不能在O(1)完成，因而我们常常使用莫队算法。莫队算法的使用条件是我们可以O(1)时间内通过已知的[l,r]答案得到[l-1,r],[l+1,r],[l,r+1],[l,r-1]的答案，并且我们能够离线询问。通过对询问排序，我们利用O(1)的转移能够以一个较为满意的复杂度解决这个问题(避免重复扫描数列）。这个问题可以使用曼哈顿距离最小生成树来写，但这样写代码似乎太麻烦了些，所以我们使用分块。我们以询问左端点所在的分块的序号为第一关键字，右端点的大小为第二关键字。</p>
<h4 id="莫队算法时间复杂度"><a href="#莫队算法时间复杂度" class="headerlink" title="莫队算法时间复杂度"></a>莫队算法时间复杂度</h4><blockquote>
<p>分块相同时，右端点递增是O(N)的，分块共有O(sqrt(N)) )个，复杂度为O(N^(1.5))<br>分块转移时，右端点最多变化N，分块共有O(sqrt(N) )个，复杂度为O(N^(1.5)<br>分块相同时，左端点最多变化sqrt(N) ，分块转移时，左端点最多变化2sqrt(N) ，共有N个询问，复杂度为O(N^(1.5) )<br>所有总时间复杂度就是O(N^1.5)  </p>
</blockquote>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhuanlan.zhihu.com/p/25017840">莫队算法 (Mo’s Algorithm)</a><br><a href="http://blog.csdn.net/hzj1054689699/article/details/51866615">莫队算法</a></p>
<h4 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h4><p>莫队模板题。令当前可选的袜子为ans<br>ans=(color[i]*(color[i]-1)/2);<br>化简得到ans=(Σ(sum(color[i])2)−(R−L+1))/((R−L+1)∗(R−L))<br>所以更新为ans=ans-ci^2+(ci+1)^2<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line">ll n, m,color[N],a[N],pos[N],ans;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a%b == <span class="number">0</span> ? b : <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span></span><br><span class="line">	ll left, right, id, ans1,ans2;</span><br><span class="line">&#125;Q[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(query q1, query q2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos[q1.left] == pos[q2.left])<span class="keyword">return</span> q1.right &lt; q2.right;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> q1.left &lt; q2.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_id</span><span class="params">(query q1, query q2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> q1.id &lt; q2.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll pos,ll add)</span> </span>&#123;</span><br><span class="line">	ans -= <span class="built_in">sqr</span>(color[a[pos]]);</span><br><span class="line">	color[a[pos]] += add;</span><br><span class="line">	ans += <span class="built_in">sqr</span>(color[a[pos]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll left = <span class="number">1</span>, right = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; Q[i].left) &#123;</span><br><span class="line">			<span class="built_in">update</span>(left, <span class="number">-1</span>);</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (left &gt; Q[i].left) &#123;</span><br><span class="line">			<span class="built_in">update</span>(left<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">			left--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (right &lt; Q[i].right) &#123;</span><br><span class="line">			<span class="built_in">update</span>(right+<span class="number">1</span>, <span class="number">1</span>);	</span><br><span class="line">			right++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (right &gt; Q[i].right) &#123;</span><br><span class="line">			<span class="built_in">update</span>(right, <span class="number">-1</span>);</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Q[i].left==Q[i].right)Q[i].ans1 = <span class="number">0</span>, Q[i].ans2 = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Q[i].ans1 = ans - (right - left + <span class="number">1</span>);</span><br><span class="line">			Q[i].ans2 = (right - left + <span class="number">1</span>)*(right - left);</span><br><span class="line">			ll g = <span class="built_in">gcd</span>(Q[i].ans1, Q[i].ans2);</span><br><span class="line">			Q[i].ans1 = Q[i].ans1 / g, Q[i].ans2 = Q[i].ans2 / g;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m)!=EOF) &#123;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;Q[i].left, &amp;Q[i].right);</span><br><span class="line">			Q[i].id = i;</span><br><span class="line">		&#125;</span><br><span class="line">		ll block = (ll)<span class="built_in">sqrt</span>(n);<span class="comment">//分块</span></span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n;i++) pos[i] = (i<span class="number">-1</span>) / block+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">sort</span>(Q, Q + m, cmp);</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">		<span class="built_in">sort</span>(Q, Q + m, cmp_id);</span><br><span class="line">		<span class="keyword">for</span> (ll i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, Q[i].ans1, Q[i].ans2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>莫队</category>
      </categories>
      <tags>
        <tag>莫队算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 2301 Problem b(莫比乌斯反演+容斥)</title>
    <url>/2018/03/21/BZOJ%20-%202301%20Problem%20b(%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94+%E5%AE%B9%E6%96%A5)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>莫比乌斯反演入门题，看popoqqq的ppt看了好久（本篇博客也是参考了很多他的ppt，然后加上了一些自己的理解），深深感到OI大佬的厉害Orz。<br><span id="more"></span></p>
<h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><h4 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h4><p>首先我们考虑这样一个函数：<br><img src="https://i.loli.net/2020/12/14/m7y6srRMPBYpzIK.png" alt="Mobius-function-1"><br>由F(n)的定义，我们可以得到诸如<br>F(1)=f(1)<br>F(2)=f(1)+f(2)<br>F(3)=f(1)+f(3)<br>F(4)=f(1)+f(2)+f(4)<br>F(5)=f(1)+f(5)<br>F(6)=f(1)+f(2)+f(3)+f(6)<br>的式子。从而我们能从F(n)推得f(n)<br>f(1)=F(1)<br>f(2)=F(2)-F(1)<br>f(3)=F(3)-F(1)<br>f(4)=F(4)-F(2)<br>f(5)=F(5)-F(1)<br>f(6)=F(6)-F(3)-F(2)+F(1)<br>然后一位大牛从这个式子里看出了个规律：<br><img src="https://i.loli.net/2020/12/14/3rSz9Klh2OYufGs.jpg" alt="Mobius-function-2"><br>其中μ(d)为莫比乌斯函数，这就是莫比乌斯反演公式，正确性的证明见popoqqq的ppt</p>
<h4 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h4><p>莫比乌斯函数μ(d)的定义为:</p>
<ol>
<li>d=1,μ(d)=1</li>
<li>d=p1*p2*…*pk为互异素数（互不相同的素数），那么μ(d)=(-1)^k</li>
<li>其他情况μ(d)=0</li>
</ol>
<h4 id="莫比乌斯函数的性质"><a href="#莫比乌斯函数的性质" class="headerlink" title="莫比乌斯函数的性质"></a>莫比乌斯函数的性质</h4><ol>
<li>当n=1时，μ(d)的前缀和为1，否则为0，证明见popoqqq的ppt</li>
<li>莫比乌斯函数是积性函数，所以我们可以使用线性筛来得到莫比乌斯函数（使用定义的第二条）</li>
</ol>
<h4 id="什么情况适合使用莫比乌斯反演"><a href="#什么情况适合使用莫比乌斯反演" class="headerlink" title="什么情况适合使用莫比乌斯反演"></a>什么情况适合使用莫比乌斯反演</h4><p>如果对一个函数f(n)，我们没法直接求出他的值，但我们能够求出他的约束和F(n)或者倍数和，那么我们就可以考虑莫比乌斯反演。接下来我们用bzoj2301来解释如何使用莫比乌斯反演。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为直接求这个询问非常麻烦，我们使用容斥原理将一个询问拆成4个，定义一个cal(a,b,k)函数为x属于[1,a],y属于[1,b]时gcd(x,y)=k数对的个数。那么我们就能将这个询问拆分为cal(b,d,k)-cal(a-1,d,k)-cal(b,c-1,k)+cal(a-1,c-1,k)。那么接下来我们怎么构造莫比乌斯反演？题目问的是x属于[1,n],y属于[1,m],gcd(x,y)=k的数对的个数，我们把这个问题扩张为x属于[1,n],y属于[1,m],k|gcd(x,y)（可以认为gcd(x,y)是k的倍数）数对的个数。对于后一个问题我们可以考虑对n来说k的倍数有几个，即floor(n/k),对y进行同样的考虑，所以我们得到了F(k)的表达式为floor(n/k)*floor(m/k)。这里我们能看出什么？我们碰到类似的这种题，我们要尽可能把F(k)设置为一个能够轻松得到的函数，而一般来说k的倍数/约数都是比较容易能够求得的，同时得到的函数F(k)和f(k)的关系也符合莫比乌斯反演，所以碰到类似的题要是没有思路的话尝试下倍数和和约数和是一个不错的选择。那么接下来我们就得到了莫比乌斯反演公式：<br><img src="https://i.loli.net/2020/12/14/4b1JAhpMQZNzUkq.png" alt="Mobius-function-3"><br>通过枚举k的倍数我们能够在O(n)中解决问题。但是考虑到询问有5w个，最后的复杂度O(n^2)是不能接受的。考虑优化<br>通过观察发现floor(n/d)这个式子，我们发现取值最多有2根号n个取值。那么对floor(n/d)*floor(m/d)我们有2（根号n+根号m）个取值。注意这里不是两者相乘。为什么？我们考虑在d变化过程中n/d和m/d变化的过程。借用《POI XIV Stage.1 Queries Zap 解题报告》中的图：<br><img src="https://i.loli.net/2020/12/14/kizwY1xlNRFmbtI.jpg" alt="Mobius-example-1"><br>我们把横轴看成d，每个竖杠代表着值的改变。我想很显然地我们能感受到为什么这个二元组只有2（根号n+根号m）个取值。所以我们枚举取值，并对莫比乌斯函数求一个前缀和，就能在O(sqrt(n))的时间内得到答案。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    a/=k,b/=k;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">min</span>(a,b),ans=<span class="number">0</span>,last;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i=last+<span class="number">1</span>)&#123;</span><br><span class="line">        last=<span class="built_in">min</span>(a/(a/i),b/(b/i));</span><br><span class="line">        ans+=(a/i)*(b/i)*(sum[last]-sum[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上是枚举取值的代码。第五行是为了找出两个比值结果中的较小值。我个人理解实际上不除k的话似乎不会影响算法的正确性？似乎只是为了减少枚举的次数？我也不是很确定，如果有大佬知道的话望周知，谢谢！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://wenku.baidu.com/view/fbec9c63ba1aa8114431d9ac.html">莫比乌斯反演 - By popoqqq</a></li>
<li><a href="https://www.cnblogs.com/candy99/p/6209502.html">BZOJ2301: [HAOI2011]Problem b[莫比乌斯反演 容斥原理]【学习笔记】</a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mobi[MAXN],vis[MAXN],prime[MAXN],sum[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mobi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            prime[cnt++]=i;</span><br><span class="line">            mobi[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;MAXN;j++)&#123;</span><br><span class="line">            vis[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//if there exists more than one same prime number, the value of the function is 0.</span></span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                mobi[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mobi[i*prime[j]]=-mobi[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++)sum[i]=sum[i<span class="number">-1</span>]+mobi[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cal(b,d,k)-cal(a-1,d)-cal(b,c-1,k)+cal(a-1,c-1,k)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    a/=k,b/=k;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">min</span>(a,b),ans=<span class="number">0</span>,last;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i=last+<span class="number">1</span>)&#123;</span><br><span class="line">        last=<span class="built_in">min</span>(a/(a/i),b/(b/i));</span><br><span class="line">        ans+=(a/i)*(b/i)*(sum[last]-sum[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cal</span>(b,d,k)-<span class="built_in">cal</span>(a<span class="number">-1</span>,d,k)-<span class="built_in">cal</span>(b,c<span class="number">-1</span>,k)+<span class="built_in">cal</span>(a<span class="number">-1</span>,c<span class="number">-1</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="built_in">prework</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(a,b,c,d,k));</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>莫比乌斯反演</category>
      </categories>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 3211 花神游历各国(线段树开方)</title>
    <url>/2018/07/22/BZOJ%20-%203211%20%E8%8A%B1%E7%A5%9E%E6%B8%B8%E5%8E%86%E5%90%84%E5%9B%BD(%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%BC%80%E6%96%B9)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要求线段树实现：</p>
<ol>
<li>区间求和</li>
<li>区间开方</li>
</ol>
<p>我们发现，对于一个不全是0或1的区间，我们对每个数开方后的和只能暴力计算，无法优化。但我们发现即便是10^9的数字也会在6次内变成1(因为取了floor)，而0，1开方后是不会再变化的，因而对于全是0，1的区间做开方后的区间和同样是不会再变化的。所以对全是0或1的区间我们记录一个flag，更新碰到flag就直接退出不用再更新。为什么这样的时间复杂度能够保证？我们已经知道10^9的数字最多开方6次，因而对于10^5的每个点，最多只有六次更新是有效的（其他直接O(1)continue了),所以时间复杂度是6*10^5，因而完全能接受。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MAXN=<span class="number">100005</span>;</span><br><span class="line">ll n,m;</span><br><span class="line">ll like[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll l,r,val,flag;</span><br><span class="line">&#125;tree[MAXN*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll root)</span></span>&#123;</span><br><span class="line">    tree[root].val=tree[root*<span class="number">2</span>].val+tree[root*<span class="number">2</span>+<span class="number">1</span>].val;</span><br><span class="line">    tree[root].flag=tree[root*<span class="number">2</span>].flag&amp;tree[root*<span class="number">2</span>+<span class="number">1</span>].flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll l,ll r,ll root)</span></span>&#123;</span><br><span class="line">    tree[root].l=l,tree[root].r=r,tree[root].flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[root].val=like[l];</span><br><span class="line">        <span class="keyword">if</span>(tree[root].val&lt;=<span class="number">1</span>)tree[root].flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll mid=(tree[root].l+tree[root].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(l,mid,root*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(mid+<span class="number">1</span>,r,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll l,ll r,ll root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[root].flag)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[root].l&amp;&amp;tree[root].r&lt;=r&amp;&amp;tree[root].l==tree[root].r)&#123;</span><br><span class="line">        tree[root].val=(ll)<span class="built_in">sqrt</span>(tree[root].val);</span><br><span class="line">        <span class="keyword">if</span>(tree[root].val&lt;=<span class="number">1</span>)tree[root].flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll mid=(tree[root].l+tree[root].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">update</span>(l,r,root*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">update</span>(l,r,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll l,ll r,ll root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[root].l&amp;&amp;tree[root].r&lt;=r)<span class="keyword">return</span> tree[root].val;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll mid=(tree[root].l+tree[root].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(l,r,root*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)<span class="keyword">return</span> <span class="built_in">query</span>(l,r,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(l,r,root*<span class="number">2</span>)+<span class="built_in">query</span>(l,r,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    ll x,l,r;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;like[i]);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;x,&amp;l,&amp;r);</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(l,r,<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">update</span>(l,r,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 3224 Tyvj 1728 普通平衡树</title>
    <url>/2018/02/20/BZOJ%20-%203224%20Tyvj%201728%20%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91%20/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Treap模板题<br><span id="more"></span></p>
<h3 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h3><p>Treap是一种二叉查找树，并同时满足了二叉树和堆的性质。每次插入一个值的时候，如果我们新建了一个树上的点，我们给这个点赋一个随机值，然后通过旋转等操作来维护Treap堆的性质，保证了树高期望是O(logn)，从而保证了时间复杂度。<br>通常来说Treap在常数大小和代码复杂度上要小于Splay。</p>
<h4 id="节点定义"><a href="#节点定义" class="headerlink" title="节点定义"></a>节点定义</h4><p>常规情况下Treap的节点需要储存左右儿子，子树大小，节点中相同元素的数量，随机数的值，我因为在treap结构体中定义了一个nexts的二维数组，所以node中没有写lson,rson。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    T val;</span><br><span class="line">    <span class="keyword">int</span> siz,rnd,cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="节点信息更新"><a href="#节点信息更新" class="headerlink" title="节点信息更新"></a>节点信息更新</h4><p>更新最基本的子树大小以及一些其他内容，时间复杂度O(1)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    tree[k].siz=tree[nexts[k][<span class="number">0</span>]].siz+tree[nexts[k][<span class="number">1</span>]].siz+tree[k].cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>与常见二叉树旋转类似，见参考中的详细解释</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>从根开始，比根的val小进入左儿子，不然进入右儿子，如果值相等重复计数器cnt++。如果该节点尚未被创建，则初始化一个新节点放到当前位置。时间复杂度O(logn)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)&#123;</span><br><span class="line">            tree[nodecnt].siz=tree[nodecnt].cnt=<span class="number">1</span>,tree[nodecnt].val=x,tree[nodecnt].rnd=<span class="built_in">rand</span>();</span><br><span class="line">            p=nodecnt++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[p].siz++;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val==x)tree[p].cnt++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;tree[p].val)&#123;</span><br><span class="line">            <span class="built_in">ins</span>(nexts[p][<span class="number">1</span>],x);</span><br><span class="line">            <span class="keyword">if</span>(tree[nexts[p][<span class="number">1</span>]].rnd&lt;tree[p].rnd)<span class="built_in">rotation</span>(p,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">ins</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">            <span class="keyword">if</span>(tree[nexts[p][<span class="number">0</span>]].rnd&lt;tree[p].rnd)<span class="built_in">rotation</span>(p,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>如果删除值小于当前值，进入左子树，大于进入右子树<br>当等于时：<br>如果出现次数cnt大于1，cnt—<br>不然我们就要删除该节点，并分三种情况讨论：</p>
<ol>
<li>没有左和右儿子，直接删除</li>
<li>有左或右儿子，用该儿子替换该节点</li>
<li>有左和右儿子，旋转并进入当前节点旋转后的位置，直到变成2的情况</li>
</ol>
<p>时间复杂度O(logn)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//since through the data of bzoj we can find that x may not exist</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val==x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[p].cnt&gt;<span class="number">1</span>)tree[p].cnt--,tree[p].siz--;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nexts[p][<span class="number">0</span>]==<span class="number">0</span>||nexts[p][<span class="number">1</span>]==<span class="number">0</span>)p=nexts[p][<span class="number">0</span>]+nexts[p][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tree[nexts[p][<span class="number">0</span>]].rnd&lt;tree[nexts[p][<span class="number">1</span>]].rnd)&#123;</span><br><span class="line">                    <span class="built_in">rotation</span>(p,<span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">del</span>(p,x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">rotation</span>(p,<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">del</span>(p,x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[p].val&lt;x)&#123;</span><br><span class="line">            tree[p].siz--;</span><br><span class="line">            <span class="built_in">del</span>(nexts[p][<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tree[p].siz--;</span><br><span class="line">            <span class="built_in">del</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="查询数字x的排名"><a href="#查询数字x的排名" class="headerlink" title="查询数字x的排名"></a>查询数字x的排名</h4><p>递归查询，并记录小于这个值的节点数量，时间复杂度O(logn)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRank</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val==x)<span class="keyword">return</span> tree[nexts[p][<span class="number">0</span>]].siz+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[p].val&lt;x)<span class="keyword">return</span> tree[nexts[p][<span class="number">0</span>]].siz+tree[p].cnt+<span class="built_in">findRank</span>(nexts[p][<span class="number">1</span>],x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findRank</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="查询排名为x的数"><a href="#查询排名为x的数" class="headerlink" title="查询排名为x的数"></a>查询排名为x的数</h4><p>与查排名思路相同<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">findKey</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[nexts[p][<span class="number">0</span>]].siz&gt;=x)<span class="keyword">return</span> <span class="built_in">findKey</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[nexts[p][<span class="number">0</span>]].siz+tree[p].cnt&lt;x)<span class="keyword">return</span> <span class="built_in">findKey</span>(nexts[p][<span class="number">1</span>],x-tree[nexts[p][<span class="number">0</span>]].siz-tree[p].cnt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> tree[p].val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="查找前驱和后继"><a href="#查找前驱和后继" class="headerlink" title="查找前驱和后继"></a>查找前驱和后继</h4><p>相同思路<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">findPre</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> -INF;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val&lt;x)<span class="keyword">return</span> <span class="built_in">max</span>(tree[p].val,<span class="built_in">findPre</span>(nexts[p][<span class="number">1</span>],x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findPre</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//find the minimum number that larger than x</span></span><br><span class="line">    <span class="function">T <span class="title">findNext</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val&gt;x)<span class="keyword">return</span> <span class="built_in">min</span>(tree[p].val,<span class="built_in">findNext</span>(nexts[p][<span class="number">0</span>],x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findNext</span>(nexts[p][<span class="number">1</span>],x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/fengzhiyuan/articles/7994428.html">关于Treap学习总结</a><br><a href="http://blog.csdn.net/the_useless/article/details/54095675">总结-Treap</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    T val;</span><br><span class="line">    <span class="keyword">int</span> siz,rnd,cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treap</span>&#123;</span></span><br><span class="line">    node&lt;T&gt; tree[MAXN];</span><br><span class="line">    <span class="keyword">int</span> nexts[MAXN][<span class="number">2</span>],root,nodecnt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">ms</span>(nexts,<span class="number">0</span>);</span><br><span class="line">        root=<span class="number">0</span>,nodecnt=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//maintain the data of the node like size</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        tree[k].siz=tree[nexts[k][<span class="number">0</span>]].siz+tree[nexts[k][<span class="number">1</span>]].siz+tree[k].cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0-&gt;left,1-&gt;right</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotation</span><span class="params">(<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> dir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v=nexts[k][dir^<span class="number">1</span>];</span><br><span class="line">        nexts[k][dir^<span class="number">1</span>]=nexts[v][dir];</span><br><span class="line">        nexts[v][dir]=k;</span><br><span class="line">        <span class="built_in">push_up</span>(k);</span><br><span class="line">        <span class="built_in">push_up</span>(k=v);<span class="comment">//help us change the root</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&amp; in order to change the l/r son</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)&#123;</span><br><span class="line">            tree[nodecnt].siz=tree[nodecnt].cnt=<span class="number">1</span>,tree[nodecnt].val=x,tree[nodecnt].rnd=<span class="built_in">rand</span>();</span><br><span class="line">            p=nodecnt++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[p].siz++;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val==x)tree[p].cnt++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;tree[p].val)&#123;</span><br><span class="line">            <span class="built_in">ins</span>(nexts[p][<span class="number">1</span>],x);</span><br><span class="line">            <span class="keyword">if</span>(tree[nexts[p][<span class="number">1</span>]].rnd&lt;tree[p].rnd)<span class="built_in">rotation</span>(p,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">ins</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">            <span class="keyword">if</span>(tree[nexts[p][<span class="number">0</span>]].rnd&lt;tree[p].rnd)<span class="built_in">rotation</span>(p,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="comment">//since through the data of bzoj we can find that x may not exist</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val==x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[p].cnt&gt;<span class="number">1</span>)tree[p].cnt--,tree[p].siz--;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nexts[p][<span class="number">0</span>]==<span class="number">0</span>||nexts[p][<span class="number">1</span>]==<span class="number">0</span>)p=nexts[p][<span class="number">0</span>]+nexts[p][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tree[nexts[p][<span class="number">0</span>]].rnd&lt;tree[nexts[p][<span class="number">1</span>]].rnd)&#123;</span><br><span class="line">                    <span class="built_in">rotation</span>(p,<span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">del</span>(p,x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">rotation</span>(p,<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">del</span>(p,x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[p].val&lt;x)&#123;</span><br><span class="line">            tree[p].siz--;</span><br><span class="line">            <span class="built_in">del</span>(nexts[p][<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tree[p].siz--;</span><br><span class="line">            <span class="built_in">del</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//query the rank of x</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRank</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val==x)<span class="keyword">return</span> tree[nexts[p][<span class="number">0</span>]].siz+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[p].val&lt;x)<span class="keyword">return</span> tree[nexts[p][<span class="number">0</span>]].siz+tree[p].cnt+<span class="built_in">findRank</span>(nexts[p][<span class="number">1</span>],x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findRank</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//query the number ranked x</span></span><br><span class="line">    <span class="function">T <span class="title">findKey</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[nexts[p][<span class="number">0</span>]].siz&gt;=x)<span class="keyword">return</span> <span class="built_in">findKey</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tree[nexts[p][<span class="number">0</span>]].siz+tree[p].cnt&lt;x)<span class="keyword">return</span> <span class="built_in">findKey</span>(nexts[p][<span class="number">1</span>],x-tree[nexts[p][<span class="number">0</span>]].siz-tree[p].cnt);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> tree[p].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//find the maximum number that smaller than x</span></span><br><span class="line">    <span class="function">T <span class="title">findPre</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> -INF;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val&lt;x)<span class="keyword">return</span> <span class="built_in">max</span>(tree[p].val,<span class="built_in">findPre</span>(nexts[p][<span class="number">1</span>],x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findPre</span>(nexts[p][<span class="number">0</span>],x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//find the minimum number that larger than x</span></span><br><span class="line">    <span class="function">T <span class="title">findNext</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)<span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(tree[p].val&gt;x)<span class="keyword">return</span> <span class="built_in">min</span>(tree[p].val,<span class="built_in">findNext</span>(nexts[p][<span class="number">0</span>],x));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">findNext</span>(nexts[p][<span class="number">1</span>],x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">treap&lt;<span class="keyword">int</span>&gt; tp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        tp.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cho,val;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;cho,&amp;val);</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(cho)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    tp.<span class="built_in">ins</span>(tp.root,val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    tp.<span class="built_in">del</span>(tp.root,val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tp.<span class="built_in">findRank</span>(tp.root,val));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tp.<span class="built_in">findKey</span>(tp.root,val));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tp.<span class="built_in">findPre</span>(tp.root,val));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tp.<span class="built_in">findNext</span>(tp.root,val));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>平衡树</category>
        <category>Treap</category>
      </categories>
      <tags>
        <tag>Treap</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 16E Fish(状压dp)</title>
    <url>/2018/05/24/CodeForces%20-%2016E%20Fish(%E7%8A%B6%E5%8E%8Bdp)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单的状压dp。令dp[i]状态中1为已死亡的鱼，0为存活的鱼，dp表示转移到这个状态的概率。dp转移方程为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dp[state|(<span class="number">1</span>&lt;&lt;i)]+=topro*dp[state]*pro[j][i];</span><br><span class="line">dp[state|(<span class="number">1</span>&lt;&lt;j)]+=topro*dp[state]*pro[i][j];</span><br></pre></td></tr></table></figure><br>这个转移方程的灵感来自于全概率公式，topro表示选中这一对鱼的概率，pro表示i吃j的概率，由全概率公式可知我们把所有可能的转移概率加起来就是最终答案。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">18</span>],pro[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">18</span>);i++)dp[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                cin&gt;&gt;pro[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> state=<span class="number">0</span>;state&lt;(<span class="number">1</span>&lt;&lt;n);state++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tstate=state,cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">double</span> topro;</span><br><span class="line">            <span class="keyword">while</span>(tstate)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tstate&amp;<span class="number">1</span>)cnt++;</span><br><span class="line">                tstate&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt==n<span class="number">-1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            cnt=n-cnt;</span><br><span class="line">            topro=<span class="number">2</span>/(<span class="keyword">double</span>)(cnt*(cnt<span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(((state&gt;&gt;i)&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(((state&gt;&gt;j)&amp;<span class="number">1</span>))<span class="keyword">continue</span>;</span><br><span class="line">                    dp[state|(<span class="number">1</span>&lt;&lt;i)]+=topro*dp[state]*pro[j][i];</span><br><span class="line">                    dp[state|(<span class="number">1</span>&lt;&lt;j)]+=topro*dp[state]*pro[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line">            temp^=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">if</span>(i)cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>)&lt;&lt;dp[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ - 4259 残缺的字符串(FFT)</title>
    <url>/2018/08/29/BZOJ%20-%204259%20%E6%AE%8B%E7%BC%BA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2(FFT)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参考了<a href="https://www.cnblogs.com/clrs97/p/4814499.html">Claris老师的博客</a>。该题最精髓的操作就是将形如A[i]B[i]的式子做一个反转，形成A[n-i]B[i]的卷积形式，这样就能够往FFT上靠。似乎BZOJ一道权限题“快速傅里叶变换”也是使用了这样一个思路，所以这应该算一个比较经典的技巧，在知道这一步后这道题就是FFT的模板题了。<br><span id="more"></span></p>
<h3 id="一点小吐槽"><a href="#一点小吐槽" class="headerlink" title="一点小吐槽"></a>一点小吐槽</h3><ol>
<li>为什么洛谷这题只有5组数据…最后我不得不拿了BZOJ的数据重测了下。</li>
<li>O2优化这么牛批的嘛，不开跑了4.4s开了只跑了1s多啊？如果比5组的总时间，那么速度上快了将近10倍。。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1048576</span>;<span class="comment">//1&lt;&lt;n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real,image;</span><br><span class="line">    <span class="built_in">Complex</span>()&#123;real=<span class="number">0</span>,image=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> real)&#123;<span class="keyword">this</span>-&gt;real=real,image=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> real,<span class="keyword">double</span> image)&#123;<span class="keyword">this</span>-&gt;real=real,<span class="keyword">this</span>-&gt;image=image;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(c.real+real,c.image+image);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> -(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real-c.real,image-c.image);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> *(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(c.real*real-c.image*image,c.real*image+c.image*real);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> *(<span class="keyword">double</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real*x,image*x);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> /(<span class="keyword">double</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real/x,image/x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Complex <span class="title">rev</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real,-image);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex *a, <span class="keyword">int</span> n,Complex *com)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k)&lt;n)k++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;k;j++)<span class="keyword">if</span> (i&amp;(<span class="number">1</span> &lt;&lt; j))t |= (<span class="number">1</span> &lt;&lt; (k - j - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (i&lt;t)<span class="built_in">swap</span>(a[i], a[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>;l &lt;= n;l *= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = l / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (Complex *p = a;p&lt;a + n;p += l) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">				Complex t = com[n / l*i] * p[m + i];</span><br><span class="line">				p[m + i] = p[i] - t;</span><br><span class="line">				p[i]=p[i]+t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Complex omega[MAXN], iomega[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		omega[i] = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2</span> * PI / n*i), <span class="built_in">sin</span>(<span class="number">2</span> * PI / n*i));</span><br><span class="line">		iomega[i] = omega[i].<span class="built_in">rev</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dft</span><span class="params">(Complex *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fft</span>(a, n,omega);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idft</span><span class="params">(Complex *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fft</span>(a, n,iomega);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)a[i] =a[i]/ n;</span><br><span class="line">&#125;</span><br><span class="line">Complex a[MAXN], b[MAXN],c[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN],B[MAXN];</span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n))&#123;</span><br><span class="line">        <span class="comment">//ms(ans,0),ms(A,0),ms(B,0);</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="keyword">if</span>(<span class="built_in">isalpha</span>(str[m-i<span class="number">-1</span>]))A[i]=str[m-i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(<span class="built_in">isalpha</span>(str[i]))B[i]=str[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len&lt;(m+n))len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">init</span>(len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)a[i]=<span class="built_in">Complex</span>(A[i]*A[i]*A[i],<span class="number">0</span>),b[i]=<span class="built_in">Complex</span>(B[i],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dft</span>(a,len),<span class="built_in">dft</span>(b,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)c[i]=a[i]*b[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)a[i]=<span class="built_in">Complex</span>(A[i],<span class="number">0</span>),b[i]=<span class="built_in">Complex</span>(B[i]*B[i]*B[i],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dft</span>(a,len),<span class="built_in">dft</span>(b,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)c[i]=c[i]+a[i]*b[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)a[i]=<span class="built_in">Complex</span>(A[i]*A[i],<span class="number">0</span>),b[i]=<span class="built_in">Complex</span>(B[i]*B[i],<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dft</span>(a,len),<span class="built_in">dft</span>(b,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)c[i]=c[i]-a[i]*b[i]*<span class="number">2.0</span>;</span><br><span class="line">        <span class="built_in">idft</span>(c,len);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&lt;n;i++)<span class="keyword">if</span>(<span class="built_in">fabs</span>(c[i].real)&lt;<span class="number">0.5</span>)ans[cnt++]=i-m+<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i)<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>FFT</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 1710B Rain(前缀和+几何)</title>
    <url>/2022/08/14/CodeForces%20-%201710B%20Rain(%E5%89%8D%E7%BC%80%E5%92%8C+%E5%87%A0%E4%BD%95)/</url>
    <content><![CDATA[<p>比赛中没有想到解法。在浏览其他人代码时，发现许多选手使用了相同的思路，似乎是一种广为人知的解法，特此记录一下。<br><span id="more"></span></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>按照题意可知，每个坐标x的雨将会形成一个坐标为xi, 高度pi的三角形，如下图。<br><img src="https://s2.loli.net/2022/08/15/FzYGxpnDRXUtEk1.jpg" alt="cf1710b-1.jpg"><br>显然我们能发现，最高点一定是出现在雨的坐标xi上。那么首先就是如何计算每一个xi的高度。虽然一个雨的情况比较好计算，但是多个雨的情况，我们应当如何计算呢？一个比较常规的方式是进行两次前缀和的计算。下面我们以一个雨的情况进行讨论<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">高度: 0  0  1  2  1  0  0&lt;br&gt;</span><br><span class="line">差分:  0  1  1  -1 -1 0&lt;br&gt;</span><br><span class="line">二阶差分:1  0  -2  0 1</span><br></pre></td></tr></table></figure><br>可以注意到，在二阶差分下，我们只要在左端点+1，最高点-2， 右端点+1，就能还原差分数组和高度数组。对于数据范围不大的题，这样就能完美还原图。但是这题的差分范围来到了1e9，遍历1e9来还原差分数组是不能接受的。这里的处理有两种方法。第一种是tutorial的方式，从左到右访问离散化的各个点。注意到虽然从差分数组到原数组的遍历非常麻烦，但是斜率的变化仅在二阶差分不为0的点发生。也就是说，斜率的变化是O(n)的。这样我们就能避免1e9的遍历，而对于高度的变化，我们能够通过kx+b类似的方式从第一个点开始从左向右扫描，进而算出所有点高度。在这一步上，tutorial和jiangly等oi的做法不太一样。tutorial是从左往右，一个一个点进行扫描。而jiangly的做法如下图所示<br><img src="https://s2.loli.net/2022/08/15/S1egIH9OynkzmiG.jpg" alt="cf1710b-2.jpg"><br>我看了很多选手都使用了这种做法。思路是对于这个三角形，延长两条边到y轴。那么截距就是pi-xi/pi+xi。然后我们将每个xi的截距相加作为每个雨对于xi点截距的贡献，参考代码中的value数组，最开始对l，j，r计算后，数组中保存的就是过xi直线的截距和。然后我们就只要考虑斜率对xi的影响了。这里只需要简单地用二阶差分计算即可。总体上来说，这种思路想要将所有雨对xi这个点的贡献，转化为一条直线表示。先计算截距贡献，再计算斜率（二阶差分转差分）。这似乎是一个非常通用的思路，思考过程和代码也非常简单。非常值得借鉴。</p>
<p>在解决了每个点高度的问题后，我们需要考虑，删除什么样的点，才能让大于m的点小于m。我们来看这样一张图：<br><img src="https://s2.loli.net/2022/08/15/pOqRWVEvh8JmYP7.jpg" alt="cf1710b-3.jpg"><br>假定在xi我们有pi大于m。那么显然，当且仅当雨水点（注意是顶点）xj在红色虚线上方时，该雨水的贡献是大于pi-m的（如图中的绿色点）。所以移走xj是可以让xi变成小于m的状态。<br><img src="https://s2.loli.net/2022/08/15/siWozyAnwrepq1B.jpg" alt="cf1710b-4.jpg"><br>推广到多个雨水的场景，那么显然一次性能够让所有雨水小于m的点就是这种形状的交集，也就是上图中的红色区域（画板中没有类似的工具，但相信还是比较好理解的）。那么问题就是如何计算红色区域。这里tutorial和jiangly的做法又有所不同。tutorial的代码非常令人迷惑，思路如下：<br><img src="https://s2.loli.net/2022/08/15/hxrERq93mAeuz2d.jpg" alt="cf1710b-5.jpg"><br><img src="https://s2.loli.net/2022/08/15/6rDR91KQbjaJnOB.jpg" alt="cf1710b-6.jpg"><br>通过上图，我们能够发现，决定哪一根直线在上的，是它的截距。同时斜率的组合一定是k为-1和k为1的两根直线。所以我们只要将两个斜率的直线，分别求出斜率的最大值，就能找到处于交集，或者说上方的两根直线的截距。在知道截距后，显然能够通过一些比较简单的计算获取到交点的坐标（代入方程计算，这里不展开）。这种方法非常方便，但是第一眼看到这道题时不容易得到。</p>
<p>jiangly使用的则是另外一种思路：对所有直线分两类：斜率为1和斜率为-1。我们现在用斜率为1的进行讨论，斜率为-1的思路非常类似。首先，我们令dp[i]为满足对所有横坐标小于i的点能够被删除需要满足点的最小高度。我们是知道每个雨的高度的，在之前差分的过程中已经计算过了。此刻我们初始化所有点对dp的贡献。对于高度小于m的点，我们直接设高度为-inf，作用是在计算中让其不产生贡献。对高度大于m的，我们设高度为pi-m，可以理解为上图中的y1为pi-m。然后我们从左往右扫描。当扫到上图中的x2时，我们能看到，原先在x1的高度pi-m此时应该是pi-m+x2-x1。这时我们将其与y2比较并取最大值。如果x2高度本来就小于m，那么-inf显然不会有贡献。从左往右计算完后，再从右往左计算k=-1的dp数组。这样两者的最大值就是在i点，高于dpi的高度即可让所有点不泛洪。这个思路非常简单明了，不需要额外的思考。是一个非常方便的思路，也非常直观。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll mod)</span></span>&#123;ll ans=<span class="number">1ll</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=(ans*a)%mod;a=a*a%mod,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">mt19937 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randint</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">int</span> out = <span class="built_in">rng</span>() % (r - l + <span class="number">1</span>) + l; <span class="keyword">return</span> out &gt;= l ? out : out + r - l + <span class="number">1</span>; &#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">x</span><span class="params">(n)</span>, <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> v = x;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(v));</span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(v)), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">value</span><span class="params">(n)</span>, <span class="title">diff2</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> c = v.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(v), x[i]-p[i])-v.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(v), x[i])-v.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(v), x[i] + p[i]) - v.<span class="built_in">begin</span>();</span><br><span class="line">        value[l]+=(p[i]-x[i]);</span><br><span class="line">        value[j]-=(p[i]-x[i]);</span><br><span class="line">        value[j]+=(x[i]+p[i]);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; c) &#123;</span><br><span class="line">            value[r]-=(x[i]+p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        diff2[l] += <span class="number">1</span>;</span><br><span class="line">        diff2[j] -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( r &lt; c ) &#123;</span><br><span class="line">            diff2[r] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c; i++ ) &#123;</span><br><span class="line">        diff2[i] += diff2[i<span class="number">-1</span>];</span><br><span class="line">        value[i] += value[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++ ) &#123;</span><br><span class="line">        value[i] += diff2[i] * v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> nice = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( value[i] &lt;= m ) &#123;</span><br><span class="line">            value[i] = <span class="number">-1e18</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value[i] -= m;</span><br><span class="line">            nice = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( nice ) &#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">string</span>(n, <span class="string">&#x27;1&#x27;</span>)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> pre = value, suf = value;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; c; i++ ) &#123;</span><br><span class="line">        pre[i] = <span class="built_in">max</span>(pre[i], pre[i<span class="number">-1</span>]+v[i]-v[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = c<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i-- ) &#123;</span><br><span class="line">        suf[i] = <span class="built_in">max</span>(suf[i], suf[i+<span class="number">1</span>]+v[i+<span class="number">1</span>]-v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(v), x[i]) - v.<span class="built_in">begin</span>();</span><br><span class="line">        ans += p[i] &gt;= <span class="built_in">max</span>(pre[j], suf[j])?<span class="string">&#x27;1&#x27;</span>:<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>前缀和</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 1721E Prefix Function Queries(KMP优化)</title>
    <url>/2022/08/30/CodeForces%20-%201721E%20Prefix%20Function%20Queries(KMP%E4%BC%98%E5%8C%96)/</url>
    <content><![CDATA[<p>cf中碰到了kmp的一种优化方式，特此记录。<br><span id="more"></span></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们知道，kmp是一种在线算法。即便我们不断在字符串尾部添加字符，我们依然能保持O(n)的均摊复杂度。然而，该题在给予字符串s后，要求对q个字符串ti分别求next数组。这种时候我们的均摊分析就失效了。因为对于每一个新的t，我们可能都需要跳n步来求fail数组。这是不能接受的。为此引出了一个新的概念<a href="https://oi-wiki.org/string/kmp/#%E6%A0%B9%E6%8D%AE%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8A%A8%E6%9C%BA">前缀函数自动机</a>.<br>首先我们来看kmp的代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ Version By OI wiki</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = (<span class="keyword">int</span>)s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = pi[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) j = pi[j - <span class="number">1</span>];<span class="comment">//可以看到，如果我们之前进行了类似while回朔的话，我们在未来的某个位置i&#x27;，可能还会跳到当前的位置i，然后再走一遍这个while循环。这是非常浪费时间的。所以这里是优化的核心，可以考虑通过dp的方式优化。</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == s[j]) j++;</span><br><span class="line">    pi[i] = j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一个显然的想法，那么我们能直接使用一个一维的jump数组，记录i位置我们最终跳到了哪里。这样未来while回朔到i位置的时候，如果发现jump数组已经访问过就直接更新到jump(i)，这样可以达到真正的O(1)更新。这个思路的优化方向是正确的，但是我们考虑这样一种情形：假定fail指针指向的是某一个a,子串形式为…ab…。当我们fail指针指向a，且子串形式也为…ab…时，我们能沿用此处的jump函数。但是如果是…ac…呢？显然此时jump函数就失效了。因此，jump数组的形式应该是jump(i, j)，代表跳到位置i，待匹配字符为j时，最终移动的位置。</p>
<p>对于OI Wiki的O(n^2)优化到O(n)我觉得是比较好理解的。简而言之就是使用dp的思想，避免重复跳跃。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OI Wiki O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_automaton</span><span class="params">(string s, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; aut)</span> </span>&#123;</span><br><span class="line">  s += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; pi = <span class="built_in">prefix_function</span>(s);</span><br><span class="line">  aut.<span class="built_in">assign</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; c++) &#123;</span><br><span class="line">      <span class="keyword">int</span> j = i;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; <span class="string">&#x27;a&#x27;</span> + c != s[j]) j = pi[j - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> + c == s[j]) j++;</span><br><span class="line">      aut[i][c] = j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OI Wiki O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_automaton</span><span class="params">(string s, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; aut)</span> </span>&#123;</span><br><span class="line">  s += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; pi = <span class="built_in">prefix_function</span>(s);</span><br><span class="line">  aut.<span class="built_in">assign</span>(n, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">26</span>; c++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; <span class="string">&#x27;a&#x27;</span> + c != s[i])</span><br><span class="line">        aut[i][c] = aut[pi[i - <span class="number">1</span>]][c];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        aut[i][c] = i + (<span class="string">&#x27;a&#x27;</span> + c == s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里在参考jiangly代码的时候，我发现他跳过了prefix_function这一步，直接在同一个循环中求jump和fail数组。核心代码在于<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&amp;&amp;str[i] == <span class="string">&#x27;a&#x27;</span>+j) &#123;</span><br><span class="line">    jump[i][j] = i+<span class="number">1</span>;</span><br><span class="line">    fail[i] = jump[fail[i<span class="number">-1</span>]][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>原理是fail(i-1)一定是一个最长公共前后缀，这样我们只要看fail(i-1)落到的位置（注意这里不同kmp的fail数组可能含义不一样。比如abcda，我实现的fail最后一个a的值是1，所以你能发现jump[fail[i-1]][j]正好就是在b上做比较。）这样就能方便地在一个循环中算出fail了。</p>
<p>最后，我们以一个表格作收尾，方便你更好地理解jump和fail的计算过程。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">a</th>
<th style="text-align:center">c</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">jumpa</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">jumpb</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">jumpc</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">fail</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>+<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> fail[MAXN] = &#123;<span class="number">0</span>&#125;, jump[MAXN][<span class="number">26</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">length</span>();</span><br><span class="line">    fail[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    jump[<span class="number">0</span>][str[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;str[i] == <span class="string">&#x27;a&#x27;</span>+j) &#123;</span><br><span class="line">                jump[i][j] = i+<span class="number">1</span>;</span><br><span class="line">                fail[i] = jump[fail[i<span class="number">-1</span>]][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                jump[i][j] = jump[fail[i<span class="number">-1</span>]][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        string q;</span><br><span class="line">        cin&gt;&gt;q;</span><br><span class="line">        <span class="keyword">int</span> m = q.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; n+m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(q[i-n]==<span class="string">&#x27;a&#x27;</span>+j) &#123;</span><br><span class="line">                    jump[i][j] = i+<span class="number">1</span>;</span><br><span class="line">                    fail[i] = jump[fail[i<span class="number">-1</span>]][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    jump[i][j] = jump[fail[i<span class="number">-1</span>]][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;fail[i]&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n+m<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//    int T;</span></span><br><span class="line"><span class="comment">//    cin&gt;&gt;T;</span></span><br><span class="line"><span class="comment">//    while(T--) &#123;</span></span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>kmp</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 1768D Lucky Permutation</title>
    <url>/2023/01/08/CodeForces%20-%201768D%20Lucky%20Permutation/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个数组，问需要多少次两个元素的交换操作后使得数组中只有一个逆序对<br><span id="more"></span></p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>首先考虑使用交换操作使数组排序需要多少次。有个显而易见的结论是，如果我们将每个元素指向自己本身指向的位置,如下图<br><img src="https://s2.loli.net/2023/01/09/V9uzstmpqxNKrio.jpg" alt="cf-1768d-1.jpg"><br>那么显然，这样的边会恰好连成一个环。而环中所有的元素复位，只需要环的大小-1次操作。对于整个数组来说，这个次数是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{k}(circlesize-1)</script><p>将k个环size相加为n，所以可以化简得到（k是环的个数）</p>
<script type="math/tex; mode=display">
n-k</script><p>在解决了使用交换操作使数组排序需要多少次后，我们来看我们现在手上的这个问题。我们来观察只有一个逆序对的数组是什么样的：</p>
<blockquote>
<p>2 1 3 4 5…<br><br>1 3 2 4 5…<br><br>1 2 4 3 5…<br></p>
</blockquote>
<p>显然这些数组都有一个显著的特点即是排序的数组对相邻的两个元素进行反转。那么参考排序的方法，我们将相邻两个元素，假定原先是i位置指向x,i+1指向y，改成i位置指向y，i+1指向x，再跑原来的方法，就可以得到只有一个逆序对的数组了。但是这种方法需要遍历所有相邻元素跑我们的算法，时间复杂度是O(n^2)。实际上我们可以先跑一遍排序算法，然后对每个数组元素染色。我们可以发现，这种交叉操作后，如果两个相邻元素原本是同一个环，那么交换后环就会+1。反之，环会-1.具体实现可以参考Codeforce中的<a href="https://codeforces.com/blog/entry/110901?#comment-989404">评论</a>，这个评论的图我认为已经非常直观了。这样就避免了一个一个交换再O(n)判断环的个数这种麻烦操作。所以最后总结一下思路就是：</p>
<ol>
<li>跑最少交换排序算法，获得环的个数</li>
<li>遍历数组，观察是否有相邻元素在相同的环，是则答案变成n-(k+1<br>)，否则答案是n-(k-1)</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin&gt;&gt;nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]!=<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(vis[j]==<span class="number">-1</span>) &#123;</span><br><span class="line">            vis[j] = i;</span><br><span class="line">            j = nums[j]<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==vis[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-cnt-flag&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> T=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">      <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 2B The least round way</title>
    <url>/2017/12/11/CodeForces%20-%202B%20The%20least%20round%20way/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>CCPC比赛的时候感觉自己dp实在太差了，最近准备补一波<br>本题的意思是从一个矩阵的左上角走到右下角（只能向右和向下），问路径上数的积的末尾最少有几个零。我们可以想到把2和5分开考虑，分别dp然后看右下角是2少还是5少，然后回溯打印路径。需要注意的是当矩阵中有0时，我们要考虑如果我们右下角能得到一个一个末尾0都没有的数的话，我们选这种方案，不然经过0的路径一定是最优的（末尾只有一个0）。<br>转移方程：<br>dp1[i][j]=min(dp1[i-1][j],dp1[i][j-1])+two[i][j];<br>dp2[i][j]=min(dp2[i-1][j],dp2[i][j-1])+five[i][j];<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/STACK:102400000,102400000&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>],two[<span class="number">1005</span>][<span class="number">1005</span>],five[<span class="number">1005</span>][<span class="number">1005</span>],dp1[<span class="number">1005</span>][<span class="number">1005</span>],dp2[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>,x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp1[i][j]=dp2[i][j]=INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)flag=<span class="number">1</span>,x=i,y=j;</span><br><span class="line">                <span class="keyword">int</span> temp1,temp2;</span><br><span class="line">                temp1=temp2=a[i][j];</span><br><span class="line">                <span class="keyword">if</span>(temp1&gt;<span class="number">0</span>&amp;&amp;temp1%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(temp1%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        two[i][j]++;</span><br><span class="line">                        temp1/=<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp2&gt;<span class="number">0</span>&amp;&amp;temp2%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(temp2%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                        five[i][j]++;</span><br><span class="line">                        temp2/=<span class="number">5</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp1[<span class="number">0</span>][<span class="number">0</span>]=two[<span class="number">0</span>][<span class="number">0</span>],dp2[<span class="number">0</span>][<span class="number">0</span>]=five[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp1[i][j]=<span class="built_in">min</span>(dp1[i][j],dp1[i<span class="number">-1</span>][j]+two[i][j]);</span><br><span class="line">                    dp2[i][j]=<span class="built_in">min</span>(dp2[i][j],dp2[i<span class="number">-1</span>][j]+five[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp1[i][j]=<span class="built_in">min</span>(dp1[i][j],dp1[i][j<span class="number">-1</span>]+two[i][j]);</span><br><span class="line">                    dp2[i][j]=<span class="built_in">min</span>(dp2[i][j],dp2[i][j<span class="number">-1</span>]+five[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag&amp;&amp;(dp1[n<span class="number">-1</span>][n<span class="number">-1</span>]&gt;<span class="number">1</span>&amp;&amp;dp2[n<span class="number">-1</span>][n<span class="number">-1</span>]&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)<span class="built_in">printf</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;n<span class="number">-1</span>;i++)<span class="built_in">printf</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">char</span> cmd[<span class="number">2005</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp1[n<span class="number">-1</span>][n<span class="number">-1</span>]&lt;dp2[n<span class="number">-1</span>][n<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp1[n<span class="number">-1</span>][n<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">int</span> ind=<span class="number">2</span>*n<span class="number">-3</span>,i=n<span class="number">-1</span>,j=n<span class="number">-1</span>;</span><br><span class="line">                cmd[<span class="number">2</span>*n<span class="number">-2</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span>(ind&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;dp1[i<span class="number">-1</span>][j]+two[i][j]==dp1[i][j])cmd[ind]=<span class="string">&#x27;D&#x27;</span>,i--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>) cmd[ind]=<span class="string">&#x27;R&#x27;</span>,j--;</span><br><span class="line">                    ind--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp2[n<span class="number">-1</span>][n<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">int</span> ind=<span class="number">2</span>*n<span class="number">-3</span>,i=n<span class="number">-1</span>,j=n<span class="number">-1</span>;</span><br><span class="line">                cmd[<span class="number">2</span>*n<span class="number">-2</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span>(ind&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;dp2[i<span class="number">-1</span>][j]+five[i][j]==dp2[i][j])cmd[ind]=<span class="string">&#x27;D&#x27;</span>,i--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">0</span>)cmd[ind]=<span class="string">&#x27;R&#x27;</span>,j--;</span><br><span class="line">                    ind--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 739B Alyona and a tree(树上差分+二分)</title>
    <url>/2018/03/16/CodeForces%20-%20739B%20Alyona%20and%20a%20tree(%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86+%E4%BA%8C%E5%88%86)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很显然对于任意一个点u，如果有一个点v满足dist(v,u)&lt;=a[u],那么v到u路径上的所有点都是满足条件的点。所以我们考虑二分（也可以倍增），找到第一个符合条件的点。然后我们使用树上差分来统计结果。我们令所有点ans=1，再对符合条件的点的父亲我们ans—，最后dfs的时候从子节点往父节点合并答案即可。注意最后答案要ans-1，因为初始ans=1即自己被多统计了一次。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line">ll dis[MAXN],a[MAXN];</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,ll&gt; &gt; G[MAXN];</span><br><span class="line">vector&lt;pair&lt;ll,<span class="keyword">int</span>&gt; &gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	ans[x]=<span class="number">1</span>;</span><br><span class="line">	ll t=dis[x]-a[x];</span><br><span class="line">	<span class="keyword">int</span> pos=<span class="built_in">lower_bound</span>(que.<span class="built_in">begin</span>(),que.<span class="built_in">end</span>(),<span class="built_in">make_pair</span>(t,<span class="number">0</span>))-que.<span class="built_in">begin</span>();</span><br><span class="line">	pos--;</span><br><span class="line">	<span class="keyword">if</span>(pos&gt;=<span class="number">0</span>)ans[que[pos].second]--;</span><br><span class="line">	que.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(dis[x],x));</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;pair&lt;<span class="keyword">int</span>,ll&gt; &gt;::iterator it=G[x].<span class="built_in">begin</span>();it!=G[x].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">		dis[it-&gt;first]=dis[x]+it-&gt;second;</span><br><span class="line">		<span class="built_in">dfs</span>(it-&gt;first);</span><br><span class="line">		ans[x]+=ans[it-&gt;first];</span><br><span class="line">	&#125;</span><br><span class="line">	que.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,v;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">		<span class="built_in">ms</span>(ans,<span class="number">0</span>),<span class="built_in">ms</span>(dis,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;v,&amp;w);</span><br><span class="line">			G[v].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i+<span class="number">1</span>,w));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		que.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)G[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>树上差分</category>
      </categories>
      <tags>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 665E Beautiful Subarrays</title>
    <url>/2018/02/24/CodeForces%20-%20665E%20Beautiful%20Subarrays/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑将区间异或转换，我们处理一个异或前缀和数组，我们能够发现通过前缀和数组原来i-j的区间异或变成了pre[j]^pre[i-1]。然后我们逐个插入前缀和pre[i]，再由高到低逐个枚举k的二进制位:</p>
<ul>
<li>当k的第i位为1：显然我们要找一个使pre[i]异或后为1的数才能保证比k-1大。</li>
<li>当k的第i位为0：如果我们找到一个使pre[i]异或后为1的数，那么异或后的数肯定比k-1大，我们直接在ans中加上这种数的个数（所以节点上要维护一个val次数数组），然后异或为1的不再考虑，我们进入异或后该位为0的节点。</li>
</ul>
<p>对每个前缀和的答案累加就是最后的答案。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> pre[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trie</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> nodecnt,nexts[<span class="number">22</span>*MAXN][<span class="number">2</span>],val[<span class="number">22</span>*MAXN];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		nodecnt=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">ms</span>(nexts,<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">		val[nodecnt]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> nodecnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inserts</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">int</span> ch=(n&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(nexts[now][ch]==<span class="number">-1</span>)nexts[now][ch]=<span class="built_in">newnode</span>();</span><br><span class="line">			now=nexts[now][ch];</span><br><span class="line">			val[now]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> now=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">int</span> t=(x&gt;&gt;i)&amp;<span class="number">1</span>,p=(y&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(p)&#123;</span><br><span class="line">				<span class="keyword">if</span>(nexts[now][!t]!=<span class="number">-1</span>)now=nexts[now][!t];</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(nexts[now][!t]!=<span class="number">-1</span>)sum+=val[nexts[now][!t]];</span><br><span class="line">				now=nexts[now][t];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(now==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,k;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k))&#123;</span><br><span class="line">		pre[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;pre[i]);</span><br><span class="line">			pre[i]^=pre[i<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		tree.<span class="built_in">init</span>();</span><br><span class="line">		tree.<span class="built_in">inserts</span>(<span class="number">0</span>);</span><br><span class="line">		ll sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			sum+=(ll)(tree.<span class="built_in">query</span>(pre[i],k<span class="number">-1</span>));</span><br><span class="line">			tree.<span class="built_in">inserts</span>(pre[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>Trie</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 56D Changing a String(dp)</title>
    <url>/2018/04/01/CodeForces%20-%2056D%20Changing%20a%20String(dp)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>第一反应是最长公共子序列乱搞。。显然不对啊<br>我们令dp[i][j]为从s1(1,i)转换到s2(1,j)所需要的最少步数。分四种情况讨论:</p>
<ol>
<li>插入：dp[i][j]=min(dp[i][j],dp[i][j-1]+1)，我们已经知道从s1(1,i)转换到s2(1,j-1)，所以在j-1尾插入字来尝试更新dp[i][j]</li>
<li>删除：dp[i][j]=min(dp[i][j],dp[i-1][j]+1)，我们已经知道从s1(1,i-1)转换到s2(1,j)，因为已经转换完成，所以i比之前i-1的状态只需要删去一个字符就能变成s2(1,j)</li>
<li>替换：dp[i][j]=dp[i-1][j-1]+1，转移显而易见</li>
<li>不变：dp[i][j]=dp[i-1][j-1],同样是转移显而易见。</li>
</ol>
<p>最后打印路径即可，因为这里操作可逆<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">1050</span>],s2[<span class="number">1050</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1050</span>][<span class="number">1050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s1))&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s2);</span><br><span class="line">        <span class="keyword">int</span> n=<span class="built_in">strlen</span>(s1),m=<span class="built_in">strlen</span>(s2);</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)dp[i][<span class="number">0</span>]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)dp[<span class="number">0</span>][i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">strlen</span>(s1);i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">strlen</span>(s2);j++)&#123;</span><br><span class="line">                dp[i][j]=INF;</span><br><span class="line">                <span class="keyword">if</span>(j&amp;&amp;dp[i][j<span class="number">-1</span>]+<span class="number">1</span>&lt;dp[i][j])dp[i][j]=dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;dp[i<span class="number">-1</span>][j]+<span class="number">1</span>&lt;dp[i][j])dp[i][j]=dp[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;j&amp;&amp;dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>&lt;dp[i][j])dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;&amp;j&amp;&amp;s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]&amp;&amp;dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&lt;dp[i][j])dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][m]);</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>||m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m&amp;&amp;dp[n][m<span class="number">-1</span>]+<span class="number">1</span>==dp[n][m])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;INSERT %d %c\n&quot;</span>,n+<span class="number">1</span>,s2[m<span class="number">-1</span>]);</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n&amp;&amp;dp[n<span class="number">-1</span>][m]+<span class="number">1</span>==dp[n][m])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;DELETE %d\n&quot;</span>,n);</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m&amp;&amp;n&amp;&amp;dp[n<span class="number">-1</span>][m<span class="number">-1</span>]+<span class="number">1</span>==dp[n][m])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;REPLACE %d %c\n&quot;</span>,n,s2[m<span class="number">-1</span>]);</span><br><span class="line">                n--,m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> n--,m--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 739C Alyona and towers(线段树)</title>
    <url>/2018/07/29/CodeForces%20-%20739C%20Alyona%20and%20towers(%E7%BA%BF%E6%AE%B5%E6%A0%91)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据题意，我们需要对一个序列执行区间加和计算最长的递增/递减/先增后减序列。对于区间加法，很自然想到线段树，我们考虑线段树维护序列。我们这样考虑，维护一个区间最左端符合条件序列的长度，维护一个区间最右端符合条件序列的长度。push_up的时候用跨过中点的合法序列，左儿子最大值，右儿子最大值一起考虑来更新最大值。在常规序列处理线段树的情况下，我们会发现我们合并时需要左儿子最右端序列的值和右儿子最左端序列的值（合并左右儿子需要比较大小）。注意在这里我们如果用常规的线段树维护序列，这个时候我们要把lazy的值推到最深的儿子，显然这样lazy操作失去了他的意义，在合并时会导致时间复杂度爆炸。因而我们考虑线段树维护差分序列，这样我们每次只要单点更新两个端点。现在我们可以放心合并不需要担心单点查询复杂度的问题。在合并时，我们要考虑这样几种情况：</p>
<ol>
<li>不合法情况，无法用跨过中点的左右两个序列合并来更新节点最大值：右端序列和左/右差分序列有一个为0（左右有一段常数列），左边为-1（递减）右边为1（递增），此时节点的左连续序列就是左儿子的左连续序列，右连续序列就是右儿子的右连续序列，直接上传，最大值继承左右儿子的最大值。</li>
<li>合法情况：我们更新在继承左右儿子的最大值的基础上再用跨过中点的序列来更新节点的最大值。注意此时的左右连续序列不能想都不想像刚刚那样直接继承，我们考虑这样一个例子，如果左儿子的整个覆盖的区间都是连续递增的，就比如为1，2，3，而此时右儿子是4，5，6。我们显然能发现这个时候区间的左连续序列长度是6而不是3。所以我们需要在左右连续序列的计算上分类讨论。具体细节见代码。</li>
</ol>
<span id="more"></span>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MAXN=<span class="number">300005</span>;</span><br><span class="line">ll arr[MAXN],diff[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    ll l,r,maxs,lmax,rmax;</span><br><span class="line">&#125;tree[MAXN*<span class="number">4</span>];</span><br><span class="line"><span class="function">ll <span class="title">sign</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span>?<span class="number">1</span>:n&lt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll root)</span></span>&#123;</span><br><span class="line">    ll mid=(tree[root].l+tree[root].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    tree[root].maxs=<span class="built_in">max</span>(tree[root*<span class="number">2</span>].maxs,tree[root*<span class="number">2</span>+<span class="number">1</span>].maxs);</span><br><span class="line">    <span class="comment">//situation that can&#x27;t merge</span></span><br><span class="line">    <span class="keyword">if</span>(!diff[mid]||!diff[mid+<span class="number">1</span>]||<span class="built_in">sign</span>(diff[mid])&lt;<span class="built_in">sign</span>(diff[mid+<span class="number">1</span>]))&#123;</span><br><span class="line">        tree[root].lmax=tree[root*<span class="number">2</span>].lmax;</span><br><span class="line">        tree[root].rmax=tree[root*<span class="number">2</span>+<span class="number">1</span>].rmax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tree[root].maxs=<span class="built_in">max</span>(tree[root].maxs,tree[root*<span class="number">2</span>].rmax+tree[root*<span class="number">2</span>+<span class="number">1</span>].lmax);</span><br><span class="line">        <span class="keyword">if</span>(tree[root*<span class="number">2</span>].maxs==tree[root*<span class="number">2</span>].r-tree[root*<span class="number">2</span>].l+<span class="number">1</span>)&#123;</span><br><span class="line">            tree[root].lmax=tree[root*<span class="number">2</span>].lmax+tree[root*<span class="number">2</span>+<span class="number">1</span>].lmax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tree[root].lmax=tree[root*<span class="number">2</span>].lmax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[root*<span class="number">2</span>+<span class="number">1</span>].maxs==tree[root*<span class="number">2</span>+<span class="number">1</span>].r-tree[root*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)&#123;</span><br><span class="line">            tree[root].rmax=tree[root*<span class="number">2</span>].rmax+tree[root*<span class="number">2</span>+<span class="number">1</span>].rmax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tree[root].rmax=tree[root*<span class="number">2</span>+<span class="number">1</span>].rmax;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll l,ll r,ll root)</span></span>&#123;</span><br><span class="line">    tree[root].l=l,tree[root].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)tree[root].maxs=tree[root].lmax=tree[root].rmax=diff[l]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(l,mid,root*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(mid+<span class="number">1</span>,r,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll pos,ll val,ll root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[root].l==tree[root].r)&#123;</span><br><span class="line">        diff[pos]+=val;</span><br><span class="line">        tree[root].maxs=tree[root].lmax=tree[root].rmax=diff[pos]?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll mid=(tree[root].l+tree[root].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos&lt;=mid)<span class="built_in">update</span>(pos,val,root*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(pos,val,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">	ll n,m,l,r,d;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;arr[i]);</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++)diff[i]=arr[i+<span class="number">1</span>]-arr[i];</span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1</span>)<span class="built_in">build</span>(<span class="number">1</span>,n<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%I64d%I64d%I64d&quot;</span>,&amp;l,&amp;r,&amp;d);</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l&gt;<span class="number">1</span>)<span class="built_in">update</span>(l<span class="number">-1</span>,d,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(r&lt;n)<span class="built_in">update</span>(r,-d,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>,tree[<span class="number">1</span>].maxs+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 864E Fire(dp)</title>
    <url>/2018/04/03/CodeForces%20-%20864E%20Fire(dp)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>01背包dp，需要注意的是物品过了d[i]秒后就会焚毁，这使得背包的选取顺序影响了dp的更新。这是为什么呢？考虑我们背包的过程，我们为了避免选取顺序的影响强制给了背包一个顺序，而由于我们先放了a大小的，后面b大小只要空间足够的肯定能放，反之亦然。也就是说背包的选取顺序对dp的更新没有影响。但是这里因为物品焚毁，如果我们先放了a大小的结果发现b已经焚毁了就没法更新状态了，但实际上我们能把先焚毁的b放进去来更新状态，所以我们将d排序后再跑背包dp，这样保证了先焚毁的能更新后焚毁的物品的状态。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,d,p,id;</span><br><span class="line">&#125;pack[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node n1,node n2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1.d&lt;n2.d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2005</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;pack[i].t&gt;&gt;pack[i].d&gt;&gt;pack[i].p;</span><br><span class="line">            pack[i].id=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ms</span>(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//sort(pack,pack+n,cmp);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=pack[i].d<span class="number">-1</span>;j&gt;=pack[i].t;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-pack[i].t]+pack[i].p&gt;dp[j])&#123;</span><br><span class="line">                    dp[j]=dp[j-pack[i].t]+pack[i].p;</span><br><span class="line">                    v[j]=v[j-pack[i].t];</span><br><span class="line">                    v[j].<span class="built_in">push_back</span>(pack[i].id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxs=<span class="number">-1</span>,pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2000</span>;i++)<span class="keyword">if</span>(dp[i]&gt;maxs)maxs=dp[i],pos=i;</span><br><span class="line">        cout&lt;&lt;maxs&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;v[pos].<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=v[pos].<span class="built_in">begin</span>();it!=v[pos].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it!=v[pos].<span class="built_in">begin</span>())cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout&lt;&lt;*it+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2005</span>;i++)v[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 956D Contact ATC(树状数组)</title>
    <url>/2018/07/12/CodeForces%20-%20956D%20Contact%20ATC(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于该题，我们建立如下图所示坐标系，横坐标为风速，纵坐标为在该风速下飞机到达0点的时间。那么显然在两条直线有交点的时候表示两架飞机同时到达0点。<br><img src="https://i.loli.net/2020/12/14/5yGFfQLixDs7UCb.jpg" alt="cf956d"><br>虽然知道了这点，但我们不能O(n^2)求直线交，该题期望的是O(nlogn)的解法。在看了杜老师(%%%)的代码后我学到了一种新的姿势：已知多条直线在两个坐标x1,x2(这道题是-w，w)的情况下，我们可以使用树状数组求逆序对的方式来计算直线的交点数量。以本题为例：我们首先定义一个结构体，储存x(坐标的绝对值),v’(考虑风速后的速度),e(通过该值在左端点一样的情况下能够比较右端点),id。我们将-w各个点的值保存在一个vector up中，w保存在另一个vector down中，然后对两个数组根据到零点时间从小到大排序。对每个点我们利用id记录up（左端点）的左边排名，然后对右端点从上往下计算，每次我们查看在该点左端点之前排名的（也就右端点在它上面，左端点在它下面的直线）有几条，利用树状数组来维护这个值即可，最后的和就是我们需要的答案。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">frac</span>&#123;</span></span><br><span class="line">    ll p,q,e,id;</span><br><span class="line">    <span class="built_in">frac</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">frac</span>(ll p,ll q,ll e,ll id):<span class="built_in">p</span>(p),<span class="built_in">q</span>(q),<span class="built_in">e</span>(e),<span class="built_in">id</span>(id)&#123;&#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> frac &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p*b.q!=b.p*q)&#123;</span><br><span class="line">            <span class="keyword">return</span> p*b.q&lt;b.p*q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//x smaller</span></span><br><span class="line">            <span class="keyword">return</span> p*b.e&lt;b.p*e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;frac&gt; up,down;</span><br><span class="line">ll BIT[MAXN],rk[MAXN];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos,ll val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=pos;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;MAXN)&#123;</span><br><span class="line">        BIT[x]+=val;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=pos;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum+=BIT[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,w,x,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;w)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;v;</span><br><span class="line">            <span class="keyword">if</span>(v&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                up.<span class="built_in">push_back</span>(<span class="built_in">frac</span>(x,-v+w,<span class="number">1</span>,i));</span><br><span class="line">                down.<span class="built_in">push_back</span>(<span class="built_in">frac</span>(x,-v-w,<span class="number">-1</span>,i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                up.<span class="built_in">push_back</span>(<span class="built_in">frac</span>(-x,v-w,<span class="number">-1</span>,i));</span><br><span class="line">                down.<span class="built_in">push_back</span>(<span class="built_in">frac</span>(-x,v+w,<span class="number">1</span>,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(up));</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(down));</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)rk[up[i].id]=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans+=<span class="built_in">sum</span>(rk[down[i].id]);</span><br><span class="line">            <span class="built_in">add</span>(rk[down[i].id]+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 8C Looking for Order</title>
    <url>/2018/01/14/CodeForces%20-%208C%20Looking%20for%20Order%20/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>做的第一道状压dp题。状压dp通常是用来解一些NP完全（没有多项式时间算法）的问题。当然，这种题的范围一般比较小。状压dp的思路就是使用2进制保存状态（这也是为什么范围比较小的原因之一），比如旅行商问题，我们用数位上的1代表以访问过的点，0则是未访问过。通常状压dp的格式是<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="comment">//dp的转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>大部分的时间复杂度为O(n^2log(n))。<br>一开始想写个O((n^2)(2^n))的，结果似乎会TLE，题目要求的复杂度是O((2^n)n)。对于这道题我们能够发现，选取的顺序其实是无关的。所以我们强制要求顺序取，也就是i之前的物品必须都取了，这个思路最终表现在剪枝上，我们对1-(1&lt;&lt;n-1)的每个数都只在最低0位上进行或1的操作。我们很显然发现每个点都取一次，那么显然时间复杂度为O((2^n)n).<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ((x&lt;&lt;1)|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; point[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">24</span>],dist[<span class="number">30</span>][<span class="number">30</span>],trace[<span class="number">1</span>&lt;&lt;<span class="number">24</span>],traceroute[<span class="number">1</span>&lt;&lt;<span class="number">24</span>];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(traceroute[n]&lt;<span class="number">100</span>)ans.<span class="built_in">push</span>(traceroute[n]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans.<span class="built_in">push</span>(traceroute[n]%<span class="number">100</span>);</span><br><span class="line">            ans.<span class="built_in">push</span>(traceroute[n]/<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">out</span>(trace[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx,fy,n;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;fx,&amp;fy))&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        point[<span class="number">0</span>].first=fx,point[<span class="number">0</span>].second=fy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;point[i].first,&amp;point[i].second);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                dist[i][j]=dist[j][i]=(<span class="built_in">sqr</span>(point[i].first-point[j].first)+<span class="built_in">sqr</span>(point[i].second-point[j].second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">24</span>);i++)dp[i]=INF;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&lt;INF)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;j)))&#123;</span><br><span class="line">                        <span class="keyword">int</span> np=i|(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;np&lt;&lt;endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(dp[np]&gt;dp[i]+<span class="number">2</span>*dist[<span class="number">0</span>][j+<span class="number">1</span>])&#123;</span><br><span class="line">                            dp[np]=dp[i]+<span class="number">2</span>*dist[<span class="number">0</span>][j+<span class="number">1</span>];</span><br><span class="line">                            trace[np]=i;</span><br><span class="line">                            traceroute[np]=j+<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(!(np&amp;(<span class="number">1</span>&lt;&lt;k)))&#123;</span><br><span class="line">                                <span class="keyword">int</span> nnp=np|(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">                                <span class="comment">//cout&lt;&lt;nnp&lt;&lt;endl;</span></span><br><span class="line">                                <span class="keyword">if</span>(dp[nnp]&gt;dp[i]+dist[<span class="number">0</span>][j+<span class="number">1</span>]+dist[j+<span class="number">1</span>][k+<span class="number">1</span>]+dist[k+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">                                    dp[nnp]=dp[i]+dist[<span class="number">0</span>][j+<span class="number">1</span>]+dist[j+<span class="number">1</span>][k+<span class="number">1</span>]+dist[k+<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                                    trace[nnp]=i;</span><br><span class="line">                                    traceroute[nnp]=(j+<span class="number">1</span>)*<span class="number">100</span>+k+<span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">out</span>((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//for(int i=0;i&lt;(1&lt;&lt;n)-1;i++)cout&lt;&lt;dp[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">int</span> sizes=ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sizes;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i)<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans.<span class="built_in">top</span>());</span><br><span class="line">            ans.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 0\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>状压dp</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces Gym - 101615D Rainbow Roads(树上差分)</title>
    <url>/2018/03/28/CodeForces%20Gym%20-%20101615D%20Rainbow%20Roads(%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于一个点，考虑可能出现同色边的情况，可以分为两种<br>(1)两个儿子是相同颜色的<br><img src="https://i.loli.net/2020/12/14/iWCsAEI24jleRGX.jpg" alt="CodeForcesGym-101615D-1"><br>如上图，显然2-4，2-5边是相同颜色的，同时对于4，5节点的子树上的点都不是good的，因为显然会有一条从5（4）到该点的一条不是rainbow road的路径。所以我们需要对这样的子树进行染色。<br>(2)父亲和儿子是相同颜色的<br><img src="https://i.loli.net/2020/12/14/5loYNhbMP8SIuTy.jpg" alt="CodeForcesGym-101615D-2"><br>这种情况下我们需要将除2和2的子树以外的所有节点进行染色。因为他们总有一条过1-2-5非彩虹路，所以那些节点不是good的。<br>现在我们解决了如何找出非good点这个问题，但是统计依然是大问题。我们需要对子树进行染色。我们注意到我们只需要最后输出一次答案即可而不需要一直回答询问，所以我们可以考虑树上差分。我们首先求出一个dfs序，得到st[i]和ed[i],对于第一种情况，因为st[i]和ed[i]之间的节点就是i和i的子树，我们使用差分即可。对于第二种情况，我们在根上+1，然后在子树上抵消这个+1即可。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> head[MAXN],color[MAXN],to[MAXN],nxt[MAXN],cnt;</span><br><span class="line"><span class="keyword">int</span> st[MAXN],ed[MAXN],dfn,f[MAXN],sum[MAXN];</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; q[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[cnt]=v;</span><br><span class="line">    color[cnt]=w;</span><br><span class="line">    nxt[cnt]=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    st[u]=++dfn;</span><br><span class="line">    f[u]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(to[i]!=fa)<span class="built_in">dfs</span>(to[i],u);</span><br><span class="line">    &#125;</span><br><span class="line">    ed[u]=dfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        cnt=<span class="number">0</span>,dfn=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ms</span>(head,<span class="number">-1</span>),<span class="built_in">ms</span>(sum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            <span class="built_in">add</span>(u,v,w),<span class="built_in">add</span>(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> m=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];~j;j=nxt[j])q[m++]=<span class="built_in">make_pair</span>(color[j],to[j]);</span><br><span class="line">            <span class="built_in">sort</span>(q,q+m);</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j=k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k=j;k&lt;m&amp;&amp;q[j].first==q[k].first;k++);</span><br><span class="line">                <span class="keyword">if</span>(k&gt;j+<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> x=j;x&lt;k;x++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> y=q[x].second;</span><br><span class="line">                        <span class="keyword">if</span>(y==f[i])&#123;</span><br><span class="line">                            sum[<span class="number">1</span>]++;</span><br><span class="line">                            sum[st[i]]--;</span><br><span class="line">                            sum[ed[i]+<span class="number">1</span>]++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            sum[st[y]]++;</span><br><span class="line">                            sum[ed[y]+<span class="number">1</span>]--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!sum[st[i]])ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">if</span>(!sum[st[i]])<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>树上差分</category>
      </categories>
      <tags>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces Gym - 100959J Ropes(prufer序列)</title>
    <url>/2018/04/13/CodeForces%20Gym%20-%20100959J%20Ropes(prufer%E5%BA%8F%E5%88%97)/</url>
    <content><![CDATA[<p>prufer序列学习笔记<br><span id="more"></span></p>
<h3 id="prufer序列"><a href="#prufer序列" class="headerlink" title="prufer序列"></a>prufer序列</h3><p>prufer序列是一种标号无根树的表示方式（注意，标号需要从1-n两两不同）。我们通过这样一种方式生成一个prufer序列：首先找到无根树所有叶子节点中标号最小的节点，我们在prufer序列后插入它的相邻节点的标号，然后在树中删除这个节点。我们重复这个过程只到树中只剩两个节点。<br><img src="http://www.matrix67.com/blogimage/200808233.gif" alt="prufer-example"><br>通过matrix67博客里的这张图我们能够更深地理解prufer序列是如何生成的。prufer序列有一个很有趣的性质，那就是一个prufer序列唯一地对应了一颗无根树，详细证明见matrix67的博客。我这里想详细写写如何从prufer序列生成无根树，我个人感觉理解了这个过程就理解了为什么prufer序列唯一地对应了一颗无根树的这个性质。我们以上面第一张图的3，3，5，2，5，6，1为例。<br><img src="https://i.loli.net/2020/12/14/qa6wIxoVOnC79Dg.jpg" alt="prufer_1"><br><img src="https://i.loli.net/2020/12/14/ontB25Wsbue9icl.jpg" alt="prufer_2"><br><img src="https://i.loli.net/2020/12/14/jfTlvzBu3ZFiGnX.jpg" alt="prufer_3"><br><img src="https://i.loli.net/2020/12/14/ByDRcg4eJLlmYOz.jpg" alt="prufer_4"><br><img src="https://i.loli.net/2020/12/14/7wR8qCzlnuWcpBX.jpg" alt="prufer_5"><br><img src="https://i.loli.net/2020/12/14/oJ9X5CHQfjWeFpt.jpg" alt="prufer_6"><br><img src="https://i.loli.net/2020/12/14/pMZufOTtDaErjIz.jpg" alt="prufer_7"><br><img src="https://i.loli.net/2020/12/14/QPnrZjzFRKLoYhk.jpg" alt="prufer_8"></p>
<h3 id="prufer序列的性质及推论"><a href="#prufer序列的性质及推论" class="headerlink" title="prufer序列的性质及推论"></a>prufer序列的性质及推论</h3><ol>
<li>prufer序列唯一地对应了一颗无根树</li>
<li>prufer序列中，每个节点出现的次数等于它的度数减1</li>
<li>n个点的无向完全图的生成树的计数：n^(n-2),即n个点的有标号无根树的计数。</li>
<li>n个节点的度依次为D1, D2,…, Dn的无根树共有(n-2)! / [ (D1-1)!(D2-1)!..(Dn-1)! ]个，因为prufer唯一确定了一颗无根树，我们对序列进行全排列，同时Prufer编码中的数字i恰好出现Di-1次。</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>裸的prufer序列题，注意判断无解</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.matrix67.com/blog/archives/682">经典证明：Prüfer编码与Cayley公式</a><br><a href="https://www.cnblogs.com/dirge/p/5503289.html">树的计数 + prufer序列与Cayley公式 学习笔记</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MOD=<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        ll ans=<span class="number">1</span>,cnt=<span class="number">0</span>,d,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;d);</span><br><span class="line">            <span class="keyword">if</span>(d==<span class="number">3</span>)cnt++;</span><br><span class="line">            sum+=(d<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum!=n<span class="number">-2</span>)<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">                ll t=i;</span><br><span class="line">                <span class="keyword">while</span>(t%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;cnt)&#123;</span><br><span class="line">                    t/=<span class="number">2</span>;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                ans=ans*t%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%I64d\n&quot;</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>prufer序列</category>
      </categories>
      <tags>
        <tag>prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces Gym - 100803G Flipping Parentheses(线段树)</title>
    <url>/2018/07/04/CodeForces%20Gym%20-%20100803G%20Flipping%20Parentheses(%E7%BA%BF%E6%AE%B5%E6%A0%91)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意是给定一个匹配好的括号序列，后面有Q次操作，每次操作将第q位的括号反转，你需要找到一个位置反转该位置上的括号让它重新匹配。位置要求是所有可行位置中最左边的。<br>我们令左括号为1，右括号为-1，并求出前缀和。考虑将右括号变为左括号的过程，我们能发现该操作的影响是从该位置到序列尾部的前缀和加2。将左括号变为右括号则是区间-2。为了反转后的括号序列是合法的，我们的前缀和中不能出现小于0的数。因而对操作是右括号变为左括号的情况我们可以将问题转化为哪个位置到末尾的最小值是2，以上所有操作可以使用二分+区间更新线段树实现。而对于左括号变为右括号的操作，我们只要维护一个set保存右括号的下标，然后取出最小的下标即可（很简单的思路，简单画一画就能发现）。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">char</span> str[MAXN];</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; dict;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,mins,lazy;</span><br><span class="line">&#125;tree[MAXN*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    tree[root].mins=<span class="built_in">min</span>(tree[root*<span class="number">2</span>].mins+tree[root*<span class="number">2</span>].lazy,tree[root*<span class="number">2</span>+<span class="number">1</span>].mins+tree[root*<span class="number">2</span>+<span class="number">1</span>].lazy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> root)</span></span>&#123;\</span><br><span class="line">    tree[root].l=l,tree[root].r=r,tree[root].lazy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)tree[root].mins=a[l];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(l,mid,root*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">build</span>(mid+<span class="number">1</span>,r,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    tree[root*<span class="number">2</span>].lazy+=tree[root].lazy,tree[root*<span class="number">2</span>+<span class="number">1</span>].lazy+=tree[root].lazy;</span><br><span class="line">    tree[root].mins+=tree[root].lazy;</span><br><span class="line">    tree[root].lazy=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[root].l&amp;&amp;tree[root].r&lt;=r)tree[root].lazy+=val;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">push_down</span>(root);</span><br><span class="line">        <span class="keyword">int</span> mid=(tree[root].l+tree[root].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=mid)<span class="built_in">update</span>(l,r,val,root*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(r&gt;mid)<span class="built_in">update</span>(l,r,val,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">push_up</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tree[root].l&amp;&amp;tree[root].r&lt;=r)<span class="keyword">return</span> tree[root].mins+tree[root].lazy;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">push_down</span>(root);</span><br><span class="line">        <span class="keyword">int</span> mid=(tree[root].l+tree[root].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=mid)<span class="keyword">return</span> <span class="built_in">query</span>(l,r,root*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)<span class="keyword">return</span> <span class="built_in">query</span>(l,r,root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">query</span>(l,r,root*<span class="number">2</span>),<span class="built_in">query</span>(l,r,root*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,Q,q;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;Q))&#123;</span><br><span class="line">        <span class="built_in">ms</span>(a,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                a[i+<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">                dict.<span class="built_in">insert</span>(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> a[i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//for(int i=1;i&lt;=N;i++)cout&lt;&lt;a[i]&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,N,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Q;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">            <span class="keyword">if</span>(str[q<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                str[q<span class="number">-1</span>]=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                dict.<span class="built_in">insert</span>(q);</span><br><span class="line">                <span class="built_in">update</span>(q,N,<span class="number">-2</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*dict.<span class="built_in">begin</span>());</span><br><span class="line">                <span class="built_in">update</span>(*dict.<span class="built_in">begin</span>(),N,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">                str[*dict.<span class="built_in">begin</span>()<span class="number">-1</span>]=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                dict.<span class="built_in">erase</span>(dict.<span class="built_in">begin</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[q<span class="number">-1</span>]=<span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                dict.<span class="built_in">erase</span>(q);</span><br><span class="line">                <span class="built_in">update</span>(q,N,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> L=<span class="number">1</span>,R=N;</span><br><span class="line">                <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">query</span>(mid,R,<span class="number">1</span>)&gt;=<span class="number">2</span>)R=mid;</span><br><span class="line">                    <span class="keyword">else</span> L=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                str[L<span class="number">-1</span>]=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                <span class="built_in">update</span>(L,N,<span class="number">-2</span>,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,L);</span><br><span class="line">                dict.<span class="built_in">insert</span>(L);</span><br><span class="line">                <span class="comment">/*for(int j=1;j&lt;=N;j++)&#123;</span></span><br><span class="line"><span class="comment">                    //cout&lt;&lt;query(i,N,1)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">                    if(query(j,N,1)==2)&#123;</span></span><br><span class="line"><span class="comment">                        str[j-1]=&#x27;)&#x27;;</span></span><br><span class="line"><span class="comment">                        update(j,N,-2,1);</span></span><br><span class="line"><span class="comment">                        printf(&quot;%d\n&quot;,j);</span></span><br><span class="line"><span class="comment">                        dict.insert(j);</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dict.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces - 1635D Infinite Set(dp)</title>
    <url>/2022/03/13/Codeforces%20-%201635D%20Infinite%20Set/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个数组，我们可以通过2种方式扩张这个数组：</p>
<ul>
<li>选取数组中的一个数，令其为x，将2*x+1的结果也加入到数组中</li>
<li>选取数组中的一个数，令其为x，将4*x的结果也加入到数组中</li>
</ul>
<p>给定一个p，问通过扩张后数组小于2^p的元素个数有几个，结果对1e9+7取模。原数组大小和p最大为1e5。</p>
<span id="more"></span>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我们首先考虑原数组仅有一个元素时，我们应当如何计算结果。考虑到p的范围达到了10^5次，2^p暗示了我们可能可以从二进制的方向考虑这个问题。考虑我们拥有的两种操作：</p>
<ul>
<li>2*x+1：如果我们将一个数字看作一个01字符串，那么2*x+1就可以看作是在01串的末尾增加一个’1’</li>
<li>4*x:同样，看作一个01字符串后，4*x可以看作在01串的末尾增加一个’00’</li>
</ul>
<p>基于这个观察结果，我们能够发现长度为i，满足被生成条件的01串，能够从i-1长度满足条件的01串末尾加’1’及从i-2长度满足条件的01串末尾添加’00’转移得到。即存在转移方程</p>
<script type="math/tex; mode=display">
dp[i] = dp[i-1]+dp[i-2]</script><p>同时我们注意到，当仅有一个元素时，两种操作产生的数字不会产生重叠！1操作仅仅会为数字添加1，而2操作仅仅会为数字添加0.所以两种操作永远不会在起始数组仅有一个元素时，产生重叠的元素，进而在转移方程中，我们不用考虑重复的情况。</p>
<p>在解决了数组仅有一个元素后，我们需要注意，对于多个元素的起始数组，我们需要考虑去重的问题。什么样的两个01串a,b会导致重复元素c？根据操作的特性，我们能发现，a和b一定都是c的前缀。进一步，根据操作的特性，我们也能发现a，b中较长的串，应当是由较短的串通过操作生成的！这里我们还能发现，如果从较短的串找较长的串，必须要dfs遍历所有可能，但是如果从较长的串找较短的串，那么就有：</p>
<ul>
<li>末尾为1时，将该数字除2，因为1只可能从操作1得到，所以反向就是除2</li>
<li>末尾为2（01串为’10’)退出循环，因为10是不可能通过操作得到的）</li>
<li>末尾为00，将该数字除4，对应操作2的反向操作</li>
</ul>
<p>通过去除重复生成串中较长的串，我们就能得到操作后不会重叠的数组。这时使用dp转移方程就能得到答案。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li>数据范围为2的指数次幂，可以考虑往bitset方向考虑</li>
<li>从小数据往大数据思考</li>
<li>操作带*2, *4时，要对二进制方向有敏感性</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a, val) memset(a, val, sizeof a);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; <span class="keyword">void</span> <span class="title">read</span><span class="params">(T&amp; x)</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN], a[MAXN];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> n, p;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n,&amp;p)) &#123;</span><br><span class="line">        <span class="built_in">ms</span>(dp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="built_in">read</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; useful;</span><br><span class="line">        <span class="built_in">sort</span>(a, a+n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> x = a[i];</span><br><span class="line">            <span class="keyword">while</span>(x) &#123;</span><br><span class="line">                <span class="keyword">if</span>(useful.<span class="built_in">count</span>(x)) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x&amp;<span class="number">1</span>) &#123;</span><br><span class="line">                    x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x&amp;<span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    x&gt;&gt;=<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                useful.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(set&lt;<span class="keyword">int</span>&gt;::iterator it = useful.<span class="built_in">begin</span>();it!=useful.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">            <span class="keyword">double</span> x = *it;</span><br><span class="line">            dp[(<span class="keyword">int</span>)<span class="built_in">log2</span>(x)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">                dp[i] = (dp[i]+dp[i<span class="number">-1</span>])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">                dp[i] = (dp[i]+dp[i<span class="number">-2</span>])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans+dp[i])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://codeforces.com/blog/entry/100153">Codeforces Round #772 Editor</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces Gym - 101620F Faulty Factorial(简单数论)</title>
    <url>/2018/05/28/CodeForces%20Gym%20-%20101620F%20Faulty%20Factorial(%E7%AE%80%E5%8D%95%E6%95%B0%E8%AE%BA)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分四种情况讨论，注意p保证是一个素数，这个条件非常关键。</p>
<ol>
<li>n&gt;=2p，如果r!=0显然无解，因为p，2p已经有两个p因子了，所以模p余数只能为0，r==0则我们随便输出一个合法的即可</li>
<li>n&gt;p&amp;&amp;n&lt;2p，r==0则随意变换一个除p外的数，不然暴力枚举。</li>
<li>n==p，r==0则若n==2无解，否则随意输出一个合法解。如果r!=0那么因为p是素数，我们由威尔逊定理(p-1)!同余于p=1得到最后的判定条件为(p-1)i%p==r然后进行暴力枚举</li>
<li>n&lt;p，我们有1*2*…*n同余r（模p意义下），我们枚举i，对两边乘上1*2*…*n的逆元然后去掉i就是i位置该放的值，判定是否合法即可。</li>
</ol>
<span id="more"></span>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll b,ll mod)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll n,p,r;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;p&gt;&gt;r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n==<span class="number">2</span>)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">else</span> cout&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ll flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;p;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i*(p<span class="number">-1</span>)%p==r)&#123;</span><br><span class="line">                        cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">2</span>*p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r!=<span class="number">0</span>)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;p+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;p&amp;&amp;n&lt;<span class="number">2</span>*p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r==<span class="number">0</span>)cout&lt;&lt;p+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ll ans=<span class="number">1</span>,flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i!=p)ans=(ans*i)%p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;p;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((ans*i)%p==r)&#123;</span><br><span class="line">                        cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll ans=<span class="number">1</span>,flag=<span class="number">0</span>,pos=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++)ans=(ans*i)%p;</span><br><span class="line">            ans=<span class="built_in">qpow</span>(ans,p<span class="number">-2</span>,p);</span><br><span class="line">            <span class="keyword">for</span>(ll i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                ll temp=r*i%p*ans%p;</span><br><span class="line">                <span class="keyword">if</span>(temp&gt;=<span class="number">1</span>&amp;&amp;temp&lt;i)&#123;</span><br><span class="line">                    cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">                    flag=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>威尔逊定理</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Educational Round 135</title>
    <url>/2022/09/10/Codeforces%20Educational%20Round%20135/</url>
    <content><![CDATA[<p>Edu round 135 tutorial<br><span id="more"></span></p>
<h1 id="A-Colored-Balls-Revisited"><a href="#A-Colored-Balls-Revisited" class="headerlink" title="A. Colored Balls: Revisited"></a>A. Colored Balls: Revisited</h1><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>There are n balls with different color in a bag. You can take out two balls with differnt color at a time. We want to know the color of remaining balls.</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>You can always find a way to pick up balls that make the color with the largest count have the last ball. I’ve solved a problem on leetcode that find out how many balls can you pick out given the count of balls with different color, which is similar to this problem. To make it as large as possible, the best solution is to first sort the count, then connect balls in i to i+1. If there is still many balls in the last pile, then break the connection before into 2 balls, and connect these two balls with the balls in the last pile. Through this solution, you can find that we can always make the last ball in the last pile.<br><img src="https://s2.loli.net/2022/09/11/WtoxejsD8SciqE2.jpg" alt="edu135-a.jpg"></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin&gt;&gt;cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max_element</span>(cnt.<span class="built_in">begin</span>(), cnt.<span class="built_in">end</span>())-cnt.<span class="built_in">begin</span>()+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="B-Best-Permutation"><a href="#B-Best-Permutation" class="headerlink" title="B. Best Permutation"></a>B. Best Permutation</h1><h2 id="Problem-Description-1"><a href="#Problem-Description-1" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>You are asked to generate a permutation that following the rules and have the maximum value. The rule is:</p>
<ul>
<li>We have a variable x with value 0.</li>
<li>Beginning from position 0, if permutation position’s value is larger than x, then x = 0. Else x = x+permutation position’s value.<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2>The maximum number must be 2n+1. Consider a sequence i, i+1, i+2. It’s obvious that x will be 2i+1, which must be larger than i+2 and become 0. So the best choice is to put n-1, n at the tail of the sequence. Then we want to make x at position at n-2 equal to zero. A decreasing sequence meet the demands when the length is even. For odd, we place the last 3 numbers before n-1, {1, 2, 3} to meet the demands.<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-2</span>; i++) &#123;</span><br><span class="line">            ans[i] = n<span class="number">-2</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[n<span class="number">-2</span>] = n<span class="number">-1</span>, ans[n<span class="number">-1</span>] = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-5</span>; i++) &#123;</span><br><span class="line">            ans[i] = n<span class="number">-2</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[n<span class="number">-5</span>] = <span class="number">1</span>, ans[n<span class="number">-4</span>] = <span class="number">2</span>, ans[n<span class="number">-3</span>] = <span class="number">3</span>;</span><br><span class="line">        ans[n<span class="number">-2</span>] = n<span class="number">-1</span>, ans[n<span class="number">-1</span>] = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; \n&quot;</span>[i==n<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="C-Digital-Logarithm"><a href="#C-Digital-Logarithm" class="headerlink" title="C.Digital Logarithm"></a>C.Digital Logarithm</h1><h2 id="Problem-Description-2"><a href="#Problem-Description-2" class="headerlink" title="Problem Description"></a>Problem Description</h2>Given two arrays, you can make one number in A/B array to become the length of number in 10-base(e.g. length of 88 is 2, 100 is 3). Two array is similar if you can change the order of the elements to make elements with same index equal. You are asked to give the minimum number of operations to make A&amp;B equal.<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2>It’s clear that we can always make two arrays equal. They will all become to 1 anyway. It’s clear that if the biggest element in A and B are not equal, me must apply the operation on it, or we can’t make it similar. So, our solution is to use two heaps, every time we check the maximum element of two arrays and if they are equal, pop both of them(Of course!). Or, apply the operation on the bigger one.<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getlen</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    string str = <span class="built_in">to_string</span>(num);</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>, <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq1, pq2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        pq1.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">        pq2.<span class="built_in">push</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq1.<span class="built_in">empty</span>()&amp;&amp;!pq2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = pq1.<span class="built_in">top</span>(), y = pq2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(x==y) &#123;</span><br><span class="line">            pq1.<span class="built_in">pop</span>(), pq2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;y) &#123;</span><br><span class="line">            pq1.<span class="built_in">pop</span>();</span><br><span class="line">            pq1.<span class="built_in">push</span>(<span class="built_in">getlen</span>(x));</span><br><span class="line">            ans++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pq2.<span class="built_in">pop</span>();</span><br><span class="line">            pq2.<span class="built_in">push</span>(<span class="built_in">getlen</span>(y));</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="D-Letter-Picking"><a href="#D-Letter-Picking" class="headerlink" title="D. Letter Picking"></a>D. Letter Picking</h1><h2 id="Problem-Description-3"><a href="#Problem-Description-3" class="headerlink" title="Problem Description"></a>Problem Description</h2>Given a string and two players A and B. Every turn Alice/Bob pick the letter on the left/right of string and <strong>prepends</strong> to their string until the string is empty. The player with the smaller lexicographically win.<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 460 (Div. 2)</title>
    <url>/2018/02/01/Codeforces%20Round%20#460%20(Div.%202)/</url>
    <content><![CDATA[<p>终于蓝名。。<br><img src="https://i.loli.net/2020/12/14/9EOcjuk8DJFw7e3.jpg" alt="first_blue"><br><span id="more"></span></p>
<h3 id="A-Supermarket"><a href="#A-Supermarket" class="headerlink" title="A. Supermarket"></a>A. Supermarket</h3><p>直接计算平均最小价格乘千克即可<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        <span class="keyword">double</span> mins=INF,a,b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="keyword">if</span>(a/b&lt;mins)mins=a/b;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">8</span>)&lt;&lt;m*mins&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="B-Perfect-Number"><a href="#B-Perfect-Number" class="headerlink" title="B. Perfect Number"></a>B. Perfect Number</h3><p>从19开始每次加9，需要减掉一部分和大于9的数(比如891)，因为数据范围只有10^4所以问题不大，但在题解中有一个Bonus问题：当k=1e18的时候怎么处理？暂时没有思路，感觉可能和数字加不能加在0的数位上有关。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,t=n;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        sum+=t%<span class="number">10</span>;</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> cal=<span class="number">0</span>,t=<span class="number">19</span>;</span><br><span class="line">    <span class="keyword">while</span>(cal&lt;=<span class="number">10000</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getsum</span>(t)==<span class="number">10</span>)a[cal++]=t;</span><br><span class="line">        t+=<span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;k)&#123;</span><br><span class="line">        cout&lt;&lt;a[k<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-Seat-Arrangements"><a href="#C-Seat-Arrangements" class="headerlink" title="C. Seat Arrangements"></a>C. Seat Arrangements</h3><p>暴力横向和纵向各扫一次，注意k=1需要特判<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&gt;&gt;k)&#123;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ll tsum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==m||str[i][j]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    sum+=(tsum-k+<span class="number">1</span>&gt;<span class="number">0</span>?tsum-k+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                    tsum=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> tsum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                ll tsum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==n||str[j][i]==<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                        sum+=(tsum-k+<span class="number">1</span>&gt;<span class="number">0</span>?tsum-k+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                        tsum=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> tsum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="D-Substring"><a href="#D-Substring" class="headerlink" title="D. Substring"></a>D. Substring</h3><p>拓扑排序+dp，拓扑排序判环，有环输出-1，否则对每个入度为0的点每次更新所有和他链接的点的26个字母的值。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,maxs,tot;</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">int</span> deg[MAXN],used[MAXN],cal[MAXN][<span class="number">26</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo_sort</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        used[t]=<span class="number">1</span>,cal[t][str[t<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>]++,tot++;</span><br><span class="line">        maxs=<span class="built_in">max</span>(maxs,cal[t][str[t<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=G[t].<span class="built_in">begin</span>();it!=G[t].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            deg[*it]--;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                cal[*it][i]=<span class="built_in">max</span>(cal[*it][i],cal[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(deg[*it]==<span class="number">0</span>)q.<span class="built_in">push</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        maxs=<span class="number">-1</span>,tot=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ms</span>(deg,<span class="number">0</span>),<span class="built_in">ms</span>(used,<span class="number">0</span>),<span class="built_in">ms</span>(cal,<span class="number">0</span>);</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            deg[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(deg[i]==<span class="number">0</span>&amp;&amp;!used[i])<span class="built_in">topo_sort</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot&lt;n)cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;maxs&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="E-Congruence-Equation"><a href="#E-Congruence-Equation" class="headerlink" title="E. Congruence Equation"></a>E. Congruence Equation</h3><p>数论题，比赛的时候打表看出了结论但是不会使用，感觉看了题解思路还是有点混乱，以后再改吧。。<br>由费马小定理可知，当p是个素数的时候，a^z mod p存在一个p-1长度的循环节，而a mod p存在p长度的循环节。通过题解的图我们能发现，n*a^n的循环节是p*(p-1)。<br><img src="http://codeforces.com/predownloaded/75/40/7540e28a6b7452737f984f1f58564233e06a9fa3.png" alt="cf-919e-proof"><br>然后我们令n=i*(p-1)+j，y=b*a^-j枚举j从1-p-1,由费马小定理可得<br><img src="http://codeforces.com/predownloaded/ca/57/ca57404121205092ad913c518861721ccaa8afcf.png" alt="cf-919e-proof-1"><br>所以答案在(j-y),p+(j-y)…p*t+(j-y)中.<br>我们计算第一个符合要求的值，又因为值在p(p-1)区间的唯一性，所以我们可以拿x-值的下标/区间长度来计算个数并且不会有重复，然后求和。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a,ll n,ll MOD)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=ans*a%MOD,n--;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a,b,p,x;</span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b&gt;&gt;p&gt;&gt;x)&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;p;i++)&#123;</span><br><span class="line">            ll tmp=<span class="built_in">qpow</span>(a,i,p);</span><br><span class="line">            tmp=b*<span class="built_in">qpow</span>(tmp,p<span class="number">-2</span>,p)%p;<span class="comment">//inv</span></span><br><span class="line">            ll h=(i-tmp+p)%p;</span><br><span class="line">            ll t=x-((p<span class="number">-1</span>)*h+i);</span><br><span class="line">            <span class="keyword">if</span>(t&gt;=<span class="number">0</span>)sum+=t/p/(p<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="F-A-Game-With-Numbers"><a href="#F-A-Game-With-Numbers" class="headerlink" title="F. A Game With Numbers"></a>F. A Game With Numbers</h3><p>F题待补</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 444 (Div. 2)</title>
    <url>/2017/11/06/Codeforces%20Round%20444%20(Div.%202)/</url>
    <content><![CDATA[<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>A.Div. 64(implementation)</li>
<li>B.Cubes for Masha(brute force)</li>
<li>C.Solution for Cube(brute force, implementation)</li>
<li>D.Ratings and Reality Shows(data structures, two pointers)</li>
<li>E.Little Brother(binary search, geometry)</li>
<li>F.Row of Models</li>
</ul>
<span id="more"></span>
<h3 id="A-Div-64"><a href="#A-Div-64" class="headerlink" title="A.Div. 64"></a>A.Div. 64</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>题意是给一个二进制的01串，判断能否通过去掉一些数字使其能被64整除（移除数字后必须为正整数）。很显然在最后一个1后有至少6个0就能使其被64整除。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	string str;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; str) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>,zero=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i&lt;str.<span class="built_in">length</span>()&amp;&amp;str[i] == <span class="string">&#x27;0&#x27;</span>)i++;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; str.<span class="built_in">length</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>)zero++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (zero &gt;= <span class="number">6</span>)cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="B-Cubes-for-Masha"><a href="#B-Cubes-for-Masha" class="headerlink" title="B.Cubes for Masha"></a>B.Cubes for Masha</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>题意是给出n个6面魔方，每个面上有一个0-9之中的数字，我们希望能用这n个魔方拼出从1到x之间所有的整数。找出最大的x（不一定要使用所有魔方）。通过观察我们发现3个魔方不可能拼出比99更大的数(考虑到要拼出99需要1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9已经有18个数，而0又是必须的)。所以我们暴搜从1-99的数。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">3</span>];</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; dict[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,t;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">		<span class="built_in">ms</span>(vis, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)dict[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">6</span>;j++) &#123;</span><br><span class="line">				cin &gt;&gt; t;</span><br><span class="line">				dict[i].<span class="built_in">insert</span>(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">99</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> num = i % <span class="number">10</span>,flag=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (dict[j].<span class="built_in">find</span>(num) != dict[j].<span class="built_in">end</span>()) &#123;</span><br><span class="line">					vis[j] = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">3</span>;k++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (i / <span class="number">10</span> == <span class="number">0</span>||(!vis[k] &amp;&amp; dict[k].<span class="built_in">find</span>(i / <span class="number">10</span>) != dict[k].<span class="built_in">end</span>())) &#123;</span><br><span class="line">							flag = <span class="number">0</span>;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					vis[j] = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!flag)<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				cout &lt;&lt; i<span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-Solution-for-Cube"><a href="#C-Solution-for-Cube" class="headerlink" title="C.Solution for Cube"></a>C.Solution for Cube</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>题意很简单，能否一步还原2<em>2</em>2的魔方，模拟。考虑到各种对称的状态，我们只需要模拟6种旋转即可。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> mcube[<span class="number">24</span>],cube[<span class="number">24</span>];</span><br><span class="line"><span class="keyword">int</span> cmd[<span class="number">3</span>][<span class="number">8</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">22</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">21</span>&#125;,</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">13</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">switchs</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (d) &#123;</span><br><span class="line">		<span class="keyword">int</span> t1 = cube[cmd[i][<span class="number">0</span>]<span class="number">-1</span>], t2=cube[cmd[i][<span class="number">1</span>]<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">4</span>;j += <span class="number">2</span>) &#123;</span><br><span class="line">			cube[cmd[i][j] - <span class="number">1</span>] = mcube[cmd[i][j + <span class="number">2</span>] - <span class="number">1</span>], cube[cmd[i][j + <span class="number">1</span>]<span class="number">-1</span>] = mcube[cmd[i][j + <span class="number">3</span>] - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		cube[cmd[i][<span class="number">6</span>] - <span class="number">1</span>] = t1, cube[cmd[i][<span class="number">7</span>] - <span class="number">1</span>] = t2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> t1 = cube[cmd[i][<span class="number">6</span>] - <span class="number">1</span>], t2 = cube[cmd[i][<span class="number">7</span>] - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">4</span>;j += <span class="number">2</span>) &#123;</span><br><span class="line">			cube[cmd[i][j + <span class="number">2</span>] - <span class="number">1</span>] = mcube[cmd[i][j] - <span class="number">1</span>], cube[cmd[i][j + <span class="number">3</span>] - <span class="number">1</span>] = mcube[cmd[i][j + <span class="number">1</span>] - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		cube[cmd[i][<span class="number">0</span>] - <span class="number">1</span>] = t1, cube[cmd[i][<span class="number">1</span>] - <span class="number">1</span>] = t2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = cube[i * <span class="number">4</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; <span class="number">4</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cube[i * <span class="number">4</span> + j] != temp)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; mcube[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; <span class="number">24</span>;i++)cin &gt;&gt; mcube[i];</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(cube, mcube, <span class="built_in"><span class="keyword">sizeof</span></span>(mcube));</span><br><span class="line">			<span class="built_in">switchs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">judge</span>())flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(cube, mcube, <span class="built_in"><span class="keyword">sizeof</span></span>(mcube));</span><br><span class="line">			<span class="built_in">switchs</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">judge</span>())flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(cube, mcube, <span class="built_in"><span class="keyword">sizeof</span></span>(mcube));</span><br><span class="line">			<span class="built_in">switchs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">judge</span>())flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(cube, mcube, <span class="built_in"><span class="keyword">sizeof</span></span>(mcube));</span><br><span class="line">			<span class="built_in">switchs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">judge</span>())flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(cube, mcube, <span class="built_in"><span class="keyword">sizeof</span></span>(mcube));</span><br><span class="line">			<span class="built_in">switchs</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">judge</span>())flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(cube, mcube, <span class="built_in"><span class="keyword">sizeof</span></span>(mcube));</span><br><span class="line">			<span class="built_in">switchs</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">judge</span>())flag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag)cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>D题后待补题。。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>CodeForces</category>
      </categories>
      <tags>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title>DHUOJ 2017121906&amp;&amp;BZOJ 4552 排序</title>
    <url>/2017/12/21/DHUOJ%202017121906&amp;&amp;BZOJ%204552%20%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>DHU数据结构期末考题，来源bzoj4552[Tjoi2016&amp;Heoi2016]。非常好的一道线段树的题目，让我看到了自己对二分，线段树的理解尚浅。<br>本题的思路是二分处于q位置上的数字，然后将原数列转换成01序列（比他大置1，反之置0）。对于一个01序列，按递增排序相当于把后半部分置1，前半部分置0（线段树区间更新）。递减思路类似。最后我们check返回q位置上的值。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ((x&lt;&lt;1)|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>, MAXM = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, q, a[MAXN], b[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r, val, lazy;</span><br><span class="line">	<span class="built_in">node</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">node</span>(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val) :<span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">val</span>(val) &#123; lazy = <span class="number">-1</span>; &#125;;</span><br><span class="line">&#125;tree[MAXN * <span class="number">4</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ask</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> oper, l, r;</span><br><span class="line">	<span class="built_in">ask</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">ask</span>(<span class="keyword">int</span> oper, <span class="keyword">int</span> l, <span class="keyword">int</span> r) :<span class="built_in">oper</span>(oper), <span class="built_in">l</span>(l), <span class="built_in">r</span>(r) &#123;&#125;;</span><br><span class="line">&#125;as[MAXM];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	tree[root].val = tree[<span class="built_in">lson</span>(root)].val + tree[<span class="built_in">rson</span>(root)].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[root].lazy&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">	tree[<span class="built_in">lson</span>(root)].val = (tree[<span class="built_in">lson</span>(root)].r - tree[<span class="built_in">lson</span>(root)].l + <span class="number">1</span>)*tree[root].lazy, tree[<span class="built_in">lson</span>(root)].lazy = tree[root].lazy;</span><br><span class="line">	tree[<span class="built_in">rson</span>(root)].val = (tree[<span class="built_in">rson</span>(root)].r - tree[<span class="built_in">rson</span>(root)].l + <span class="number">1</span>)*tree[root].lazy, tree[<span class="built_in">rson</span>(root)].lazy = tree[root].lazy;</span><br><span class="line">	tree[root].lazy = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildtree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	tree[root].l = l, tree[root].r = r,tree[root].lazy=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (l == r)tree[root].val=b[l];</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">buildtree</span>(l, mid, <span class="built_in">lson</span>(root));</span><br><span class="line">		<span class="built_in">buildtree</span>(mid + <span class="number">1</span>, r, <span class="built_in">rson</span>(root));</span><br><span class="line">		<span class="built_in">push_up</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> oper, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= tree[root].l&amp;&amp;r &gt;= tree[root].r) &#123;</span><br><span class="line">		tree[root].lazy = oper;</span><br><span class="line">		tree[root].val = (tree[root].r - tree[root].l + <span class="number">1</span>)*oper;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (tree[root].l + tree[root].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">push_down</span>(root);</span><br><span class="line">		<span class="keyword">if</span> (l &lt;= mid)<span class="built_in">change</span>(l, r, oper, <span class="built_in">lson</span>(root));</span><br><span class="line">		<span class="keyword">if</span> (mid&lt;r)<span class="built_in">change</span>(l, r, oper, <span class="built_in">rson</span>(root));</span><br><span class="line">		<span class="built_in">push_up</span>(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= tree[root].l&amp;&amp;tree[root].r &lt;= r)<span class="keyword">return</span> tree[root].val;</span><br><span class="line">	<span class="built_in">push_down</span>(root);</span><br><span class="line">	<span class="keyword">int</span> mid = (tree[root].l + tree[root].r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= mid)res += <span class="built_in">query</span>(l, r, <span class="built_in">lson</span>(root));</span><br><span class="line">	<span class="keyword">if</span> (mid&lt;r)res += <span class="built_in">query</span>(l, r, <span class="built_in">rson</span>(root));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i]&gt;x)b[i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> b[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">buildtree</span>(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="built_in">query</span>(as[i].l, as[i].r, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (as[i].oper == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (as[i].r - sum &gt;= as[i].l)<span class="built_in">change</span>(as[i].l, as[i].r - sum, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (sum)<span class="built_in">change</span>(as[i].r - sum + <span class="number">1</span>, as[i].r, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (sum)<span class="built_in">change</span>(as[i].l, as[i].l + sum - <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (as[i].r &gt;= as[i].l + sum)<span class="built_in">change</span>(as[i].l + sum, as[i].r, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">query</span>(q, q, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;as[i].oper, &amp;as[i].l, &amp;as[i].r);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">		<span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">check</span>(mid))l = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Eventbus随笔</title>
    <url>/2022/10/26/Eventbus%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<p>在USC的CSCI-526游戏开发课程中，我们的项目遇到了这样一个问题：对于一个事件，可能有多个模块需要关注。比如游戏中的天气变更事件，防御塔、怪物、数据统计模块都需要根据这个事件触发操作。最开始时我们将触发代码，甚至是部分逻辑放入了其他系统，导致了模块间的强耦合。为了解决这个问题，我想到了观察者模式，又想到了在字节实习时使用的EventBus。于是我便按照记忆手写了属于我们自己的Eventbus，在实现的过程中发现这个模式确实非常有趣，故写文记录。<br><span id="more"></span></p>
]]></content>
      <categories>
        <category>工程</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2196 Computer(树形dp)</title>
    <url>/2018/07/06/HDU%20-%202196%20Computer(%E6%A0%91%E5%BD%A2dp)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基础树形dp，但看了题解才做出来。。<br>树形dp有两种基本形式：从根到叶子，从叶子到根。本题稍微有点特别，需要进行两次dfs才能完成整个dp。<br>我们定义一个dp数组dp[MAXN][3]。dp[i][0]记录的是节点i子树中所有节点到子树根节点i的最大距离，dp[i][1]记录的是节点i往根方向的最大距离，dp[i][2]记录的是节点i子树中所有点的到子树根节点i的次大距离。为什么要这样设计dp状态？如果我们将i节点设为根节点，我们能发现原来父亲节点也变成了一棵子树。但我们不能对每个节点都dfs一次，所以我们考虑使用一个dp[i][1]从顶向下来计算父亲节点这棵子树的距离最大值，dp[i][0],dp[i][2]的作用在后文中会写到。<br>对于dp[i][0]，dp[i][2]我们在第一次dfs中就计算出来，注意我们要记录一个一个点最长距离走的是哪个儿子longest[i],这个值在后面会用到。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> go=to[i];</span><br><span class="line">        <span class="keyword">if</span>(go==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="built_in">dfs1</span>(go,u)+len[i];</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;dp[u][<span class="number">0</span>])&#123;</span><br><span class="line">            dp[u][<span class="number">2</span>]=dp[u][<span class="number">0</span>];</span><br><span class="line">            dp[u][<span class="number">0</span>]=temp;</span><br><span class="line">            islongest[u]=go;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;dp[u][<span class="number">1</span>])&#123;</span><br><span class="line">            dp[u][<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在第二次dfs中我们计算dp[i][1]。我们在父亲节点时计算儿子节点的dp[son][1]而不是dfs进入儿子后计算。然后分类讨论</p>
<ol>
<li>对于不是longest的儿子节点，我们显然知道往根方向的最大值是儿子节点到当前节点的距离+当前节点中儿子的最大值和dp[i][1]中的较大值</li>
<li>是longest的儿子节点，往根方向的最大值是儿子节点到当前节点的距离+dp[i][2]和dp[i][1]中的较大值(注意此时原来所有儿子中的最大值已经不能使用了，因为这个最大值包含在dp[son][0]中，此时只能选择次大值)</li>
</ol>
<p>最后遍历所有节点取max(dp[i][0],dp[i][1])即可<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10005</span>,MAXM=MAXN*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[MAXN],nxt[MAXM],to[MAXM],len[MAXM],edgecnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[edgecnt]=v;</span><br><span class="line">    len[edgecnt]=w;</span><br><span class="line">    nxt[edgecnt]=head[u];</span><br><span class="line">    head[u]=edgecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">3</span>],islongest[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> go=to[i];</span><br><span class="line">        <span class="keyword">if</span>(go==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="built_in">dfs1</span>(go,u)+len[i];</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;dp[u][<span class="number">0</span>])&#123;</span><br><span class="line">            dp[u][<span class="number">2</span>]=dp[u][<span class="number">0</span>];</span><br><span class="line">            dp[u][<span class="number">0</span>]=temp;</span><br><span class="line">            islongest[u]=go;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;dp[u][<span class="number">1</span>])&#123;</span><br><span class="line">            dp[u][<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> go=to[i];</span><br><span class="line">        <span class="keyword">if</span>(go==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(go==islongest[u])&#123;</span><br><span class="line">            dp[go][<span class="number">1</span>]=len[i]+<span class="built_in">max</span>(dp[u][<span class="number">2</span>],dp[u][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dp[go][<span class="number">1</span>]=len[i]+<span class="built_in">max</span>(dp[u][<span class="number">0</span>],dp[u][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(go,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,u,v;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        <span class="built_in">ms</span>(head,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">ms</span>(islongest,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">ms</span>(dp,<span class="number">0</span>);</span><br><span class="line">        edgecnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            <span class="built_in">addedge</span>(i,u,v);</span><br><span class="line">            <span class="built_in">addedge</span>(u,i,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1402 A * B Problem Plus</title>
    <url>/2018/01/07/HDU%20-%201402%20A%20%20multiply%20B%20Problem%20Plus/</url>
    <content><![CDATA[<p>FFT模板题<br><span id="more"></span></p>
<h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><p>快速傅里叶变换(FFT)是一种在O(nlog(n))时间内完成离散傅里叶变换的高效算法。在ACM中，我们通常用它加速多项式乘法。</p>
<h3 id="一些预备知识"><a href="#一些预备知识" class="headerlink" title="一些预备知识"></a>一些预备知识</h3><h4 id="多项式的表示"><a href="#多项式的表示" class="headerlink" title="多项式的表示"></a>多项式的表示</h4><p>对于常规的多项式，我们习惯使用<strong>系数表示</strong><br><img src="https://i.loli.net/2020/12/14/jMYBUS4oakHCfxq.png" alt="多项式系数表示"><br>事实上，还有<strong>点值表示</strong>。我们通过将n个值带入一个n-1次多项式，通过x-&gt;f(x)的映射关系，我们也能唯一的表示一个多项式（考虑带入解方程组来还原）。</p>
<blockquote>
<p>定理：一个n-1次多项式在n个不同点的取值唯一确定了该多项式。</p>
</blockquote>
<p>系数表示和点值表示之间转换的时间表示的时间复杂度都是O(n^2)。（点值表示-&gt;系数表示可以用拉格朗日插值）</p>
<h4 id="多项式的乘法"><a href="#多项式的乘法" class="headerlink" title="多项式的乘法"></a>多项式的乘法</h4><p>对于系数表示，我们算法的时间复杂度是O(n^2)，这是显而易见的。而对于点值表示，我们会发现其多项式乘法的时间复杂度只有O(n)(显然我们只需要对两个多项式在同一个横坐标的地方的纵坐标相乘，我们就能得到A(x)*B(x)在这个点的纵坐标值)。由于点值表示的乘法时间复杂度只有O(n)，所以我们要考虑的问题变成了如何快速将一个多项式的系数表示转换成点值表示。</p>
<h4 id="FFT中要用到的复数知识"><a href="#FFT中要用到的复数知识" class="headerlink" title="FFT中要用到的复数知识"></a>FFT中要用到的复数知识</h4><p>设a、b为实数，i^2=-1，形如a+bi的数叫做<strong>复数</strong>，其中i被称为虚数单位。<strong>复数域</strong>是已知最大的域。<br>该向量的长度a平方加b平方开根号叫做模长。从x轴正半轴到该向量的转角的有向（以逆时针为正方向）角叫做幅角。<br>复数相加满足的是平行四边形法则，复数相乘则是模长相乘，幅角相加。这个运算是要记住的，我们后面要用到。<br>对于朴素的插值算法，时间复杂度依然是O(n^2)。这制约了多项式乘法的时间复杂度。但实际上，我们可以通过巧妙地选取要带入的点，利用点的性质来加速乘法，我们要选取的点就是复数中的单位根。</p>
<h4 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h4><p>下面的如果不特别指出，我们n默认取2的正整数次幂，因为hexo用Latex好麻烦(好吧其实是不会用TAT)，下面令w(a,b)中a为上标，b为下标。<br>单位根指的是复平面上，以原点为圆心，1为半径作圆，然后把圆n等分，我们令辐角为0的w(0,n)为主n次单位根，其余的都是它的幂次。<br><img src="https://i.loli.net/2020/12/14/VeFlX5gGO3kfQms.jpg" alt="复数根"><br>下面给出了单位根的一些性质<br><strong>引理1（消去引理）</strong>：对任何整数n&gt;=0,k&gt;=0,以及d&gt;0我们有:<br><img src="https://i.loli.net/2020/12/14/E6ezQPMsSKgBNni.png" alt="消去引理"><br>通过单位附属根的定义，利用复数的指数形式，这个引理很容易证明<br><strong>引理2</strong>：对任意偶数n&gt;0，有<br><img src="https://i.loli.net/2020/12/14/3tlgiUP4VhQRTZ5.png" alt="复数根一般"><br>同样由定义易证<br><strong>引理3（折半引理）</strong>：如果n&gt;0为偶数，那么n个n次单位复数根的平方的集合就是n/2个n/2次单位复数根的集合。<br>这个引理在下面证明的时候并不会使用，只是启发了我们下面式子将要使用的A(x^2)<br>证明：<br>对任意非负整数我们有<br><img src="https://i.loli.net/2020/12/14/YLPgjwkHFBQomAx.png" alt="折半1"><br>还有<br><img src="https://i.loli.net/2020/12/14/pmtuESZwBJQKU1v.png" alt="折半2"><br><strong>引理4（求和引理）</strong>：对任意整数n&gt;=1和不能被n整除的非负整数k，有<br><img src="https://i.loli.net/2020/12/14/SwJMsjrc8AQvfbp.png" alt="求和引理"><br>证明可用等比数列求和<br><img src="https://i.loli.net/2020/12/14/oGOnZ2NfwshvB43.png" alt="求和引理证明"><br>当且仅当k被n整除时，w(k,n)=1，且分母不为0.<br>以上就是FFT所需要的所有预备知识，大家只需要记住性质，因为后面证明要用到。</p>
<h3 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h3><p>离散傅里叶变换就是将n个n次单位复数根代入多项式，求其点值表示。时间复杂度O(n^2)。</p>
<h3 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h3><p>注意从这里开始n将是<strong>第一个大于两个多项式次幂的和的值</strong>，考虑我们一共需要两个多项式次幂的和才能插值，而且n要是2的整数次幂，因为在后面我们要使用奇偶分类，用2的整数次在后面会非常方便，在编程中体现在对n的处理和用0把两个多项式补到n次。虽然已经有较好的处理非2的整数幂的方法，但是混合基FFT比较麻烦，平时基本都是利用0补到2的整数次幂。<br>我们将多项式通过下标的奇偶分为两部分（虽然我不知道为什么会想到这么分，但这样分的确使得后面我们能分治加速dft）：<br><img src="https://i.loli.net/2020/12/14/UpCxaIWt5kJKScy.png" alt="奇偶分类"><br>同时我们令<br><img src="https://i.loli.net/2020/12/14/bTx5ELUiyhq2CuF.png" alt="偶数"><br><img src="https://i.loli.net/2020/12/14/tAFHOKzwZu96GSq.png" alt="奇数"><br>则有<br><img src="https://i.loli.net/2020/12/14/CAceDMQVplBHRfs.png" alt="合并"><br>我们令k&lt;n/2.<br>对于w(k,n)我们有：<br><img src="https://i.loli.net/2020/12/14/wGLq2IF6nyhx89c.png" alt="wnk"><br>对于w(k+n/2,n)我们有<br><img src="https://i.loli.net/2020/12/14/VCxJukNYsQnX12y.png" alt="wnk2"><br>这里我们用到了w(n,n)=1和w(k+n/2,n)=-w(k,n)<br>通过上面的变换，我们能够发现当我们k取遍[0,n/2-1]时，k和k+n/2取遍了[0,n-1]。也就是说我们可以通过递归的解这个问题，通过把A1再视作之前的A，然后再做奇偶分类，直到数组长度为1再使用前面的式子合并子问题。时间复杂度为O(nlogn)。<br>以上就是FFT最常用的Cooley-Tukey算法。</p>
<h3 id="傅里叶逆变换"><a href="#傅里叶逆变换" class="headerlink" title="傅里叶逆变换"></a>傅里叶逆变换</h3><p>虽然解决了从系数转换到点值，但反过来的复杂度依然是O(n^2)。而傅里叶逆变换就是为了解决这个问题。（这一部分我不是很明白下面的D是怎么得到的，所以大部分参考的Miskcoo’s Space中的文章。）<br>IDFT本质上就是解一个如下的线性方程组<br><img src="https://i.loli.net/2020/12/14/OExfq6byKMR27Zn.png" alt="iDFT-1"><br>矩阵形式<br><img src="https://i.loli.net/2020/12/14/uaGrDw4fVLNR5Sc.png" alt="iDFT-2"><br>记上面的系数方程为V，考虑下面这个矩阵<br><img src="https://i.loli.net/2020/12/14/jQzBR74cINgXha1.png" alt="iDFT-3"><br>设相乘后的结果是E=DV<br><img src="https://i.loli.net/2020/12/14/OsE2k6DcuzIGr7f.png" alt="iDFT-4"><br>由引理4可知若i=j,eij=n<br>否则<br><img src="https://i.loli.net/2020/12/14/esSJFOiE5pVak2I.png" alt="iDFT-5"><br>因此可以知道In=E/n，所以 D/n=V的逆<br>如果在之前的矩阵方程进行左乘<br><img src="https://i.loli.net/2020/12/14/ei7cBWCNTFOUwbA.png" alt="iDFT-6"><br>简单的说IDFT就是把DFT过程中使用单位根的倒数取代单位根，做一次fft再对每个数除n，就是傅里叶逆变换的结果。</p>
<h3 id="傅里叶变换的迭代实现"><a href="#傅里叶变换的迭代实现" class="headerlink" title="傅里叶变换的迭代实现"></a>傅里叶变换的迭代实现</h3><p>使用递归实现的FFT常数和空间都比较大，所以我们使用两个方式进行优化。一个是二进制位翻转，另一个是蝴蝶操作。</p>
<h4 id="二进制位翻转"><a href="#二进制位翻转" class="headerlink" title="二进制位翻转"></a>二进制位翻转</h4><p>我们模拟一次FFT分治的过程<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">000</span> <span class="number">001</span> <span class="number">010</span> <span class="number">011</span> <span class="number">100</span> <span class="number">101</span> <span class="number">110</span> <span class="number">111</span></span><br><span class="line"> <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span> </span><br><span class="line"> <span class="number">0</span>   <span class="number">2</span>   <span class="number">4</span>   <span class="number">6</span> - <span class="number">1</span>   <span class="number">3</span>   <span class="number">5</span>   <span class="number">7</span> </span><br><span class="line"> <span class="number">0</span>   <span class="number">4</span> - <span class="number">2</span>   <span class="number">6</span> - <span class="number">1</span>   <span class="number">5</span> - <span class="number">3</span>   <span class="number">7</span></span><br><span class="line"> <span class="number">0</span> - <span class="number">4</span> - <span class="number">2</span> - <span class="number">6</span> - <span class="number">1</span> - <span class="number">5</span> - <span class="number">3</span> - <span class="number">7</span></span><br><span class="line"><span class="number">000</span> <span class="number">100</span> <span class="number">010</span> <span class="number">110</span> <span class="number">001</span> <span class="number">101</span> <span class="number">011</span> <span class="number">111</span></span><br></pre></td></tr></table></figure><br>我们发现，我们可以对每个数进行二进制位翻转，然后我们可以先2个2个合并，然后4个4个…这样就能使用迭代实现分治。</p>
<h4 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h4><p>在原来赋值的过程中，我们需要一个额外的b数组来存放数据，如下图<br><img src="https://i.loli.net/2020/12/14/ZB1THx9rKO7bCoJ.png" alt="蝴蝶操作"><br><img src="https://i.loli.net/2020/12/14/5xU1PFklY6zKvq4.png" alt="蝴蝶操作2"><br>在处理完b后，最后统一放入a。这样实际上是非常浪费空间的。我们可以使用一个t保存w(k,n)*a(n/2+k)，然后直接对a[k],a[k+n/2]操作，具体见代码</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>算法导论第三十章 多项式与快速傅里叶变换<br>萌次的blog<a href="https://oi.men.ci/fft-notes/">FFT 学习笔记</a><br>Miskcoo的blog<a href="http://blog.miskcoo.com/2015/04/polynomial-multiplication-and-fast-fourier-transform#IDFT">从多项式乘法到快速傅里叶变换</a></p>
</blockquote>
<h3 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h3><p>直接fft往上套就行，但最好数位翻转方便进位。不是很懂HDU？数组开小了怎么给的是WA啊。。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>有使用std::complex和自行实现complex，自行实现比较快（也就30ms..)<br>std::complex（时间265ms)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ((x&lt;&lt;1)|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(complex&lt;<span class="keyword">double</span>&gt; *a, <span class="keyword">int</span> n,complex&lt;<span class="keyword">double</span>&gt; *com)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k)&lt;n)k++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;k;j++)<span class="keyword">if</span> (i&amp;(<span class="number">1</span> &lt;&lt; j))t |= (<span class="number">1</span> &lt;&lt; (k - j - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (i&lt;t)<span class="built_in">swap</span>(a[i], a[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>;l &lt;= n;l *= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = l / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (complex&lt;<span class="keyword">double</span>&gt; *p = a;p&lt;a + n;p += l) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">				complex&lt;<span class="keyword">double</span>&gt; t = com[n / l*i] * p[m + i];</span><br><span class="line">				p[m + i] = p[i] - t;</span><br><span class="line">				p[i]=p[i]+t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">complex&lt;<span class="keyword">double</span>&gt; omega[<span class="number">140000</span>], iomega[<span class="number">140000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		omega[i] = complex&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(<span class="number">2</span> * PI / n*i), <span class="built_in">sin</span>(<span class="number">2</span> * PI / n*i));</span><br><span class="line">		iomega[i] = <span class="built_in">conj</span>(omega[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dft</span><span class="params">(complex&lt;<span class="keyword">double</span>&gt; *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fft</span>(a, n,omega);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idft</span><span class="params">(complex&lt;<span class="keyword">double</span>&gt; *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fft</span>(a, n,iomega);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)a[i]/= n;</span><br><span class="line">&#125;</span><br><span class="line">complex&lt;<span class="keyword">double</span>&gt; a[<span class="number">140000</span>], b[<span class="number">140000</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">140000</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s)) &#123;</span><br><span class="line">        <span class="built_in">ms</span>(ans,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">50005</span>;i++)a[i] = b[i] = complex&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)a[<span class="built_in">strlen</span>(s) - i - <span class="number">1</span>].<span class="built_in">real</span>(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">		len += <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)b[<span class="built_in">strlen</span>(s) - i - <span class="number">1</span>].<span class="built_in">real</span>(s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; n)&lt;len)n++;</span><br><span class="line">		n = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">		<span class="built_in">init</span>(n);</span><br><span class="line">		<span class="built_in">dft</span>(a, n);</span><br><span class="line">		<span class="built_in">dft</span>(b, n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)a[i] =a[i]* b[i];</span><br><span class="line">		<span class="built_in">idft</span>(a, n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)ans[i] = (<span class="keyword">int</span>)(a[i].<span class="built_in">real</span>() + <span class="number">0.5</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>;</span><br><span class="line">			ans[i] = ans[i] % <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> cal = n;</span><br><span class="line">		<span class="keyword">while</span> (!ans[cal]&amp;&amp;cal&gt;<span class="number">0</span>)cal--;</span><br><span class="line">		<span class="keyword">while</span> (cal &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[cal]);</span><br><span class="line">			cal--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>自行实现（时间234ms）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ((x&lt;&lt;1)|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> real,image;</span><br><span class="line">    <span class="built_in">Complex</span>()&#123;real=<span class="number">0</span>,image=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> real)&#123;<span class="keyword">this</span>-&gt;real=real,image=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">double</span> real,<span class="keyword">double</span> image)&#123;<span class="keyword">this</span>-&gt;real=real,<span class="keyword">this</span>-&gt;image=image;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(c.real+real,c.image+image);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> -(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real-c.real,image-c.image);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> *(<span class="keyword">const</span> Complex &amp;c)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(c.real*real-c.image*image,c.real*image+c.image*real);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> *(<span class="keyword">double</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real*x,image*x);</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> /(<span class="keyword">double</span> x)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real/x,image/x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Complex <span class="title">rev</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real,-image);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex *a, <span class="keyword">int</span> n,Complex *com)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; k)&lt;n)k++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;k;j++)<span class="keyword">if</span> (i&amp;(<span class="number">1</span> &lt;&lt; j))t |= (<span class="number">1</span> &lt;&lt; (k - j - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (i&lt;t)<span class="built_in">swap</span>(a[i], a[t]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>;l &lt;= n;l *= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> m = l / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (Complex *p = a;p&lt;a + n;p += l) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">				Complex t = com[n / l*i] * p[m + i];</span><br><span class="line">				p[m + i] = p[i] - t;</span><br><span class="line">				p[i]=p[i]+t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Complex omega[<span class="number">140000</span>], iomega[<span class="number">140000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		omega[i] = <span class="built_in">Complex</span>(<span class="built_in">cos</span>(<span class="number">2</span> * PI / n*i), <span class="built_in">sin</span>(<span class="number">2</span> * PI / n*i));</span><br><span class="line">		iomega[i] = omega[i].<span class="built_in">rev</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dft</span><span class="params">(Complex *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fft</span>(a, n,omega);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idft</span><span class="params">(Complex *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">fft</span>(a, n,iomega);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)a[i] =a[i]/ n;</span><br><span class="line">&#125;</span><br><span class="line">Complex a[<span class="number">140000</span>], b[<span class="number">140000</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">140000</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">50005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s)) &#123;</span><br><span class="line">        <span class="built_in">ms</span>(ans,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s), n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">50005</span>;i++)a[i] = b[i] = <span class="built_in">Complex</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)a[<span class="built_in">strlen</span>(s) - i - <span class="number">1</span>].real=s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">		len += <span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)b[<span class="built_in">strlen</span>(s) - i - <span class="number">1</span>].real=s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; n)&lt;len)n++;</span><br><span class="line">		n = (<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">		<span class="built_in">init</span>(n);</span><br><span class="line">		<span class="built_in">dft</span>(a, n);</span><br><span class="line">		<span class="built_in">dft</span>(b, n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)a[i] =a[i]* b[i];</span><br><span class="line">		<span class="built_in">idft</span>(a, n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)ans[i] = (<span class="keyword">int</span>)(a[i].real + <span class="number">0.5</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>;</span><br><span class="line">			ans[i] = ans[i] % <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> cal = n;</span><br><span class="line">		<span class="keyword">while</span> (!ans[cal]&amp;&amp;cal&gt;<span class="number">0</span>)cal--;</span><br><span class="line">		<span class="keyword">while</span> (cal &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[cal]);</span><br><span class="line">			cal--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>FFT</category>
      </categories>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>Fragment管理指北</title>
    <url>/2021/08/07/Fragment%E7%AE%A1%E7%90%86%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/08/15/nLZ2zDdq7bAUy9S.jpg" alt="fragment-management-cover.jpeg"></p>
<p>随着ViewModel的大量使用，曾经并不是那么好用的Fragment走上了主流的舞台。相较于简明易懂的Activity管理，Fragment的管理更为复杂。在上周的需求中，我和同事共同完成了一个旧页面的彻底改造。在改造的过程中，我们发现了一个Fragment偶尔重复添加的bug。由于报错信息有限，同时对于Fragment的理解不够，我直接就是一波反向定位:new_moon_with_face:， 认为主要的问题是Activity被kill后恢复时，未判断是否是第一次添加fragment导致了重复添加。最后发现并不是这个问题导致的重复添加:disappointed_relieved:，但是探索的过程非常有趣，也增加了我对Fragment的理解。所以写下此文与大家分享。</p>
<span id="more"></span>
<h1 id="茴字有四样写法，你知道么？"><a href="#茴字有四样写法，你知道么？" class="headerlink" title="茴字有四样写法，你知道么？"></a>茴字有四样写法，你知道么？</h1><h2 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h2><p>Fragment的replace也许是最简单的替换方法，也是《第一行代码》第一个提到的Fragment管理方式。replace首先会清空同一容器Id下的Fragment栈（remove），然后才是添加新的Fragment。这样处理最大的优点就是简单，因为如果我们全部使用replace的话，显然栈中永远只有一个Fragment，管理起来非常方便。但是简单的背面是每次销毁重建Fragment，带来的性能消耗是难以想象的。所以引出了基于栈的管理方式。</p>
<h2 id="Add-Show和Hide"><a href="#Add-Show和Hide" class="headerlink" title="Add, Show和Hide"></a>Add, Show和Hide</h2><p>Fragment的管理类BackStackRecord使用了一个ArrayList（为什么是ArrayList不是Stack？）来管理我们的每一个操作。</p>
<p><img src="https://i.loli.net/2021/08/15/cFHandkxYV87uez.png" alt="fragment-op-flag.png"></p>
<p><img src="https://i.loli.net/2021/08/15/oaqBpQgLH2X95DO.png" alt="fragment-op-class.png"></p>
<p>结合FragmentTransaction中的静态变量和Op类，FragmentTransaction的实现类能够记录我们每一次对Fragment进行的操作，这通常代表我们能够很轻松地完成回滚操作（已帮我们封装好）。同时给予了我们fragment复用的能力。要想享受这些能力，我们就应该使用add来添加新的Fragment，而不是replace。但是add同样有自己的问题。</p>
<p><img src="https://i.loli.net/2021/08/15/nPTLRbwlzpE6rCG.gif" alt="fragment-add-only.gif"></p>
<p>当我们只add不进行hide，show管理时，fragment会重叠在一起（！）。所以添加多个Fragment时一定要进行hide，show处理。但是这样就高枕无忧了吗？看看这样一个片段，这里我开启了开发者模式退出app就kill进程的开关。</p>
<p><img src="https://i.loli.net/2021/08/15/o3iBbPqtrhuDfs8.gif" alt="fragment-rebuild-after-destroy.gif"></p>
<p>管理Fragment的Activity代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Use this flag to remember the current Fragment</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentFragmentTag: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(TestViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">addFragment</span><span class="params">(fragment: <span class="type">Fragment</span>, fragmentTag: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> cur: Fragment? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> nxt: Fragment? = <span class="literal">null</span></span><br><span class="line">        currentFragmentTag?.let &#123;</span><br><span class="line">            cur = supportFragmentManager.findFragmentByTag(currentFragmentTag)</span><br><span class="line">        &#125;</span><br><span class="line">        fragmentTag?.let &#123;</span><br><span class="line">            nxt = supportFragmentManager.findFragmentByTag(fragmentTag)</span><br><span class="line">        &#125;</span><br><span class="line">        supportFragmentManager.beginTransaction().apply &#123;</span><br><span class="line">            <span class="comment">// Hide the current fragment</span></span><br><span class="line">            cur?.let &#123;</span><br><span class="line">                hide(it)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*  </span></span><br><span class="line"><span class="comment">             * If the fragment has been already existed in the stack, reuse it.</span></span><br><span class="line"><span class="comment">             * Else add the new fragment.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            nxt?.let &#123; show(it) &#125; ?: add(R.id.main_container, fragment, fragmentTag)</span><br><span class="line">            commit()</span><br><span class="line">        &#125;</span><br><span class="line">        currentFragmentTag = fragmentTag</span><br><span class="line">        Log.d(<span class="string">&quot;Main&quot;</span>, supportFragmentManager.backStackEntryCount.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Control logic</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        testViewModel.fragmentIndex.observe(<span class="keyword">this</span>, Observer&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                <span class="number">1</span> -&gt; addFragment(FirstFragment(), FirstFragment.TAG)</span><br><span class="line">                <span class="number">2</span> -&gt; addFragment(SecondFragment(), SecondFragment.TAG)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        testViewModel.fragmentIndex.value = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新出现的问题，和之前只add没有hide，show处理的情况有些类似。很容易联想到是否在哪个环节又出现了只add没有hide的操作。通过查阅资料我们能够了解到，当Activity因为内存不足被回收时，会调用onSaveInstance()来保存视图层（FragmentActivity提供实现)。当Activity再度重建时，之前实例化的fragment会恢复到Activity中。同时onCreate中又走了一遍创建新fragment的逻辑，所以导致了fragment的重叠。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="重写onSaveInstanceState"><a href="#重写onSaveInstanceState" class="headerlink" title="重写onSaveInstanceState"></a>重写onSaveInstanceState</h3><p>如果不走父类的onSaveInstanceState，那么恢复fragment的流程也不会走。当然，所有的状态也都会丢失</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//super.onSaveInstanceState(outState)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过onCreate的参数savedInstanceState判断是否第一次加载"><a href="#通过onCreate的参数savedInstanceState判断是否第一次加载" class="headerlink" title="通过onCreate的参数savedInstanceState判断是否第一次加载"></a>通过onCreate的参数savedInstanceState判断是否第一次加载</h3><p>在第一次创建时，savedInstanceState总是为null。而当恢复activity时，savedInstanceState中保存了数据不再为空，那么我们显然能够通过这种方式来判断是否需要创建新的fragment。这里需要注意的是我们不能使用viewmodel来保存当前的页面，因为viewmodel只在activity是在前台被销毁时，恢复时能够获取到相同的viewmodel。如果activity是在后台太久被杀死的，那么就获取不到相同的viewmodel了。所以唯一的解决方式是通过savedInstanceState来保存信息，恢复时重新读取并赋值给ViewModel一些相关值（比如我存了当前页的Id在ViewModel中，需要恢复）。这样就能完美解决我们的问题。</p>
<p><img src="https://i.loli.net/2021/08/16/91xaH6i72heyzBv.gif" alt="fragment-final.gif"></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentFragmentTag: String? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> testViewModel <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        ViewModelProvider(<span class="keyword">this</span>).<span class="keyword">get</span>(TestViewModel::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">replaceFragment</span><span class="params">(fragment: <span class="type">Fragment</span>, fragmentTag: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> cur: Fragment? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> nxt: Fragment? = <span class="literal">null</span></span><br><span class="line">        currentFragmentTag?.let &#123;</span><br><span class="line">            cur = supportFragmentManager.findFragmentByTag(currentFragmentTag)</span><br><span class="line">        &#125;</span><br><span class="line">        fragmentTag?.let &#123;</span><br><span class="line">            nxt = supportFragmentManager.findFragmentByTag(fragmentTag)</span><br><span class="line">        &#125;</span><br><span class="line">        supportFragmentManager.beginTransaction().apply &#123;</span><br><span class="line">            cur?.let &#123;</span><br><span class="line">                hide(it)</span><br><span class="line">            &#125;</span><br><span class="line">            nxt?.let &#123; show(it) &#125; ?: add(R.id.main_container, fragment, fragmentTag)</span><br><span class="line">            commit()</span><br><span class="line">        &#125;</span><br><span class="line">        currentFragmentTag = fragmentTag</span><br><span class="line">        Log.d(<span class="string">&quot;Main&quot;</span>, supportFragmentManager.backStackEntryCount.toString())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        <span class="comment">// Not the first time, recover data.</span></span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState!=<span class="literal">null</span>)&#123;</span><br><span class="line">            testViewModel.fragmentIndex.value = savedInstanceState.getInt(<span class="string">&quot;finalIndex&quot;</span>)</span><br><span class="line">            currentFragmentTag = savedInstanceState.getString(<span class="string">&quot;finalTag&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        testViewModel.fragmentIndex.observe(<span class="keyword">this</span>, Observer&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                <span class="number">1</span> -&gt; replaceFragment(FirstFragment(), FirstFragment.TAG)</span><br><span class="line">                <span class="number">2</span> -&gt; replaceFragment(SecondFragment(), SecondFragment.TAG)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// First time to create the activity. </span></span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState==<span class="literal">null</span>)testViewModel.fragmentIndex.value = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Save important data here.</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">        currentFragmentTag?.let &#123;</span><br><span class="line">            outState.putString(<span class="string">&quot;finalTag&quot;</span>, it)</span><br><span class="line">        &#125;</span><br><span class="line">        testViewModel.fragmentIndex.value?.let&#123;</span><br><span class="line">            outState.putInt(<span class="string">&quot;finalIndex&quot;</span>,it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工程</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3068  最长回文</title>
    <url>/2017/10/13/HDU%20-%203068%20%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87/</url>
    <content><![CDATA[<p><em>思路：</em><br>一道神奇的回文题，使用O(n^2)复杂度的算法会超时，需要使用manacher算法。manacher算法简而言之就是利用了已经获得的回文字符串左右对称的性质，观察现在所在的字符是不是在已有回文串中，利用回文串左边求得的回文长度来初始化右边来减少重复计算，需要记录当前会问能达到的最右端。复杂度为O(n)，因为最右端最多移动n次，所以复杂度很低。<br><span id="more"></span></p>
<p><em>代码：</em><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">110000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> p[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">manacher</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>, r = <span class="number">0</span>,length=<span class="built_in">strlen</span>(str),maxs = <span class="number">0</span>;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; r)p[i] = <span class="built_in">min</span>(r - i, p[<span class="number">2</span> * pos - i]); <span class="keyword">else</span> p[i] = <span class="number">1</span>; <span class="keyword">while</span> (str[i - p[i]] == str[i + p[i]])p[i]++; <span class="keyword">if</span> (i + p[i]&gt; r)r = i + p[i], pos = i;</span><br><span class="line">        maxs = <span class="built_in">max</span>(maxs, p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxs<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> str[MAX*<span class="number">2</span>],astr[MAX*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; str) &#123;</span><br><span class="line">        astr[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span>,astr[<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;str[i]!=<span class="string">&#x27;\0&#x27;</span>;i++, j += <span class="number">2</span>)astr[j] = str[i], astr[j + <span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        astr[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">manacher</span>(astr)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>Manacher</category>
      </categories>
      <tags>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2586 How far away ？</title>
    <url>/2017/11/20/HDU%20-%202586%20How%20far%20away%20%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>模板题，保存DFS序后使用RMQ求LCA。这个算法相对来说比较好理解。我们访问的顺序是类似根-子节点-根的顺序，记录访问顺序后使用RMQ查询两点之间depth的最小值就是LCA。这题我真的是无限RE,最后发现是自己ST表的模板有问题。。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">40010</span>,MAX_LOG_V=<span class="number">25</span>;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; G[MAX_V];</span><br><span class="line"><span class="keyword">int</span> root,n,m;</span><br><span class="line"><span class="keyword">int</span> vis[MAX_V];</span><br><span class="line"><span class="keyword">int</span> vs[MAX_V * <span class="number">2</span> ];</span><br><span class="line"><span class="keyword">int</span> depth[MAX_V * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> id[MAX_V];</span><br><span class="line"><span class="keyword">int</span> dist[MAX_V];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> p, <span class="keyword">int</span> d, <span class="keyword">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">	id[v] = ++k;</span><br><span class="line">	vis[v] = <span class="number">1</span>;</span><br><span class="line">	vs[k] = v;</span><br><span class="line">	depth[k] = d;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; G[v].<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[G[v][i].first]) &#123;</span><br><span class="line">			dist[G[v][i].first] = dist[v] + G[v][i].second;</span><br><span class="line">			<span class="built_in">dfs</span>(G[v][i].first, v, d + <span class="number">1</span>, k);</span><br><span class="line">			vs[++k] = v;</span><br><span class="line">			depth[k] = d;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>*MAX_V][MAX_LOG_V];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> K = (<span class="keyword">int</span>)(<span class="built_in">log</span>((<span class="keyword">double</span>)len) / <span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i +(<span class="number">1</span>&lt;&lt;j)- <span class="number">1</span> &lt;= len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> a = dp[i][j - <span class="number">1</span>], b = dp[i + (<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (depth[a] &lt; depth[b]) dp[i][j] = a;</span><br><span class="line">			<span class="keyword">else</span>            dp[i][j] = b;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RMQ</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> K = (<span class="keyword">int</span>)(<span class="built_in">log</span>((<span class="keyword">double</span>)(y - x + <span class="number">1</span>)) / <span class="built_in">log</span>(<span class="number">2.0</span>));</span><br><span class="line">	<span class="keyword">int</span> a = dp[x][K], b = dp[y - (<span class="number">1</span>&lt;&lt;K) + <span class="number">1</span>][K];</span><br><span class="line">	<span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span>            <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = id[u], y = id[v];</span><br><span class="line">	<span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">	<span class="keyword">int</span> res = <span class="built_in">RMQ</span>(x, y);</span><br><span class="line">	<span class="keyword">return</span> vs[res];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t,u,v,val;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAX_V;i++)G[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">ms</span>(vs, <span class="number">0</span>), <span class="built_in">ms</span>(depth, <span class="number">0</span>), <span class="built_in">ms</span>(id, <span class="number">0</span>), <span class="built_in">ms</span>(id, <span class="number">0</span>), <span class="built_in">ms</span>(dist, <span class="number">0</span>),<span class="built_in">ms</span>(vis,<span class="number">0</span>),<span class="built_in">ms</span>(dp,<span class="number">0</span>);</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) &#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;</span><br><span class="line">			G[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v, val)), G[v].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u, val));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, k);</span><br><span class="line">		<span class="built_in">ST</span>(n* <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			<span class="keyword">int</span> z = <span class="built_in">LCA</span>(u, v);</span><br><span class="line">			cout &lt;&lt; dist[u] + dist[v] - <span class="number">2</span> * dist[z]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3555 Bomb</title>
    <url>/2017/10/14/HDU%20-%203555%20Bomb/</url>
    <content><![CDATA[<p><em>思路</em><br>现在发现自己的dp实在是烂，决定把kuangbin专题下的dp都刷一遍。<br><span id="more"></span><br>数位dp的题通常会让你求在[l,r]区间中符合条件的数，比如这道题是带有‘49’的数。为了求解，我们使用一个二位的dp数组，第一维是长度，第二维是这位的数字（1-9）。首先我们要初始化dp数组，然后再判断小于给定n的数有多少个不包括49.这是一个二重循环，第一重循环是当前位数，第二重是1-digit[i]-1。我们可以理解为对一个数2345，我们先固定首位2，计算2000-2299，然后2300-2339这样递推，然后注意下当前数包含49的话可以直接退出循环，因为后面的数都不符合条件（比如4949，算完前两位就不用算了）。<br><em>代码</em><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll dp[<span class="number">45</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//in order to init dp[1][i]=1</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">40</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">9</span>;j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">9</span>;k++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!(j == <span class="number">4</span> &amp;&amp; k == <span class="number">9</span>))dp[i][j] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> digit[<span class="number">45</span>];</span><br><span class="line">	ll x = n, j = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x) &#123;</span><br><span class="line">		digit[j++] = x % <span class="number">10</span>;</span><br><span class="line">		x /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(digit, digit + j);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;j;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;digit[i];k++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!(digit[i<span class="number">-1</span>]==<span class="number">4</span>&amp;&amp;k==<span class="number">9</span>))ans += dp[j - i][k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (digit[i - <span class="number">1</span>] == <span class="number">4</span> &amp;&amp; digit[i] == <span class="number">9</span>)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="built_in">ms</span>(dp, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		cout &lt;&lt; n + <span class="number">1</span> - <span class="built_in">solve</span>(n + <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3853 LOOPS(概率dp)</title>
    <url>/2018/03/16/HDU%20-%203853%20LOOPS(%E6%A6%82%E7%8E%87dp)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>概率/期望dp。本题我们能通过全期望公式得到dp[i][j]=dp[i+1][j]*map[i][j][2]+dp[i][j+1]*map[i][j][1]+dp[i][j]*map[i][j][0]+2得到(2是消耗的能量）。由于dp要求无后效性，我们移项得到dp[i][j]=(dp[i+1][j]*map[i][j][2]+dp[i][j+1]*map[i][j][1]+2)/(1-map[i][j][0])。需要注意的是对于概率dp，我们通常正推，但期望dp我们通常反着推。就期望dp来说，正推最大的困难点在于一个点可能是直接转移过来的，但也有可能在原地停留后再转移，即转移概率需要另外计算，所以概率并不是简单的map[i][j][k]。对于本题来说正推计算后的公式实际上还能接受，但对像hdu4405这种题来说正推的转移太复杂了，所以我们考虑泛用性更好的反推。对于一个点X，显然有如下转移<br><img src="https://i.loli.net/2020/12/14/tXukgZoTeAs7dfH.jpg" alt="hdu-3853-1"><br>那我们显然地，通过这个转移从起点到终点的期望等于使用这个转移从终点到起点的期望。对于这个反推我们考虑从右下往左上推，注意，这个时候每个点的期望是从<strong>右边的点，下面的点和自己</strong>推来的，这意味着原来正推的时候该点左下角的点对该点下面的点的影响是没有的，所以可以放心的使用全期望公式。<br>总结一下，我们使用反推通常是因为我们可以很方便地知道一个点到下一个点的转移概率，这个概率在反推的时候是不用额外计算的。但正推就要考虑之前的点有没有通过多种方式转移到这个点，我们需要考虑转移的概率究竟是几。两相比较之下显然反推比较优秀。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">double</span> maps[MAXN][MAXN][<span class="number">3</span>],dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r,c;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;c))&#123;</span><br><span class="line">        <span class="built_in">ms</span>(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">                    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;maps[i][j][k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=c;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==r&amp;&amp;j==c)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(maps[i][j][<span class="number">0</span>]==<span class="number">1.00</span>)<span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j]=(dp[i][j+<span class="number">1</span>]*maps[i][j][<span class="number">1</span>]+dp[i+<span class="number">1</span>][j]*maps[i][j][<span class="number">2</span>]+<span class="number">2</span>)/(<span class="number">1</span>-maps[i][j][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>概率dp</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3949 XOR</title>
    <url>/2018/01/22/HDU%20-%203949%20XOR/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>线性基模板题<br><span id="more"></span></p>
<h3 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h3><p>一个向量空间中既是线性无关，同时又能张成该向量空间的向量组V称为向量空间的基。<br>acm中线性基通常用来计算子集异或问题，如子集最大，最小，第k大异或和，线性基有一个非常重要的性质：</p>
<blockquote>
<p>对于任意一个存在于线性基的二进制位，至多只有一个数bj满足第i位为1</p>
</blockquote>
<p>也就是说如果我们要选第k大的异或值，我们只要选择k各个二进制位换算成的数在线性基中是第几个数，然后异或一下就是第k大的（因为两两行之间不会出现抵消使得结果变小）。</p>
<h3 id="线性基求法"><a href="#线性基求法" class="headerlink" title="线性基求法"></a>线性基求法</h3><p>线性基的求法与线性代数正交基的构造方法——格拉姆-施密特方法非常像，大家可以类比地去学习。<br>假定我们读入n个数，存放在a[n]，再令b[MAXP]为我们的线性基数列，MAXP为读入数二进制位的最大位数。若我们构造到a[n],我们从高位到低位进行计算。若计算到第j位，我们发现a[i]的二进制位有这个1，那我们看b[j]的基是否已经存在，如果存在，那么我们吧b[j]的影响从a[i]中减掉，表现为b[j]^=a[i],如果不存在，那么我们b[j]=a[i],同时先将比b[j]小的基对b[j]的影响消除，表现为b[j]^=b[k];。对比b[j]大的基，我们要消除b[j]对他们的影响，表现为算法中的b[k]^=b[j]。我们重复计算后就能算出a的线性基。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll *a,ll n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ms</span>(b,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=MAXP;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[i]&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b[j])a[i]^=b[j];<span class="comment">//eliminate the influence of b[j] in a[i];</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    b[j]=a[i];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)<span class="keyword">if</span>(b[k]&amp;&amp;((b[j]&gt;&gt;k)&amp;<span class="number">1</span>))b[j]^=b[k];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;=MAXP;k++)<span class="keyword">if</span>(b[k]&gt;&gt;j&amp;<span class="number">1</span>)b[k]^=b[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题是线性基第k小的模板题。思路上问讲过，不过要注意当出现无法插入的值的时候，说明有向量线性相关，所以我们要考虑异或值可以生成0（线性基没有考虑生成0）。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.sengxian.com/algorithms/linear-basis">线性基学习笔记</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ((x&lt;&lt;1)|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100000</span>+<span class="number">10</span>,MAXP=<span class="number">62</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Linear_Basis</span>&#123;</span></span><br><span class="line">    ll b[MAXN];</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    <span class="keyword">int</span> zero;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(ll *a,ll n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="comment">//in order to cal the time of update</span></span><br><span class="line">        <span class="built_in">ms</span>(b,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=MAXP;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>((a[i]&gt;&gt;j)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(b[j])a[i]^=b[j];<span class="comment">//eliminate the influence of b[j] in a[i];</span></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        b[j]=a[i],cnt++;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=j<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)<span class="keyword">if</span>(b[k]&amp;&amp;((b[j]&gt;&gt;k)&amp;<span class="number">1</span>))b[j]^=b[k];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;=MAXP;k++)<span class="keyword">if</span>(b[k]&gt;&gt;j&amp;<span class="number">1</span>)b[k]^=b[j];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&lt;n)zero=<span class="number">1</span>;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=MAXP;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i])v.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(zero)k--;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=(<span class="number">1ll</span>&lt;&lt;(<span class="keyword">int</span>)v.<span class="built_in">size</span>()))<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((k&gt;&gt;i)&amp;<span class="number">1</span>)ans^=v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;lb;</span><br><span class="line"></span><br><span class="line">ll a[<span class="number">100050</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n,m,q;</span><br><span class="line">    ll k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;T;z++)&#123;</span><br><span class="line">        lb.zero=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;a[i]);</span><br><span class="line">        lb.<span class="built_in">build</span>(a,n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,z+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;k);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,lb.<span class="built_in">query</span>(k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>线性基</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3948 The Number of Palindromes</title>
    <url>/2018/01/18/HDU%20-%203948%20The%20Number%20of%20Palindromes/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>计算本质不同的回文串，回文树模板题<br><span id="more"></span></p>
<h3 id="回文树"><a href="#回文树" class="headerlink" title="回文树"></a>回文树</h3><p>顾名思义，就是一个解决关于回文问题的数据结构，通常用来处理本质不同回文的个数。</p>
<h3 id="回文树的元素"><a href="#回文树的元素" class="headerlink" title="回文树的元素"></a>回文树的元素</h3><p>1.len[i]:i节点表示的回文串长度<br>2.next[i][c]:在i节点表示的回文串两边加c得到的回文串<br>3.fail[i]:当i失配后跳转不等于i表示的回文串自身的最长后缀回文<br>4.cnt[i]:节点i表示的本质不同的串的个数<br>5.num[i]:以节点i节点最右端点为回文串的结尾的回文串个数（需要在建完树后运行count）<br>6.last:上一个构建的回文串的位置<br>7.S[i]:第i次加入的字符S[0]=-1<br>8.p:添加的节点个数<br>9.n:添加的字符个数</p>
<h3 id="回文树的构造"><a href="#回文树的构造" class="headerlink" title="回文树的构造"></a>回文树的构造</h3><p>在参考中的《Palindromic Tree——回文树【处理一类回文串问题的强力工具】》详细讲解了回文树的构造方式，这里不再重复，主要讲讲我对回文树fail的理解。<br><img src="https://i.loli.net/2020/12/14/TCMupwrNEIsxYKt.jpg" alt="回文树的构造"><br>当我们加入一个字符X时，如果我们希望XAX是一个回文串，那么A就必须是一个回文串，所以fail指针指向的就是在到结尾结束的回文串中更短的那个。如果A等于零，那么fail最终会指向长度为1的回文串，也就是我们想加入的字符X。这就是fail指针的意义。</p>
<h3 id="回文树的应用"><a href="#回文树的应用" class="headerlink" title="回文树的应用"></a>回文树的应用</h3><p>1.求串S前缀0~i内本质不同回文串的个数（两个串长度不同或者长度相同且至少有一个字符不同便是本质不同）(直接构造计算)<br>2.求串S内每一个本质不同回文串出现的次数（cnt[i])<br>3.求串S内回文串的个数（其实就是1和2结合起来）(p-2,也就是节点数-两个奇偶节点)<br>4.求以下标i结尾的回文串的个数（num[i])</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/u013368721/article/details/42100363">Palindromic Tree——回文树【处理一类回文串问题的强力工具】</a><br><a href="http://blog.csdn.net/lwfcgz/article/details/48739051">回文树介绍(Palindromic Tree)</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ((x&lt;&lt;1)|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">26</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Palindromic_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nexts[MAXN][N],fail[MAXN],cnt[MAXN],num[MAXN],len[MAXN],S[MAXN],last,n,p;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        p=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">newnode</span>(<span class="number">-1</span>);</span><br><span class="line">        last=<span class="number">0</span>,n=<span class="number">0</span>,</span><br><span class="line">        S[n]=<span class="number">-1</span>;</span><br><span class="line">        fail[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();i++)<span class="built_in">add</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)nexts[p][i]=<span class="number">0</span>;</span><br><span class="line">        cnt[p]=<span class="number">0</span>,num[p]=<span class="number">0</span>,len[p]=length;</span><br><span class="line">        <span class="keyword">return</span> p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        c-=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        S[++n]=c;</span><br><span class="line">        <span class="keyword">int</span> cur=<span class="built_in">getFail</span>(last);</span><br><span class="line">        <span class="keyword">if</span>(!nexts[cur][c])&#123;</span><br><span class="line">            <span class="keyword">int</span> now=<span class="built_in">newnode</span>(len[cur]+<span class="number">2</span>);</span><br><span class="line">            fail[now]=nexts[<span class="built_in">getFail</span>(fail[cur])][c];</span><br><span class="line">            nexts[cur][c]=now;</span><br><span class="line">            num[now]=num[fail[now]]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last=nexts[cur][c];</span><br><span class="line">        cnt[last]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFail</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(S[n-len[x]<span class="number">-1</span>]!=S[n])x=fail[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=p<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) cnt[fail[i]] += cnt[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;pt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;str;</span><br><span class="line">            pt.<span class="built_in">init</span>(str);</span><br><span class="line">            pt.<span class="built_in">Count</span>();</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;pt.p<span class="number">-2</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>回文树</category>
      </categories>
      <tags>
        <tag>回文树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 4089 Activation(概率dp)</title>
    <url>/2018/04/05/HDU%20-%204089%20Activation(%E6%A6%82%E7%8E%87dp)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题我们定义dp[i][j]为队伍中有i个人Tomato排在第j个时，服务器崩溃且排在他前面的人有大于等于k个人的概率。<br>一共有三个转移方程（注意是逆推）：</p>
<ol>
<li>dp[i][1]=p1*dp[i][1]+p2*dp[i][i]+p4，因为要求无后效性，化简可得dp[i][1]=p2/(1-p1)*dp[i][i]+p4/(1-p1)</li>
<li>对j属于[1,k]有：dp[i][j]=p1*dp[i][j]+p2*dp[i][j-1]+p3*dp[i-1][j-1]+p4，同样因为要求无后效性，化简可得dp[i][j]=p2/(1-p1)*dp[i][j-1]+p3/(1-p1)*dp[i-1][j-1]+p4/(1-p1)</li>
<li>对j属于[k+1,n]有:dp[i][j]=p1*dp[i][j]+p2*dp[i][j-1]+p3*dp[i-1][j-1]，化简可得dp[i][j]=p2/(1-p1)*dp[i][j-1]+p3/(1-p1)*dp[i-1][j-1]</li>
</ol>
<p>接下来我们发现这个dp转移方程。。构成了一个环？不过这道题并没有用到高斯消元，我们将dp转移中第j项与dp[i]即当前状态无关的令为一个常数c[j]，然后对第一个方程迭代。我们最后化简可得如下式子：<br><img src="https://i.loli.net/2020/12/14/U2rTOzRv1ctio4y.png" alt="hdu4089"><br>然后我们用转移方程求出所有dp[i]的状态，然后dp[n][m]就是答案。这题有个比较奇怪的点，似乎如果不对p4约等于0的情况进行特判会出问题？不是很懂为什么。。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2020</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">double</span> p1,p2,p3,p4;</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">2</span>][MAXN],c[MAXN],pp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%lf%lf%lf%lf&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;p1,&amp;p2,&amp;p3,&amp;p4))&#123;</span><br><span class="line">        <span class="keyword">double</span> p21=p2/(<span class="number">1</span>-p1),p31=p3/(<span class="number">1</span>-p1),p41=p4/(<span class="number">1</span>-p1);</span><br><span class="line">        <span class="keyword">if</span>(p4&lt;eps)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0.00000\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pp[<span class="number">0</span>]=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)pp[i]=pp[i<span class="number">-1</span>]*p21;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            c[<span class="number">1</span>]=p41;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=k;j++)c[j]=p31*dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>]+p41;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k+<span class="number">1</span>;j&lt;=n;j++)c[j]=p31*dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">double</span> tmp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)tmp+=c[j]*pp[i-j];</span><br><span class="line">            dp[i&amp;<span class="number">1</span>][i]=tmp/(<span class="number">1</span>-pp[i]);</span><br><span class="line">            dp[i&amp;<span class="number">1</span>][<span class="number">1</span>]=p21*dp[i&amp;<span class="number">1</span>][i]+p41;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=n;j++)dp[i&amp;<span class="number">1</span>][j]=p21*dp[i&amp;<span class="number">1</span>][j<span class="number">-1</span>]+c[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.5f\n&quot;</span>,dp[n&amp;<span class="number">1</span>][m]);</span><br><span class="line">        <span class="built_in">ms</span>(dp,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>概率dp</category>
      </categories>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 4514 湫湫系列故事——设计风景线</title>
    <url>/2018/03/15/HDU%20-%204514%20%E6%B9%AB%E6%B9%AB%E7%B3%BB%E5%88%97%E6%95%85%E4%BA%8B%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E9%A3%8E%E6%99%AF%E7%BA%BF/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>并查集判环+树的直径。注意树有可能是不连通的。<br>树的直径通过两次bfs就能得到，具体证明见<a href="https://www.cnblogs.com/wuyiqi/archive/2012/04/08/2437424.html">树的直径（最长路）的详细证明</a><br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">2000005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> fa[MAXN],ranks[MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],to[MAXM],nexts[MAXM],wei[MAXM],edge,dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN],used[MAXN];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    edge=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ms</span>(head,<span class="number">-1</span>),<span class="built_in">ms</span>(vis,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)fa[i]=i,ranks[i]=<span class="number">0</span>;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x]=<span class="built_in">getfa</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">getfa</span>(x),y=<span class="built_in">getfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(ranks[x]&lt;ranks[y])fa[x]=y;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[y]=x;</span><br><span class="line">        <span class="keyword">if</span>(ranks[x]==ranks[y])ranks[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getfa</span>(x)==<span class="built_in">getfa</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    wei[edge]=w,to[edge]=v,nexts[edge]=head[u],head[u]=edge++;</span><br><span class="line">    wei[edge]=w,to[edge]=u,nexts[edge]=head[v],head[v]=edge++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ms</span>(used,<span class="number">0</span>),<span class="built_in">ms</span>(dis,<span class="number">0</span>);</span><br><span class="line">    used[s]=<span class="number">1</span>,dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())Q.<span class="built_in">pop</span>();</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=nexts[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v=to[i];</span><br><span class="line">            <span class="keyword">if</span>(!used[v])&#123;</span><br><span class="line">                used[v]=<span class="number">1</span>;</span><br><span class="line">                dis[v]=dis[u]+wei[i];</span><br><span class="line">                Q.<span class="built_in">push</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">treedim</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u=s,maxs=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">bfs</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i]&gt;maxs)u=i,maxs=dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(u);</span><br><span class="line">    maxs=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)maxs=<span class="built_in">max</span>(maxs,dis[i]);</span><br><span class="line">    <span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">same</span>(u,v))flag=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">unite</span>(u,v);</span><br><span class="line">            <span class="built_in">addEdge</span>(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> maxs=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[i])maxs=<span class="built_in">max</span>(maxs,<span class="built_in">treedim</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxs);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>树的直径</category>
      </categories>
      <tags>
        <tag>树上操作</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 5443 The Water Problem(ST表)</title>
    <url>/2018/07/10/HDU%20-%205443%20The%20Water%20Problem(ST%E8%A1%A8)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>ST表模板<br><span id="more"></span></p>
<h3 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h3><p>ST表是rmq的一种实现方式。初始化复杂度O(nlogn)，查询O(1),不支持修改，不能实现区间和(与st表查询方式有关，但我仔细想了想，感觉似乎修改下查询应该能在logn时间里得到区间和)。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>ST表的初始化用到了倍增的思路。我们令ST[i][j]维护的是从i开始的，长度为2^j的区间，即[i,i+2^j-1]。那么显然有st[i][j]=function(min,max,|,…自选)(st[i][j-1],st[i+2^(j-1)][j-1])。因为st表维护区间的长度都是2的倍数，所以能做到区间合并时不重不漏。</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询时我们取k=(int)log2(n)。然后求max(st[x][k],st[y-powerOfTwo[k]+1][k])即可。这样的区间实际上是有重叠的，所以这也是为什么我之前说的st表不能处理区间和问题。但是因为在rmq中没有这样的问题，所以我们大可放心使用。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//STtable and data needed</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LogMAXN=(<span class="keyword">int</span>)(<span class="built_in">log</span>(MAXN)/<span class="built_in">log</span>(<span class="number">2</span>))+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STtable</span>&#123;</span></span><br><span class="line">    <span class="comment">//init O(nlogn),query O(1)</span></span><br><span class="line">    <span class="comment">//st[i][j] means it charges the interval of [i,i+2^j-1]</span></span><br><span class="line">    T st[MAXN][LogMAXN];</span><br><span class="line">    <span class="keyword">int</span> powerOfTwo[LogMAXN],logOfTwo[MAXN];</span><br><span class="line">    <span class="built_in">STtable</span>(T A[],<span class="keyword">int</span> n)&#123;</span><br><span class="line">        powerOfTwo[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;LogMAXN;i++)powerOfTwo[i]=(powerOfTwo[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        logOfTwo[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)logOfTwo[i]=((i)&amp;(i<span class="number">-1</span>))==<span class="number">0</span>?logOfTwo[i<span class="number">-1</span>]+<span class="number">1</span>:logOfTwo[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)st[i][<span class="number">0</span>]=A[i];</span><br><span class="line">        <span class="comment">//STtable initiation, you may change the function here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=logOfTwo[n];i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j+powerOfTwo[i]<span class="number">-1</span>&lt;n;j++)&#123;</span><br><span class="line">                st[j][i]=<span class="built_in">max</span>(st[j][i<span class="number">-1</span>],st[j+powerOfTwo[i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=logOfTwo[y-x+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(st[x][k],st[y-powerOfTwo[k]+<span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,q,l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="function">STtable&lt;<span class="keyword">int</span>&gt; <span class="title">st</span><span class="params">(a,n)</span></span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,st.<span class="built_in">rmq</span>(l<span class="number">-1</span>,r<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>ST表</category>
      </categories>
      <tags>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 4757 Tree</title>
    <url>/2018/02/14/HDU%20-%204757%20Tree/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可持久化trie树和主席树的构造类似。这题与之前主席树不同的地方就是在树上建树，类似spoj cot那题。对第n个节点，我们维护根-n这条链上的字典树。然后求x-y路径上的异或最大值时我们用x上的字典树+y上的字典树-两倍lca的父亲的字典树（因为根到lca父亲的字典树加了两遍），然后就是对常规的01字典树的考察。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>,MAX_LOGN=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tree[MAXN*<span class="number">20</span>][<span class="number">2</span>],value[MAXN*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> root[MAXN];</span><br><span class="line"><span class="keyword">int</span> parent[MAX_LOGN][MAXN],depth[MAXN];</span><br><span class="line"><span class="keyword">int</span> nodecnt,rootcnt;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tree[nodecnt][<span class="number">0</span>]=<span class="number">0</span>,tree[nodecnt][<span class="number">1</span>]=<span class="number">0</span>,value[nodecnt]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> nodecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inserts</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> fa,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tp=root[pos],tpfa=root[fa];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">15</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=(val&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tree[tp][c])&#123;</span><br><span class="line">            <span class="keyword">int</span> id=<span class="built_in">newnode</span>();</span><br><span class="line">            tree[tp][c]=id;</span><br><span class="line">            tree[tp][!c]=tree[tpfa][!c];</span><br><span class="line">            value[tree[tp][c]]=value[tree[tpfa][c]];</span><br><span class="line">        &#125;</span><br><span class="line">        tp=tree[tp][c],tpfa=tree[tpfa][c];</span><br><span class="line">        value[tp]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> xylca,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> posx=root[x],posy=root[y],poslca,ans=<span class="number">0</span>;</span><br><span class="line">    poslca=parent[<span class="number">0</span>][xylca]==<span class="number">-1</span>?<span class="number">0</span>:root[parent[<span class="number">0</span>][xylca]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">15</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">int</span> c=(val&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(value[tree[posx][!c]]+value[tree[posy][!c]]<span class="number">-2</span>*value[tree[poslca][!c]]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans|=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            c=!c;</span><br><span class="line">        &#125;</span><br><span class="line">        posx=tree[posx][c],posy=tree[posy][c],poslca=tree[poslca][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    root[u]=<span class="built_in">newnode</span>();</span><br><span class="line">    <span class="built_in">inserts</span>(u,fa,a[u]);</span><br><span class="line">    parent[<span class="number">0</span>][u]=fa,depth[u]=d;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=G[u].<span class="built_in">begin</span>();it!=G[u].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*it!=fa)<span class="built_in">dfs</span>(*it,u,d+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k+<span class="number">1</span>&lt;MAX_LOGN;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=V;v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[k][v]&lt;<span class="number">0</span>)parent[k+<span class="number">1</span>][v]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> parent[k+<span class="number">1</span>][v]=parent[k][parent[k][v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth[u]&gt;depth[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;MAX_LOGN;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((depth[v]-depth[u])&gt;&gt;k&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            v=parent[k][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(u==v)<span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=MAX_LOGN<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[k][u]!=parent[k][v])&#123;</span><br><span class="line">            u=parent[k][u];</span><br><span class="line">            v=parent[k][v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[<span class="number">0</span>][u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,x,y,z;</span><br><span class="line">        root[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        tree[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>,tree[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>,value[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        nodecnt=<span class="number">1</span>,rootcnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v),G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(x,y,<span class="built_in">lca</span>(x,y),z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>可持久化字典树</category>
      </categories>
      <tags>
        <tag>可持久化字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 5536 Chip Factory</title>
    <url>/2018/01/26/HDU%20-%205536%20Chip%20Factory/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>字典树异或，题意是n个数选出3个使得(si+sj)^sk的值最大，我们对每个数构造01字典树，然后暴力枚举si,sj求和后直接在字典树上贪心。注意要在字典树上删除si和sj避免计算自己（可以使用lazy策略）。时间复杂度O(30*n^2)<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ((x&lt;&lt;1)|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p,nexts[<span class="number">100010</span>][<span class="number">2</span>],val[<span class="number">100010</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100010</span>;i++)nexts[i][<span class="number">0</span>]=nexts[i][<span class="number">1</span>]=<span class="number">-1</span>,val[i]=<span class="number">0</span>;p=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> ++p;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pos=<span class="number">30</span>;pos&gt;=<span class="number">0</span>;pos--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id=(x&amp;(<span class="number">1</span>&lt;&lt;pos))?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nexts[now][id]==<span class="number">-1</span>)nexts[now][id]=<span class="built_in">newnode</span>();</span><br><span class="line">            now=nexts[now][id];</span><br><span class="line">            val[now]+=ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> pos=<span class="number">30</span>;pos&gt;=<span class="number">0</span>;pos--)&#123;</span><br><span class="line">            <span class="keyword">int</span> id=(x&amp;(<span class="number">1</span>&lt;&lt;pos))?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(nexts[now][<span class="number">0</span>]==<span class="number">-1</span>||val[nexts[now][<span class="number">0</span>]]==<span class="number">0</span>)ans|=((id^<span class="number">1</span>)&lt;&lt;pos),now=nexts[now][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nexts[now][<span class="number">1</span>]==<span class="number">-1</span>||val[nexts[now][<span class="number">1</span>]]==<span class="number">0</span>)ans|=((id^<span class="number">0</span>)&lt;&lt;pos),now=nexts[now][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> ta1=ans|((id^<span class="number">1</span>)&lt;&lt;pos),ta2=ans|((id^<span class="number">0</span>)&lt;&lt;pos);</span><br><span class="line">                <span class="keyword">if</span>(ta1&gt;ta2)ans=ta1,now=nexts[now][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> ans=ta2,now=nexts[now][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;trie;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        trie.<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);</span><br><span class="line">            trie.<span class="built_in">change</span>(num[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxs=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            trie.<span class="built_in">change</span>(num[i],<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                trie.<span class="built_in">change</span>(num[j],<span class="number">-1</span>);</span><br><span class="line">                maxs=<span class="built_in">max</span>(maxs,trie.<span class="built_in">unite</span>(num[i]+num[j]));</span><br><span class="line">                trie.<span class="built_in">change</span>(num[j],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            trie.<span class="built_in">change</span>(num[i],<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxs);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>Trie</category>
      </categories>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 6185 Covering</title>
    <url>/2018/01/21/HDU%20-%206185%20Covering/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>类似插头dp的题，但数据范围到了10^18次。我们发现他的宽度只有4，若我们令a[n]为方案数，b[n]为不可分割的矩阵数，通过打表我们能发现a[1]=b[1]=1，b[2]=4，且n&gt;=3时有：<br>当n为奇数时：b[n]=2<br>当n为偶数时：b[n]=3<br>我的理解是更多分割的方案在之前已经有过计算，所以只有把原有的矩阵拉长的方案没有计算过，我们使用递推式计算就是要使用这一部分。<br>最后计算可得a[n]=a[n-1]+5a[n-2]+a[n-3]-a[n-4]，然后使用矩阵快速幂。<br><span id="more"></span></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://blog.csdn.net/u013480600/article/details/19644847">POJ3420 递推/状态压缩DP +矩阵幂加速处理</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) ((x&lt;&lt;1)|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Matrix class</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	ll num[MAXN][MAXN];</span><br><span class="line">	<span class="built_in">Mat</span>(<span class="keyword">int</span> n = MAXN, <span class="keyword">int</span> m = MAXN) :<span class="built_in">n</span>(n), <span class="built_in">m</span>(m) &#123; <span class="built_in">ms</span>(num, <span class="number">0</span>); &#125;;</span><br><span class="line">	Mat <span class="keyword">operator</span> +(<span class="keyword">const</span> Mat &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Mat <span class="title">ans</span><span class="params">(n, m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">				ans.num[i][j] = num[i][j] + b.num[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	Mat <span class="keyword">operator</span> -(<span class="keyword">const</span> Mat &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Mat <span class="title">ans</span><span class="params">(n, m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;j++) &#123;</span><br><span class="line">				ans.num[i][j] = num[i][j] - b.num[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	Mat <span class="keyword">operator</span> *(<span class="keyword">const</span> Mat &amp;b)<span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="function">Mat <span class="title">ans</span><span class="params">(n, b.m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;b.m;j++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;m;k++) &#123;</span><br><span class="line">					ans.num[i][j] = ((ans.num[i][j] + num[i][k] * b.num[k][j]) % MOD+MOD)%MOD;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Mat <span class="title">getI</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="function">Mat <span class="title">ans</span><span class="params">(x, x)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;x;i++)ans.num[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pow</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">		Mat I = <span class="built_in">getI</span>(<span class="number">4</span>);</span><br><span class="line">		ll cal = x;</span><br><span class="line">		<span class="keyword">while</span> (cal) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cal &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				I = I*(*<span class="keyword">this</span>);</span><br><span class="line">				cal--;</span><br><span class="line">			&#125;</span><br><span class="line">			(*<span class="keyword">this</span>) = (*<span class="keyword">this</span>)*(*<span class="keyword">this</span>);</span><br><span class="line">			cal /= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		(*<span class="keyword">this</span>) = I;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%I64d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        Mat A,B;</span><br><span class="line">        A.num[<span class="number">0</span>][<span class="number">0</span>]=(ll)<span class="number">1</span>,A.num[<span class="number">0</span>][<span class="number">1</span>]=(ll)<span class="number">5</span>,A.num[<span class="number">0</span>][<span class="number">2</span>]=(ll)<span class="number">1</span>,A.num[<span class="number">0</span>][<span class="number">3</span>]=(ll)(<span class="number">-1</span>),A.num[<span class="number">1</span>][<span class="number">0</span>]=(ll)<span class="number">1</span>,A.num[<span class="number">2</span>][<span class="number">1</span>]=(ll)<span class="number">1</span>,A.num[<span class="number">3</span>][<span class="number">2</span>]=(ll)<span class="number">1</span>;</span><br><span class="line">        B.num[<span class="number">0</span>][<span class="number">0</span>]=(ll)<span class="number">36</span>,B.num[<span class="number">1</span>][<span class="number">0</span>]=(ll)<span class="number">11</span>,B.num[<span class="number">2</span>][<span class="number">0</span>]=(ll)<span class="number">5</span>,B.num[<span class="number">3</span>][<span class="number">0</span>]=(ll)<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">4</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,B.num[<span class="number">4</span>-n][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A.<span class="built_in">pow</span>(n<span class="number">-4</span>);</span><br><span class="line">            Mat ans=A*B;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.num[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>矩阵快速幂</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-1711 Number Sequence</title>
    <url>/2017/10/13/HDU-1711%20Number%20Sequence/</url>
    <content><![CDATA[<p><em>思路</em><br>一道kmp的裸题，主要是学习kmp的使用方法。kmp的精髓在于使用了一个next数组。这个next数组的计算是放在预处理中的。next数组中记录的是不同长度下最长的前后缀的位置。举个例子：<br>字符串：a b c d a b d<br>next   0 0 0 0 1 2 0<br>你看到了什么？后边的两个a，b对应了开头的公共前缀的长度。那么这个next数组该怎么用？当你做字符串匹配的时候，如果发现当前位置字符与模板字符串不同，那么你可以把指向模板字符串的指针挪到之前公共长度（也就是next数组对应的地方）继续匹配，这样就避免了公共的前缀重复匹配浪费时间。<br>这里着重讲一下next数组怎么求。next数组的求法稍微有点绕，我放下我的代码<br>void makenext() {<br>int q, k;<br>nexts[0] = 0;<br>for (q = 1, k = 0;q &lt; m;q++) { while (k &gt; 0 &amp;&amp; b[q] != b[k])k = nexts[k - 1];<br>if (b[q] == b[k])k++;<br>nexts[q] = k;<br>}<br>}<br>代码中的while循环是非常绕的，他的意思是什么呢？在求前后缀的时候，因为b[q]!=b[k]，也就是前后缀有失配的地方，这个时候你之前算的一长串已经不能用了，所以你要回到之前求的短串再来尝试匹配。<br><span id="more"></span><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nexts[<span class="number">10000</span>], a[<span class="number">1000000</span>], b[<span class="number">10000</span>], n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makenext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q, k;</span><br><span class="line">    nexts[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (q = <span class="number">1</span>, k = <span class="number">0</span>;q &lt; m;q++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; b[q] != b[k])k = nexts[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (b[q] == b[k])k++;</span><br><span class="line">        nexts[q] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, q;</span><br><span class="line">    <span class="built_in">makenext</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, q = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; b[q] != a[i])q = nexts[q - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (b[q] == a[i])q++;</span><br><span class="line">        <span class="keyword">if</span> (q == m)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i-q+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)cin &gt;&gt; b[i];</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="built_in">kmp</span>();</span><br><span class="line">        <span class="keyword">if</span> (flag == n )cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; flag &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>kmp</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU – 2222 Keywords Search</title>
    <url>/2017/10/13/HDU%20%E2%80%93%202222%20Keywords%20Search/</url>
    <content><![CDATA[<p><em>思路：</em><br>AC自动机模板题。AC自动机是在一个字符串中查找多个特征串的算法。其中使用了一个next数组和Trie树，与kmp的next数组相类似。思想就是当指向的节点不匹配时，退回上一个匹配的节点，然后在其fail节点中继续查找这个串。（可以理解为两个特征串相同的前后缀然后直接跳转）构造fail指针的时候，需要查找其父节点的fail然后查其儿子节点。利用BFS完成。在扫描的时候，需要对已经扫过的节点标记为-1，避免重复计算。</p>
<span id="more"></span>
<p><em>代码：</em><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    node *next[<span class="number">26</span>];</span><br><span class="line">    node *fail;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="built_in">node</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        sum = <span class="number">0</span>;<span class="comment">//字符串末尾数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Build Trie-Tree</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node *root, string str)</span> </span>&#123;</span><br><span class="line">    node *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = str[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//id</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next[id] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node *q = <span class="keyword">new</span> node;</span><br><span class="line">            p-&gt;next[id] = q;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next[id];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Build fail pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildfail</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    node *p = root;</span><br><span class="line">    queue&lt;node*&gt; q;</span><br><span class="line">    root-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//对深度为2的节点fail初始化为root，不然会指向自己</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;next[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            root-&gt;next[i]-&gt;fail = root;</span><br><span class="line">            q.<span class="built_in">push</span>(root-&gt;next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node *t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;next[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(t-&gt;next[i]);</span><br><span class="line">                p = t-&gt;fail;</span><br><span class="line">                                <span class="comment">//为什么要有这个循环？因为没有的话只会查找一个fail节点，但实际上还有很多其它的fail节点的儿子没查</span></span><br><span class="line">                <span class="keyword">while</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;next[i]!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">                        t-&gt;next[i]-&gt;fail = p-&gt;next[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = p-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p==<span class="literal">NULL</span>)t-&gt;next[i]-&gt;fail = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AC-automation</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">acauto</span><span class="params">(node *root,string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    node *p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="comment">//先匹配一个</span></span><br><span class="line">        <span class="keyword">while</span> (!p-&gt;next[id] &amp;&amp; p != root)p = p-&gt;fail;</span><br><span class="line">        p = p-&gt;next[id];</span><br><span class="line">        <span class="keyword">if</span> (!p) p = root;</span><br><span class="line">        node *temp = p;</span><br><span class="line">                <span class="comment">//为了尝试匹配所有情况</span></span><br><span class="line">        <span class="keyword">while</span> (temp != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;sum &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                ans += temp-&gt;sum;</span><br><span class="line">                temp-&gt;sum = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            temp = temp-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freetree</span><span class="params">(node *root)</span> </span>&#123;</span><br><span class="line">    node *p = root;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next[i] != <span class="literal">NULL</span>)<span class="built_in">freetree</span>(p-&gt;next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T,n;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        string str;</span><br><span class="line">        node *root = <span class="keyword">new</span> node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="built_in">insert</span>(root, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">buildfail</span>(root);</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">acauto</span>(root,str) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">freetree</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>AC自动机</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU-2089 不要62</title>
    <url>/2017/10/13/HDU-2089%20%E4%B8%8D%E8%A6%8162/</url>
    <content><![CDATA[<p><em>思路：</em><br>数位dp的入门题，主要是为了对数位dp有一个初步的认识。我一开始认为数位dp是对左右区间进行dp，不过在看了几篇博客后认识到了应当对当前位以i为第一位的数作为状态来dp。递推式还是比较简单的。<br><span id="more"></span><br><em>代码：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1)+1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ms</span>(dp, <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">7</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; <span class="number">10</span>;k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">4</span> &amp;&amp; !(j == <span class="number">6</span> &amp;&amp; k == <span class="number">2</span>)) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = n,length=<span class="number">0</span>, digit[<span class="number">10</span>],ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        digit[++length] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    digit[length+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length ;i &gt; <span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; digit[i];j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">4</span> &amp;&amp; !(digit[i + <span class="number">1</span>] == <span class="number">6</span> &amp;&amp; j == <span class="number">2</span>))ans += dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digit[i] == <span class="number">4</span> || (digit[i] == <span class="number">2</span> &amp;&amp; digit[i + <span class="number">1</span>] == <span class="number">6</span>))<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;l&gt;&gt;r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l + r == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>(r + <span class="number">1</span>) - <span class="built_in">solve</span>(l) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>High Performance MySQL</title>
    <url>/2021/03/21/High-Performance-MySQL/</url>
    <content><![CDATA[<p>本文基于MySQL 8.0。高性能MySQL自用笔记。<br><span id="more"></span></p>
<h1 id="1-MySQL的架构和历史"><a href="#1-MySQL的架构和历史" class="headerlink" title="1. MySQL的架构和历史"></a>1. MySQL的架构和历史</h1><h2 id="1-1-MySQL逻辑架构"><a href="#1-1-MySQL逻辑架构" class="headerlink" title="1.1 MySQL逻辑架构"></a>1.1 MySQL逻辑架构</h2><p><img src="https://i.loli.net/2021/03/21/eFHvj1TaBrst7DC.png" alt=""></p>
<center>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">1-1:MySQL服务器逻辑架构图</div>
</center>

<p>第一层大部分基于网络的应用都有。包括了链接处理、授权认证、安全等。</p>
<p>第二层保存了MySQL的核心功能。查询解析、分析、优化、缓存以及所有的内置函数（日期、时间、数学、加密函数等），所有的跨储存引擎的功能：储存过程、触发器、视图等（因为不同储存引擎的实现不同）。</p>
<p>第三层是储存引擎。负责MySQL数据的存取。储存引擎会执行“开始一个事务”或“根据主键提取一行记录”的操作，但不会解析SQL（<strong>除了InnoDB，它会解析外键定义。因为MySQL的服务器并没有这个功能。</strong>）</p>
<h3 id="1-1-1-链接管理与安全性"><a href="#1-1-1-链接管理与安全性" class="headerlink" title="1.1.1 链接管理与安全性"></a>1.1.1 链接管理与安全性</h3><p>MySQL的每一个客户端链接都会有一个线程。创建和销毁线程都由服务器负责。在MySQL5.5以上的版本提供了线程池插件。</p>
<p>链接完成后，服务器会进行身份验证，同时检查该客户端是否有执行特定查询的权限。</p>
<h3 id="1-1-2-优化与执行"><a href="#1-1-2-优化与执行" class="headerlink" title="1.1.2 优化与执行"></a>1.1.2 优化与执行</h3><p>MySQL会解析查询，并创造内部数据结构（解析树）同时进行优化。包括重写查询、决定表的读取顺序，选择索引等。我们能够通过关键字提示（hint）优化器，影响它的决策过程，也可以请求优化器解释（explain）优化过程的各个因素，让用户知道服务器是如何进行优化决策的。</p>
<p><strong>优化器与储存引擎无关，但是储存引擎对优化查询有影响。</strong>因为优化器需要储存引擎提供容量或者某个具体操作的开销信息，以及表数据的统计信息等（如索引）。</p>
<p>对于SELECT语句，解析查询前，服务器会先检查查询缓存，如果找到了对应的查询，就不会再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</p>
<h2 id="1-2-并发控制"><a href="#1-2-并发控制" class="headerlink" title="1.2 并发控制"></a>1.2 并发控制</h2><p>本章只讨论并发读写。</p>
<h3 id="1-2-1-读写锁"><a href="#1-2-1-读写锁" class="headerlink" title="1.2.1 读写锁"></a>1.2.1 读写锁</h3><p>在处理并发读或者写时，可以通过实现一个由两个类型的锁组成的锁系统来解决问题。这两种锁为<strong>共享锁</strong>和<strong>排他锁</strong>。或者<strong>读锁</strong>和<strong>写锁</strong>。</p>
<p>读锁是共享的。多个线程可以同时读取一个资源。写锁是排他的，即写锁会阻塞其它的读锁和写锁。</p>
<h3 id="1-2-2-锁粒度"><a href="#1-2-2-锁粒度" class="headerlink" title="1.2.2 锁粒度"></a>1.2.2 锁粒度</h3><p>最理想的情况是，在保证不会出现冲突的情况下，我们仅仅锁定需要修改的数据，以保证高并发。</p>
<p>加锁，解锁，检查锁状态都会增加系统开销。如果系统花费了大量的时间在锁上，系统的性能可能就会收到影响。</p>
<p>MySQL的每个储存引擎都实现了自己的锁策略和锁粒度。也就是说<strong>储存引擎决定了大部分锁管理的方式</strong>（比如MyISAM只有表锁，而InnoDB实现了表锁和行级锁。同时要注意服务器会因为一些特殊目的使用一些表锁，见下文表锁章节）。这里是MySQL最重要的两种锁策略。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>MySQL最基本的锁策略，也是开销最小的策略（因为不像行级锁需要考虑哪些行受影响）。在特定的场景中，表锁也可以有良好的性能。例如READ LOCAL表锁支持某些类型的并发写操作。另外，写锁比读锁有更高的优先级。因此写锁请求可能会插入到读锁队列的前面。</p>
<p>虽然储存引擎可以管理自己的锁，但是MySQL还是会使用一些表锁来实现目的。比如服务器会对ALTER TABLE之类的语句使用表锁，而忽略储存引擎的锁机制。</p>
<h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p>行级锁可以最大程度支持并发处理，同时也带来了最大的锁开销（需要确认哪些行需要被锁定）。在InnoDB和XtraDB以及其它的一些储存引擎中实现了行级锁。<strong>行级锁只在储存引擎层实现</strong>。</p>
<h2 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h2><p>事务是一组原子性的SQL查询，包含了多条SQL语句。对于一个事务来说，所有的请求要么全部执行成功，要么全部执行失败（任何一句语句失败，都会导致语句回退来满足“全部成功，全部失败”的条件）。</p>
<p>为什么我们需要事务？考虑一个银行的例子。一个银行的数据库有两张表：支票表（checking）和储蓄表（savings）现在要从Jane的支票帐户转账200美元到她的储蓄账户。那么需要三个步骤：</p>
<ol>
<li>检查支票的长湖的余额是否高于200美元。</li>
<li>从支票帐户余额中减去200美元。</li>
<li>在储蓄帐户余额中增加200美元。</li>
</ol>
<p>上述步骤必须要么全部成功，要么全部失败。若第三步失败，那么我们必须回滚之前所有的操作。</p>
<p>我们可以用START TRANSACTION来开始一个事务，然后要么用COMMIT来提交事务修改的数据并且永久保存，要么用ROLLBACK回滚所有的修改。SQL样本如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> 	balance <span class="keyword">FROM</span> checking <span class="keyword">WHERE</span> customer_id<span class="operator">=</span><span class="number">10233276</span>;</span><br><span class="line">UPDATE checking <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">200.00</span> <span class="keyword">WHERE</span> customer_id<span class="operator">=</span><span class="number">10233276</span>;</span><br><span class="line">UPDATE savings <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span><span class="number">200.00</span> <span class="keyword">WHERE</span> customer_id <span class="operator">=</span> <span class="number">10233276</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们第三步增加储蓄帐户余额失败，那么Jane就平白无故少了200美金，这是不能接受的，所以需要回滚。</p>
<p>事务处理系统，应该满足ACID特征：</p>
<p><strong>原子性</strong>：一个事务应当是一个不可分割的最小工作单元，事务中的操作要么全部成功，要么全部失败。<br><strong>一致性</strong>：数据总是从一个一致性的状态转换到另一个一致性的状态。即便系统崩溃，前文中提到的支票账户也不会损失200元。因为事务没有最终提交，所以事务中所做的修改也不会保存到数据库中。<br><strong>隔离性</strong>：在事务最终提交前，该事务对其他事务是不可见的。注意，这里的隔离性不是完美的，在后面的隔离级别我们会提到。<br><strong>持久性</strong>：一旦事务提交，所做的修改就会永久保存到数据库中。</p>
<h3 id="1-3-1-隔离级别"><a href="#1-3-1-隔离级别" class="headerlink" title="1.3.1 隔离级别"></a>1.3.1 隔离级别</h3><p>在SQL标准中有四种隔离级别：</p>
<h4 id="1-Read-Uncommitted-未提交读"><a href="#1-Read-Uncommitted-未提交读" class="headerlink" title="1. Read Uncommitted(未提交读)"></a>1. Read Uncommitted(未提交读)</h4><p>在这个级别，即便事务中的修改没有提交，其他事务也能看到修改后的数据。事务能够读到未提交的数据，被称为(脏读)。理论上该隔离级别性能最好，但是考虑到脏读带来的问题，我们很少使用这种隔离级别。<br><br>实现：仅在更新数据时添加行级共享锁，直到事务结束。这样事务2就能读到事务1的修改，但是事务2无法修改事务1锁定的数据。</p>
<h4 id="2-Read-Committed-提交读"><a href="#2-Read-Committed-提交读" class="headerlink" title="2. Read Committed(提交读)"></a>2. Read Committed(提交读)</h4><p>大多数数据库的默认隔离级别是提交读（但MySQL不是）。提交读满足了隔离性的简单定义：一个事务开始时，只能“看见”已经提交的事务所做的更改。也就是说，在提交之前，所做的修改对于其他事务都是不可见的。这个级别有时被称为不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。<br>实现：对于读取的数据添加行级共享锁，读取完成后立刻释放。更新数据行添加行级排他锁，直到事务结束才释放。</p>
<h4 id="3-Repeatable-Read（可重复读）"><a href="#3-Repeatable-Read（可重复读）" class="headerlink" title="3. Repeatable Read（可重复读）"></a>3. Repeatable Read（可重复读）</h4><p>可重复度解决了脏读的问题，保证了在同一事物中多次读取同样的记录结果是一致的。但是没有办法解决幻读的问题。幻读指的是当某个事务在读取摸个范围内的记录时，另外一个事务又在该范围内插入新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。Innodb和XtraDB使用了多版本并发控制解决了幻读的问题。<br>实现：对于读取的数据添加行级共享锁，直到事务结束才释放。更新数据行添加行级排他锁，直到事务结束才释放。</p>
<h4 id="4-Serializable（可串行化）"><a href="#4-Serializable（可串行化）" class="headerlink" title="4. Serializable（可串行化）"></a>4. Serializable（可串行化）</h4><p>最高隔离级别，通过强制事务串行执行，避免了幻读的问题。但该隔离级别会导致大量的锁争用，并发也极差。<br>实现：事务在读取数据时，需要先添加表级共享锁。写数据时，需要添加表级排他锁。<br>| 隔离级别 | 脏读可能性 | 不可重复度可能性 | 幻读可能性 | 加锁读写 |<br>| :———: | :————: | :———————: | :————: | :———: |<br>| 未提交读 |    Yes     |       Yes        |    Yes     |    No    |<br>|  提交读  |     No     |       Yes        |    Yes     |    No    |<br>| 可重复读 |     No     |        No        |    Yes     |    No    |<br>| 可串行化 |     No     |        No        |     No     |   Yes    |</p>
<h3 id="1-3-2-死锁"><a href="#1-3-2-死锁" class="headerlink" title="1.3.2 死锁"></a>1.3.2 死锁</h3><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源。多个事务同时锁定同一个资源时，也会产生死锁。为了解决这个问题，数据库使用了死锁检测和死锁超时机制。如InnoDB系统能够检测到死锁的循环依赖，并立即返回一个错误。另外就是查询的时候，如果查询达到锁等待超时的设定后放弃锁请求。InnoDB目前解决死锁的办法是将拥有所少行级排它锁的事务进行回滚。锁的行为和顺序是和搜索引擎相关的。同样的顺序，有的搜索引擎会产生死锁，有些不会。所以死锁的产生有两种原因：有些是因为真的数据冲突，有的是因为搜索引擎的原因。</p>
<h3 id="1-3-3-事务日志"><a href="#1-3-3-事务日志" class="headerlink" title="1.3.3 事务日志"></a>1.3.3 事务日志</h3><p>类似oracle的重做日志文件。一般修改表的数据时，首先是修改内存中的表拷贝，然后是将修改记录记录硬盘上的事务日志中，而不用每次都将数据持久化到磁盘。因为事务日志采取的追加的方式，因此写日志的操作是磁盘上一小块区域的顺序IO。而不是随机IO.使用了事务日志后，内存的数据就可以慢慢刷入磁盘。因此修改数据需要写两次磁盘（写日志，写磁盘）。如果数据的修改已经记录到事务日志并持久化，但数据本身没有刷入磁盘，如果系统崩溃，储存引擎在重启时就能够自动回复这部分修改的数据。</p>
<h3 id="1-3-4-MySQL中的事务"><a href="#1-3-4-MySQL中的事务" class="headerlink" title="1.3.4 MySQL中的事务"></a>1.3.4 MySQL中的事务</h3><p>MySQL有两种提供支持事务的储存引擎：InnoDB和NDB Cluster.有一些第三方的储存引擎也支持事务，比较知名的包括XtraDB和PBXT。</p>
<h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p>MySQL默认使用自动提交模式。如果不显式地开启一个事务，那么每个查询都将被当作一个事务执行提交操作。通过修改AUTOCOMMIT变量来启用或者禁用自动提交模式。如果关闭autocommit,那么所有的查询都将在一个事务中直到你显示输入commit命令或者是rollback,该事务结束，同时开始一个新事务。<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;AUTOCOMMIT&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span> </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> autocommit    <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>(<span class="number">0.0</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> AUTOCOMMIT <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>注意，一部分sql命令执行前会强制执行commit来提交当前的活动事务。比如alter table,lock tables。注意，对于没有事务管理的储存引擎，可以视作autocommit一直开启的状态。</p>
<h4 id="在事务中使用混合储存引擎"><a href="#在事务中使用混合储存引擎" class="headerlink" title="在事务中使用混合储存引擎"></a>在事务中使用混合储存引擎</h4><p>因为事务是下层的储存引擎实现的，所以如果在一个事务中使用多种储存引擎就是不可靠的。如果我们需要回滚，那么非事务型的储存引擎就无法回滚。</p>
<h4 id="隐式和显式锁定"><a href="#隐式和显式锁定" class="headerlink" title="隐式和显式锁定"></a>隐式和显式锁定</h4><p>InnoDB采用的是两阶段锁定协议。在事务的执行过程中，随时都可以执行锁定，锁只有在执行commit或者rollback的时候才会释放，并且所有的锁在同一时刻释放。前面的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。<br>虽然MySQL有lock tables语句，但是lock tables和事务同时使用会产生无法预料的后果，所以不推荐。</p>
<h2 id="1-4-多版本并发控制"><a href="#1-4-多版本并发控制" class="headerlink" title="1.4 多版本并发控制"></a>1.4 多版本并发控制</h2><p>MVCC是行级锁的一个变种，在很多情况下避免了加锁操作，所以开销耕地。大部分实现了非阻塞的读操作，写操作也之锁定必要的行。<br><br>MVCC的实现是通过保存数据在某个时间点的快照来实现的。根据事务开始时间的不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。<br><br>InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列实现的。一个保存了行的创建版本，一个保存了行的过期版本（删除版本）。每次开始一个新的事务，系统版本号都会自动递增。</p>
<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>InnoDB会根据以下两个条件检查每行记录：</p>
<ol>
<li>InnoDB只查找版本早于当前事务版本的数据行，这样可以保证事务查询到的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>航的删除版本要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务开始之前未被删除。<br>只有两个条件都符合的行才会被返回。</li>
</ol>
<h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>InnoDB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识。</p>
<p>注意，MVCC仅在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。</p>
<h2 id="1-5-MySQL的储存引擎"><a href="#1-5-MySQL的储存引擎" class="headerlink" title="1.5 MySQL的储存引擎"></a>1.5 MySQL的储存引擎</h2><h3 id="1-5-1-InnoDB"><a href="#1-5-1-InnoDB" class="headerlink" title="1.5.1 InnoDB"></a>1.5.1 InnoDB</h3><p>支持事务，使用MVCC,使用间隙锁防止幻读，使用了聚簇索引，表的rows是估计值。<br>间隙锁：对一个范围的锁定，是前开后闭区间。比如表内有数据5,10。此时我们A事务第一次查询想看表内是否有7,结果是没有。此时B事务插入7。那么如果之后再查表内是否有7,那么就是没有了。所以为了解决这个问题，我们应当锁定(5,10]区间。这就是间隙锁。</p>
<h3 id="1-5-2-MyISAM"><a href="#1-5-2-MyISAM" class="headerlink" title="1.5.2 MyISAM"></a>1.5.2 MyISAM</h3><p>不支持事务和行级锁。rows是准确值。开销低</p>
<h3 id="1-5-3-Archive"><a href="#1-5-3-Archive" class="headerlink" title="1.5.3 Archive"></a>1.5.3 Archive</h3><p>只支持insert和select.插入时压缩数据，io更少。适合日志及高速插入。</p>
<h1 id="2-服务器性能剖析"><a href="#2-服务器性能剖析" class="headerlink" title="2. 服务器性能剖析"></a>2. 服务器性能剖析</h1><h2 id="2-1-剖析查询"><a href="#2-1-剖析查询" class="headerlink" title="2.1 剖析查询"></a>2.1 剖析查询</h2><h3 id="2-1-1-记录慢查询"><a href="#2-1-1-记录慢查询" class="headerlink" title="2.1.1 记录慢查询"></a>2.1.1 记录慢查询</h3><p>在my.ini开启慢查询日志：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqlld]</span><br><span class="line">//多久是慢查询，单位分钟，0代表记录所有查询</span><br><span class="line">long_query_time=2</span><br><span class="line"></span><br><span class="line">//5.0,5.1版本</span><br><span class="line">log-slow-queries=&#x27;mysql_slow_query.log&#x27;</span><br><span class="line">//5.5以上</span><br><span class="line">slow-query-log=On</span><br><span class="line">slow_query_log_file=&#x27;mysql_slow_query.log&#x27;</span><br><span class="line"></span><br><span class="line">//记录没有使用索引的查询</span><br><span class="line">log-query-not-using-indexes</span><br></pre></td></tr></table></figure><br>对于获得的慢查询，通过explain查看运行的信息。慢查询对IO的开销可以忽略不计。如果权限不足的话，可以尝试percona toolkit的<a href="https://www.percona.com/doc/percona-toolkit/2.2/installation.html">pt-query-digest</a>或者抓取TCP包。</p>
<h3 id="2-1-2剖析慢查询"><a href="#2-1-2剖析慢查询" class="headerlink" title="2.1.2剖析慢查询"></a>2.1.2剖析慢查询</h3><h4 id="使用show-profile"><a href="#使用show-profile" class="headerlink" title="使用show profile"></a>使用show profile</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>通过show profiles能看到记录的查询细节<br><img src="https://i.loli.net/2021/04/05/voiVX3N1ybr9RUE.png" alt="mysql_show_profiles.png"></p>
<p>精细查看：</p>
<p><img src="https://i.loli.net/2021/04/05/LTbOnH9IzfNrQZF.png" alt="mysql_show_profile_for_q1.png"></p>
<h4 id="使用show-status"><a href="#使用show-status" class="headerlink" title="使用show status"></a>使用show status</h4><p>show status可以查看操作的次数统计。注意一部分数据是会话级别的，一部分是全局级别的，需要在MySQL官方手册中查看具体的定义。</p>
<p><img src="https://i.loli.net/2021/04/05/dTx6U5gsfPtkDob.png" alt="mysql_show_status.png"></p>
<h2 id="2-2诊断间歇性问题"><a href="#2-2诊断间歇性问题" class="headerlink" title="2.2诊断间歇性问题"></a>2.2诊断间歇性问题</h2><h3 id="2-2-1-单条查询问题还是服务器问题"><a href="#2-2-1-单条查询问题还是服务器问题" class="headerlink" title="2.2.1 单条查询问题还是服务器问题"></a>2.2.1 单条查询问题还是服务器问题</h3><p>我们需要观察，是服务器上所有的程序都突然变慢，又突然都变好，每一条查询也都变慢了，那么慢查询就不一定是原因。反之，如果服务器整体没有问题，只有某条查询偶尔变慢，那么就应该注意是否是这条查询的问题。</p>
<h4 id="使用SHOW-GLOBAL-STATUS"><a href="#使用SHOW-GLOBAL-STATUS" class="headerlink" title="使用SHOW GLOBAL STATUS"></a>使用SHOW GLOBAL STATUS</h4><p>通过较高频率执行命令可以通过显示的Threads_running, Threads_connected, questions,queries的“尖刺“或者”凹陷“来发现。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysqladmin ext -i1 | awk <span class="string">&#x27;/Queries/&#123;q=$4-qp;qp=$4&#125; /Threads_connected/&#123;tc=$4&#125; /Threads_running/&#123;printf &quot;%5d %5d %5d\n&quot;, q, tc, $4&#125;&#x27;</span></span><br><span class="line">798 136 7</span><br><span class="line">767 134 9</span><br><span class="line">828 134 7</span><br><span class="line">683 134 7</span><br><span class="line">784 135 7</span><br><span class="line">614 134 7</span><br><span class="line">108 134 24</span><br><span class="line">187 134 31</span><br><span class="line">179 134 28</span><br><span class="line">1179 134 7</span><br><span class="line">1151 134 7</span><br><span class="line">1240 135 7</span><br><span class="line">1000 135 7</span><br></pre></td></tr></table></figure><br>可以看到Thread connected没有变化，但是正在查询的线程数明显上升。这可能是因为：1. 服务器内部有瓶颈，导致新查询在开始执行前因为要获取老查询正在等待的锁而造成堆积。这样的锁通常也会对应用服务器造成后端压力，使得应用服务器出现排队问题。2. 突然遭到了大量查询请求的冲击。</p>
<h4 id="使用show-processlist"><a href="#使用show-processlist" class="headerlink" title="使用show processlist"></a>使用show processlist</h4><p>通过不断捕获show processlist的输出，观察是否存在大量线程处于不正常的状态或者不正常的特征。比如查询很少会长时间处于“statistics”状态。。另外，很少见到大量线程报告当前链接用户是“未经验证的用户”。我们可以使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -e <span class="string">&#x27;SHOW PROCESSLIST\G&#x27;</span> | grep State: | sort |uniq -c | sort -rn</span><br></pre></td></tr></table></figure><br>来进行分析。</p>
<h3 id="3-4-2-捕获诊断数据"><a href="#3-4-2-捕获诊断数据" class="headerlink" title="3.4.2 捕获诊断数据"></a>3.4.2 捕获诊断数据</h3><h4 id="诊断触发器"><a href="#诊断触发器" class="headerlink" title="诊断触发器"></a>诊断触发器</h4><p>一个好的触发器应该避免误报和漏检。误报是指收集了很多数据但是都没有用，而漏检指出问题时没有采集到必要的数据。我们需要选择一个合适的数值，以便在开始是就捕获数据，更不能将阈值设定的太高。比如Threads_connected偶尔出现非常高的尖峰值，在几分钟从100冲向5000或更高。虽然将阈值设定为4900也能捕获到问题，但考虑到平时仅仅有10的并发，我们应该在150或200左右就开始捕获。</p>
<h4 id="我们要收集什么样的数据？"><a href="#我们要收集什么样的数据？" class="headerlink" title="我们要收集什么样的数据？"></a>我们要收集什么样的数据？</h4><p>系统的状态，cpu利用率，磁盘利用率，可用空间，ps输出采样，内存利用率，从mysql能够获取的信息如show status,show processlist和show innodb status。</p>
<h4 id="解释结果数据"><a href="#解释结果数据" class="headerlink" title="解释结果数据"></a>解释结果数据</h4><p>建议通过两个两个目的出发：1. 问题是否发生了？2. 是否有很明显的跳跃性的变化。为此有的时候应当抓取一些正常的数据作为对比。可能的问题有：性能低下的SQL查询，不适合的索引，设计糟糕的数据库逻辑架构等。通过抓取TCP流量或者show processlist输出，可以获得查询和事务出现的地方，从而知道用户对数据库进行了什么操作。通过服务器的内部行为则可以清楚服务器是否有bug,或者内部的性能和扩展性是否有问题。</p>
<h3 id="3-4-3-一个案例"><a href="#3-4-3-一个案例" class="headerlink" title="3.4.3 一个案例"></a>3.4.3 一个案例</h3><p>首先设置thread_connected的触发条件，正常情况下threads_connected的值不会超过15。，但在发生问题时可能飙升到几百。以下是样本的收集数据：</p>
<ul>
<li><p>查询活动从1000到10000的qps,其中很多是垃圾命令，如ping服务器是否存活。其余的大部分是select,每秒300～2000次。有很少的update（大约每秒5次）</p>
</li>
<li><p>检查processlist.txt</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep State: processlist.txt | sort | uniq -c | sort -rn</span><br><span class="line">161 State: Copying to tmp table</span><br><span class="line">156 State: Sorting result</span><br><span class="line">136 State: statistics</span><br><span class="line"> 50 State: Sending data</span><br><span class="line"> 24 State: NULL</span><br><span class="line"> 13 State:</span><br><span class="line">  7 State: freeing item</span><br><span class="line">  7 State: cleaning up</span><br><span class="line">  1 State: storing result <span class="keyword">in</span> query cache</span><br><span class="line">  1 State: end</span><br></pre></td></tr></table></figure>
<ul>
<li><p>大部分查询都是索引扫描或者范围扫描，很少有全表扫描或表关联的情况。</p>
</li>
<li><p>每秒大约有20-100次排序，需要排序的行大约有1000-2000行。</p>
</li>
<li><p>每秒大约创建12-90个临时表，其中有3-5个是磁盘临时表。</p>
</li>
<li><p>没有表所或者查询缓存的问题。</p>
</li>
<li><p>在show innodb status中可以观察到主要的线程状态是”flushing buffer pool pages”，但只有很少的脏页需要刷新。Innodb_buffer_pool_pages_flushed也没有太大的变化，日志顺序好和最后检查点之间的差距也很少。InnoDB缓存池也没有用满。缓存池比数据集还要大很多。大多数线程在等待InnoDB队列：“12 queries inside InnoDB, 495 queries in queue”。</p>
</li>
<li><p>每秒不会一次iostat输出，持续30秒。从输出可以发现没有磁盘读，而写操作接近了“天花板”，所以IO平均等待时间和队列长度都非常高。</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">r/s</th>
<th style="text-align:center">w/s</th>
<th style="text-align:center">rsec/s</th>
<th style="text-align:center">wsec/s</th>
<th style="text-align:center">avgqu-sz</th>
<th style="text-align:center">await</th>
<th style="text-align:center">svctm</th>
<th style="text-align:center">%util</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.00</td>
<td style="text-align:center">500.00</td>
<td style="text-align:center">8.00</td>
<td style="text-align:center">86216.00</td>
<td style="text-align:center">5.05</td>
<td style="text-align:center">11.95</td>
<td style="text-align:center">0.59</td>
<td style="text-align:center">29.40</td>
</tr>
<tr>
<td style="text-align:center">0.00</td>
<td style="text-align:center">451.00</td>
<td style="text-align:center">0.00</td>
<td style="text-align:center">206248.00</td>
<td style="text-align:center">123.25</td>
<td style="text-align:center">238.00</td>
<td style="text-align:center">1.90</td>
<td style="text-align:center">85.90</td>
</tr>
<tr>
<td style="text-align:center">0.00</td>
<td style="text-align:center">565.00</td>
<td style="text-align:center">0.00</td>
<td style="text-align:center">269792.00</td>
<td style="text-align:center">143.80</td>
<td style="text-align:center">245.00</td>
<td style="text-align:center">1.77</td>
<td style="text-align:center">100.00</td>
</tr>
<tr>
<td style="text-align:center">0.00</td>
<td style="text-align:center">649.00</td>
<td style="text-align:center">0.00</td>
<td style="text-align:center">309248.00</td>
<td style="text-align:center">143.01</td>
<td style="text-align:center">231.30</td>
<td style="text-align:center">1.54</td>
<td style="text-align:center">100.10</td>
</tr>
<tr>
<td style="text-align:center">0.00</td>
<td style="text-align:center">589.00</td>
<td style="text-align:center">0.00</td>
<td style="text-align:center">281784.00</td>
<td style="text-align:center">142.58</td>
<td style="text-align:center">232.15</td>
<td style="text-align:center">1.70</td>
<td style="text-align:center">100.10</td>
</tr>
<tr>
<td style="text-align:center">0.00</td>
<td style="text-align:center">384.00</td>
<td style="text-align:center">0.00</td>
<td style="text-align:center">162008.00</td>
<td style="text-align:center">71.80</td>
<td style="text-align:center">238.39</td>
<td style="text-align:center">1.73</td>
<td style="text-align:center">66.60</td>
</tr>
<tr>
<td style="text-align:center">0.00</td>
<td style="text-align:center">14.00</td>
<td style="text-align:center">0.00</td>
<td style="text-align:center">400.00</td>
<td style="text-align:center">0.01</td>
<td style="text-align:center">0.93</td>
<td style="text-align:center">0.36</td>
<td style="text-align:center">0.5</td>
</tr>
<tr>
<td style="text-align:center">0.00</td>
<td style="text-align:center">13.00</td>
<td style="text-align:center">0.00</td>
<td style="text-align:center">248.00</td>
<td style="text-align:center">0.01</td>
<td style="text-align:center">0.92</td>
<td style="text-align:center">0.23</td>
<td style="text-align:center">0.3</td>
</tr>
<tr>
<td style="text-align:center">0.00</td>
<td style="text-align:center">14.00</td>
<td style="text-align:center">0.00</td>
<td style="text-align:center">400.00</td>
<td style="text-align:center">0.01</td>
<td style="text-align:center">0.93</td>
<td style="text-align:center">0.36</td>
<td style="text-align:center">0.3</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>vmstat的输出也验证了iostat的结果，并且cpu的大部分时间是空闲的，只是偶尔在写尖峰的时候有一些IO等待时间（最高约9%的cpu）。</li>
</ul>
<p>在这里，值得注意的是是wsec/s中，服务器每秒写入了几百mb的数据到磁盘。但是在整体操作为select的情况下，为什么服务器一直在写入？注意到主要的线程状态是刷新页面。在这个版本的InnoDB中，存在这疯狂刷新的问题，因为InnoDB没有按时间均匀分布刷新请求，而是隔一段时间突然请求一次强制检查点导致大量刷新操作。但是我们发现Innodb_buffer_pool_pages_flushed并没有怎么增加，而且主要是select查询的话，不太可能有大量的写需求。我们注意到磁盘的IO已经饱和，为什么？要么是数据库导致了IO问题，要么不是。同时，iostat的结果表明了磁盘本身的相应是很快的，但是请求在块设备队列中等待了很长的时间才能够进入到磁盘设备。但注意，这也有可能是错误的信息。通过记录io来查看除了什么问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;/mysqld.*tmp/ &#123;</span></span><br><span class="line"><span class="string">        total+= $7;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      /^Sun Mar 28/ &amp;&amp; total &#123;</span></span><br><span class="line"><span class="string">          printf &quot;%s %7.2f MB\n&quot;, $4, total/1024/1024;</span></span><br><span class="line"><span class="string">          total = 0;</span></span><br><span class="line"><span class="string">      &#125;&#x27;</span> lsof.txt</span><br><span class="line">18:34:38 1655.21MB</span><br><span class="line">18:34:42 1.88MB</span><br><span class="line">18:34:48 1.88MB</span><br><span class="line">18:34:53 1.88MB</span><br><span class="line">18:34:58 1.88MB</span><br></pre></td></tr></table></figure>
<p>我们能够发现在问题初始mysql写了1.5gb的数据到临时表。这和show processlist中大量的copying to tmp table相吻合。这表明了某些效率低下的查询风暴耗尽了磁盘资源，而一种可能性就是缓存失效。当memcached中所有缓存的条目同时失效，而同时又有很多应用要同时访问时，就会出现这种情况。要解决这个问题，一方面在应用层面解决缓存失效的问题；另一方面修改了查询，避免使用临时表。</p>
<h1 id="4-schema与数据类型优化"><a href="#4-schema与数据类型优化" class="headerlink" title="4. schema与数据类型优化"></a>4. schema与数据类型优化</h1><h2 id="4-1-选择数据类型的原则"><a href="#4-1-选择数据类型的原则" class="headerlink" title="4.1 选择数据类型的原则"></a>4.1 选择数据类型的原则</h2><ul>
<li>更小的通常更好</li>
<li>简单的更好</li>
<li>尽量避免NULL</li>
</ul>
<h2 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h2><p>这些值的储存方式与储存引擎的实现密切相关。以下的描述基于InnoDB和MyISAM.<br><br><strong>VARCHAR</strong><br><br>varchar更节省空间，因为它仅使用必要的空间。除非该表使用ROW_FORMAT=FIXED创建。VARCHAR需要使用1到2个额外字节储存字符串的长度。如果最大长度小于等于255,那么就使用1个字节，否则就是2个字节。varchar解决了空间，也对性能有帮助。但是由于行是变长的，在update时有可能使行变得比原来更长。如果一个行占用的空间增长，同时页内没有更多的空间可以储存，这时不同的储存引擎的处理是不一样的。MyISAM会把行拆成不同的片段储存。InnoDB需要分裂页来使行可以放进页内。一般地说，推荐在这些情况使用varchar：</p>
<ol>
<li>字符串列的最大长度比平均长度大很多</li>
<li>列的更新很少，所以碎片不是问题。</li>
<li>使用了像utf-8这样的字符集，每个字符都是用不同的字节数进行储存</li>
</ol>
<p>在5.0或更高版本，mysql在储存和检索时会保留末尾空格，但是4.1或更老的版本，会剔除末尾空格。InnoDB还会把过长的varchar储存为BLOB。<br><br><strong>CHAR</strong><br><br>储存char时，mysql总是会删除所有的末尾空格。CHAR适合储存定长的字符串，比如密码的md5值。同时对于经常变更的数据，char也更好，因为不容易产生碎片。<br><br><strong>VARCHAR(5)和VARCHAR(200)</strong><br><br>当我们储存“hi“时，这两个数据项的开销是一样的，那么我们应该使用更短的列吗？事实是确实如此。更长的列会消耗更多的内存。mysql通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或操作时会特别糟糕。使用磁盘临时表进行排序时也同样糟糕。<br><br><strong>BLOB和TEXT类型</strong><br><br>与其他类型不同，MySQL会把每个BLOB和TEXT当作独立的对象处理。当BLOB和TEXT太大时，InnoDB会使用专门的“外部“储存区域来进行储存，此时每个值在行内需要1-4个字节储存一个指针，然后在外部储存区域储存实际的值。mysql不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。因为memory引擎不支持BLOB和TEXT类型，所以如果查询使用了BLOB或TEXT的列，那么将不得不使用MyISAM磁盘临时表。所以最佳的解决方案是不使用BLOB和TEXT.另一个比较巧妙的解决方法是使用substring(column, length)将列值转换为字符串，这样就可以使用内存临时表了。但是要保证截取的字符串足够短，不然mysql会把内存临时表转换成磁盘临时表。<br></p>
<h2 id="4-3-日期和时间类型"><a href="#4-3-日期和时间类型" class="headerlink" title="4.3 日期和时间类型"></a>4.3 日期和时间类型</h2><h3 id="DATATIME"><a href="#DATATIME" class="headerlink" title="DATATIME"></a>DATATIME</h3><p>能保存从1001年到9999年，精度为秒。使用8个字节展示。</p>
<h3 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h3><p>能保存从1970年1月1日午夜以来的秒数值，只使用4个字节的储存空间，能保存从1970到2038的年份。提供了FROM_UNIXTIME()转换为日期UNIX_TIMESTAMP()从日期转换为时间戳。使用TIMESTAMP代表这个时间依赖系统的时区。同时，在插入时如果没有制定第一个timestamp的值，那么默认为当前时间。</p>
]]></content>
      <categories>
        <category>工程</category>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 1776 Car Fleet II</title>
    <url>/2022/07/01/Leetcode%20-%201776%20Car%20Fleet%20II/</url>
    <content><![CDATA[<p>In the discussion of this problem, most people said we can use monostack to solve it. However, they didn’t tell us why. Here I want to give an explanation with more details.<br><span id="more"></span></p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p><img src="https://s2.loli.net/2022/07/02/2dS8PFYOIfC7V6s.jpg" alt="leetcode1776-1.jpeg"><br><img src="https://s2.loli.net/2022/07/02/Od6nIFR9fT2jyY4.jpg" alt="leetcode1776-2.jpeg"></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// [1,2], [2,1], [4,3], [7,2]</span></span><br><span class="line">    <span class="comment">// 2nd&amp;3rd car collide, then first car </span></span><br><span class="line">    <span class="comment">// brute force O(n^2)</span></span><br><span class="line">    <span class="comment">// [7, 2], </span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">getCollisionTimes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; cars)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// k-1 times in stack</span></span><br><span class="line">        stack&lt;<span class="keyword">double</span>&gt; intersectionTime;</span><br><span class="line">        <span class="comment">// k cars in stack</span></span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; carsInStack;</span><br><span class="line">        <span class="keyword">int</span> n = cars.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!intersectionTime.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">int</span> indexOfTopCar = carsInStack.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">// [1,5], [3, 10] 2/10-5</span></span><br><span class="line">                <span class="keyword">if</span>(cars[indexOfTopCar][<span class="number">1</span>]==cars[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    carsInStack.<span class="built_in">pop</span>();</span><br><span class="line">                    intersectionTime.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">double</span> collideTime = ((<span class="keyword">double</span>)cars[indexOfTopCar][<span class="number">0</span>]-cars[i][<span class="number">0</span>])/(cars[i][<span class="number">1</span>]-cars[indexOfTopCar][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(collideTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    carsInStack.<span class="built_in">pop</span>();</span><br><span class="line">                    intersectionTime.<span class="built_in">pop</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(collideTime&gt;intersectionTime.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                        carsInStack.<span class="built_in">pop</span>();</span><br><span class="line">                        intersectionTime.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        carsInStack.<span class="built_in">push</span>(i);</span><br><span class="line">                        intersectionTime.<span class="built_in">push</span>(collideTime);</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(collideTime);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(intersectionTime.<span class="built_in">empty</span>()&amp;&amp;carsInStack.<span class="built_in">size</span>()==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> indexOfTopCar = carsInStack.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(cars[indexOfTopCar][<span class="number">1</span>]==cars[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    carsInStack.<span class="built_in">pop</span>();</span><br><span class="line">                    carsInStack.<span class="built_in">push</span>(i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="number">-1.0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3/1</span></span><br><span class="line">                    <span class="keyword">double</span> collideTime = ((<span class="keyword">double</span>)cars[indexOfTopCar][<span class="number">0</span>]-cars[i][<span class="number">0</span>])/(cars[i][<span class="number">1</span>]-cars[indexOfTopCar][<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(collideTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        carsInStack.<span class="built_in">pop</span>();</span><br><span class="line">                        carsInStack.<span class="built_in">push</span>(i);</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(<span class="number">-1.0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        intersectionTime.<span class="built_in">push</span>(collideTime);</span><br><span class="line">                        carsInStack.<span class="built_in">push</span>(i);</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(collideTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(intersectionTime.<span class="built_in">empty</span>()&amp;&amp;carsInStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                carsInStack.<span class="built_in">push</span>(i);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="number">-1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>凸包</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 2262 Total Appeal of A String.md</title>
    <url>/2022/06/16/Leetcode%20-%202262%20Total%20Appeal%20of%20A%20String/</url>
    <content><![CDATA[<p>A very interesting dp problem.</p>
<span id="more"></span>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>At first, I thought I should record the position of each character into 26 arrays. When we traverse from 0 to n, we can find that the appeal of a substring starts from index i, can be divided into at most 26 parts(As we only have 26 letters). As a result, we can find what letter we haven’t met and using Binary search to find the next nearest letter that we haven’t met. The time complexity is O(nlogn). I got TLE with this solution.</p>
<p>Another Way to solve this problem is DP. Let’s define DP[i] as the total appeal of all substrings end at index i. Then, DP[i] is made up of two parts:</p>
<ol>
<li>We append letter[i] to all the substrings ends at index i-1. <strong>Here we suppose we don’t add a new distinct letter.</strong> We will calculate the contribution of adding new distinct letter in the second part. Here we just take letter[i] as a letter we already have at index i-1. The contribution of this part is DP[i-1].</li>
<li>Here we consider the situation that letter[i] is a new distinct letter. In order to make it a new distinct letter, we need to find the last position that letter[i] appears, call it position j. The contribution of letter[i] as a new distinct letter is i-j;</li>
</ol>
<p>When we add them up, then we can get the answer.</p>
<h1 id="Inspiration"><a href="#Inspiration" class="headerlink" title="Inspiration"></a>Inspiration</h1><p>When handling counting problem, a state meets demands and ends at i is helpful and should be considered as a solution.</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="TLE-Code"><a href="#TLE-Code" class="headerlink" title="TLE Code"></a>TLE Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">appealSum</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; pos[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            pos[s[i]-<span class="string">&#x27;a&#x27;</span>].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            pos[i].<span class="built_in">push_back</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            unordered_set&lt;<span class="keyword">int</span>&gt; dict;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n) &#123;</span><br><span class="line">                dict.<span class="built_in">insert</span>(s[j]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                <span class="keyword">int</span> mins = n;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">26</span>;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dict.<span class="built_in">find</span>(k)==dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        <span class="keyword">int</span> index = <span class="built_in">lower_bound</span>(pos[k].<span class="built_in">begin</span>(), pos[k].<span class="built_in">end</span>(), j)-pos[k].<span class="built_in">begin</span>();</span><br><span class="line">                        mins = <span class="built_in">min</span>(mins, pos[k][index]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans+=(mins-j)*dict.<span class="built_in">size</span>();</span><br><span class="line">                j = mins;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">appealSum</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> prev[<span class="number">26</span>], ans = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            prev[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">            cur += (i-prev[s[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            prev[s[i]-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">            ans+=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 99 Recover Binary Search Tree</title>
    <url>/2021/11/16/Leetcode%20-%2099%20Recover%20Binary%20Search%20Tree/</url>
    <content><![CDATA[<p>在Leetcode中碰到了从未在ACM中见过的Morris遍历，简单记录一下。</p>
<span id="more"></span>
<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>题意是一棵二叉搜索树中，有两个节点顺序错了，需要我们进行还原。解决这道题的核心关键就在于，我们需要知道对于一棵二叉搜索树来说，<strong>它的中序遍历是有序的</strong>。那么我们就能将题目转换为，在一个数组中，将两个次序错误的元素还原。以下面的数组为例：</p>
<blockquote>
<p>1 6 3 4 5 2 7</p>
</blockquote>
<p>错误序列具有的特征是，对于6来说，6&gt;3了。对于2来说，5&gt;2了。所以我们会在序列中找到两个前一个大于后一个的颠倒元素。此时我们取第一次的第一个元素和第二次的后一个元素即可。对于基本的题目，这题只要递归中序遍历即可。但是Leetcode要求空间复杂度为O(1)，意味着递归是不符合要求的（递归是O(n)空间，考虑递归的栈有多深）。这里就引出了Morris遍历。</p>
<h2 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h2><p>令当前遍历的节点为cur</p>
<ol>
<li>如果cur无左孩子，cur向右移动</li>
<li>如果cur有左孩子，找出cur <strong>子树</strong>上最右的节点，记为mostRight<ol>
<li>如果mostRight的右节点指向空，令其指向cur，cur向左节点移动</li>
<li>如果mostRight的右节点指向cur，令其为null，cur向右移动</li>
</ol>
</li>
</ol>
<p>我们对一棵树完整走一遍Morris遍历来加深印象。</p>
<p><img src="https://i.loli.net/2021/11/16/YsyecVnoDId7iJv.png" alt="Morris-1.png"></p>
<p>我们从4节点开始遍历树。4有左儿子，mostRight为3。3右儿子指向null, 我们令其右儿子指向cur(4)，cur向左儿子移动变成2。</p>
<p><img src="https://i.loli.net/2021/11/16/T9tm8QUL3AszSRC.png" alt="Morris-2.png"></p>
<p>2节点有左儿子，mostRight为1。1的右节点指向null，我们令其右儿子指向cur(2)，cur向左儿子移动变成1.</p>
<p><img src="https://i.loli.net/2021/11/16/V7NBvgQjOC1YZIG.png" alt="Morris-3.png"></p>
<p>3没有左儿子，向右移动到2.</p>
<p><img src="https://i.loli.net/2021/11/16/9fDigWuUa3JGhvl.png" alt="Morris-4.png"></p>
<p>我们又回到了2节点。2有左儿子，此时mostRight为1。注意到1的右儿子正指向cur(2)，所以令1的右儿子为NULL同时cur走向右儿子(3)。</p>
<p><img src="https://i.loli.net/2021/11/16/vmrFURGD5ca1txw.png" alt="Morris-5.png"></p>
<p>3没有左儿子，向右移动到4。</p>
<p><img src="https://i.loli.net/2021/11/16/QmH2bRkdPO8hnjf.png" alt="Morris-6.png"></p>
<p>此时cur为4，4有左儿子，mostRight为3。注意到3的右儿子指向cur，所以令3的右儿子为null。向右移动到5。这样整棵树就完成了遍历。只要将之前的解题思路和Morris遍历结合在一起，就完成了题目的要求。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        TreeNode *pre = <span class="literal">NULL</span>, *first = <span class="literal">NULL</span>, *second = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                TreeNode *mostRight = cur -&gt; left;</span><br><span class="line">                <span class="keyword">while</span> (mostRight -&gt; right != <span class="literal">NULL</span> &amp;&amp; mostRight -&gt; right != cur) &#123;</span><br><span class="line">                    mostRight = mostRight -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mostRight -&gt; right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    mostRight -&gt; right = cur;</span><br><span class="line">                    cur = cur -&gt; left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostRight -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt; cur -&gt;val)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!first)first = pre;</span><br><span class="line">                        second = cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = cur;</span><br><span class="line">                    cur = cur -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt; cur -&gt;val)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!first)first = pre;</span><br><span class="line">                    second = cur;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(first-&gt;val, second-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/101321696">神级遍历——morris</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>Morris遍历</category>
      </categories>
      <tags>
        <tag>Morris遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Head first Red Black Tree</title>
    <url>/2021/07/01/Head%20first%20Red%20Black%20Tree/</url>
    <content><![CDATA[<p>Red-Black Tree is a special kind of binary search tree. Each of its node is either black or red. Besides, the Red-Black tree has the following features:</p>
<ul>
<li>Each of its nodes is either black or red.</li>
<li>The root node is black.</li>
<li>Every leaf node is black. (In the Red-Black tree, the leaf node is a NIL node).</li>
<li>If a node is red, its child must be black.</li>
<li>From any node to its descendant leaf node must have the same number of black nodes. </li>
</ul>
<p>The reason why we use the Red-Black tree that it’s height is always log(n), which guarantees the time complexity of its operation. The proof of Red-Black Tree’s time complexity can be found <a href="https://www.cnblogs.com/skywang12345/p/3245399.html">here</a>. </p>
<span id="more"></span>
<h1 id="An-Implementation-of-the-Red-Black-tree-in-C"><a href="#An-Implementation-of-the-Red-Black-tree-in-C" class="headerlink" title="An Implementation of the Red-Black tree in C++"></a>An Implementation of the Red-Black tree in C++</h1><p>To help understand the Red-Black tree better, implementing the Red-Black tree is a good way.</p>
<h2 id="The-node-of-the-Red-Black-tree"><a href="#The-node-of-the-Red-Black-tree" class="headerlink" title="The node of the Red-Black tree"></a>The node of the Red-Black tree</h2><h3 id="The-structure-of-the-node"><a href="#The-structure-of-the-node" class="headerlink" title="The structure of the node"></a>The structure of the node</h3><p>First, we should consider the structure of the RB tree’s node. According to the features of the Red-Black tree, the node of  Red-Black tree should contain the value, color, pointers of its child and parent. So we can get code like this:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The color of RB Tree&#x27;s node. I use enum type here to make code much easier to read.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RBTNodeColor</span>&#123;</span></span><br><span class="line">    RED,</span><br><span class="line">    BLACK</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// The relation between the node and its sons.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RBTRelation</span>&#123;</span></span><br><span class="line">    LEFT,</span><br><span class="line">    RIGHT,</span><br><span class="line">    ERROR</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use generics to make it easy to use.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line">    RBTNodeColor color;<span class="comment">//RED or BLACK</span></span><br><span class="line">    RBTNode&lt;T&gt; *child[<span class="number">2</span>], *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="The-operation-of-the-node"><a href="#The-operation-of-the-node" class="headerlink" title="The operation of the node"></a>The operation of the node</h3><p>As a good programmer we should use getter and setter.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RBTNode</span>(T value, RBTNodeColor color = BLACK, RBTNode&lt;T&gt; *left = <span class="literal">NULL</span>, RBTNode&lt;T&gt; *right = <span class="literal">NULL</span>, RBTNode&lt;T&gt; *parent = <span class="literal">NULL</span>) : <span class="built_in">value</span>(value), <span class="built_in">color</span>(color), <span class="built_in">parent</span>(parent)&#123;</span><br><span class="line">        child[<span class="number">0</span>] = left, child[<span class="number">1</span>] = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Use getSon(LEFT) or getSon(RIGHT) to access the sons.</span></span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">getSon</span><span class="params">(RBTRelation relation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;child[relation];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSon</span><span class="params">(RBTNode&lt;T&gt; *node, RBTRelation relation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;child[relation] = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">getParent</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(RBTNode&lt;T&gt; *parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTNodeColor <span class="title">getRBTNodeColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRBTNodeColor</span><span class="params">(RBTNodeColor color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTRelation <span class="title">getRelation</span><span class="params">(RBTNode *parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;<span class="built_in">getSon</span>(LEFT) == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> LEFT;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">getSon</span>(RIGHT) == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> RIGHT;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Good! Now the structure of RB tree is done. We can move to the next step.</p>
<h2 id="RB-Tree"><a href="#RB-Tree" class="headerlink" title="RB Tree"></a>RB Tree</h2><p>To make the code look much tidier, I use a class to symbolize the RB tree.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBTNode&lt;T&gt; *root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Keep in mind that we should always record the root of the tree(For all the binary search tree), or nobody will know which node we should begin with while searching. </p>
<h3 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h3><p>Rotate is the basic operation of the binary search tree. I’ve read many books that tend to use “Left Rotate” and “Right Rotate”. In my opinion, this makes things too complex. Before looking at the following picture, I hope you know that Enum in C++ can be present as Integer. For example the RBTRelation I’ve defined before means LEFT = 0, RIGHT = 1, ERROR = 2. In the following picture, I will use Integers to present the relationship between parent and sons.(The ? means we don’t make any changes to this node. Actually, we don’t do anything to the sibling as well.).</p>
<p><img src="https://i.loli.net/2021/06/22/dGXA48Cs2cyHUhn.png" alt="RBTree-Left-Rotate.png"></p>
<p><img src="https://i.loli.net/2021/06/22/6BUOLIxCZvDbRHf.png" alt="RBTree-Right-Rotate.png"></p>
<p>Left Rotate and Right Rotate is just like a mirror, right? What’s more, the edges between parent and sibling, son and ? never change. The edges between parent and son, son and grandson seem have a pattern. Let’s make it clear:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Left Rotate</th>
<th>Right Rotate</th>
</tr>
</thead>
<tbody>
<tr>
<td>The relation between parent and son is <strong>RIGHT(1)</strong>.</td>
<td>The relation between parent and son is <strong>LEFT(0)</strong>.</td>
</tr>
<tr>
<td>parent[<strong>RIGHT(1)</strong>] = son[<strong>LEFT(0)</strong>]</td>
<td>parent[<strong>LEFT(0)</strong>] = son[<strong>RIGHT(1)</strong>]</td>
</tr>
<tr>
<td>Gson-&gt;parent = parent</td>
<td>Gson-&gt;parent = parent</td>
</tr>
<tr>
<td>son-&gt;parent = grandparent</td>
<td>son-&gt;parent = grandparent</td>
</tr>
<tr>
<td>if(grandparent==NULL)root = son</td>
<td>if(grandparent==NULL)root = son</td>
</tr>
<tr>
<td>else {relation = parent-&gt;getRelation(grandparent)</td>
<td>else {relation = parent-&gt;getRelation(grandparent)</td>
</tr>
<tr>
<td>grandparent-&gt;son[relation] = son}</td>
<td>grandparent-&gt;son[relation] = son}</td>
</tr>
<tr>
<td>son-&gt;son[<strong>LEFT(0)</strong>] = parent</td>
<td>son-&gt;son[<strong>RIGHT(1)</strong>] = parent</td>
</tr>
<tr>
<td>parent-&gt;parent = son</td>
<td>parent-&gt;parent = son</td>
</tr>
</tbody>
</table>
</div>
<p>Almost the same, right? Even though the relationship maybe a bit different, you can correspond relationship easily. Then we can merge left rotate and right rotate into one function.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Rotate</th>
</tr>
</thead>
<tbody>
<tr>
<td>The relation between parent and son is <strong>Relationship</strong>(0,1). Define <strong>Reverse Relationship</strong> as Relationship^1</td>
</tr>
<tr>
<td>parent[<strong>Relationship</strong>] = son[<strong>Reverse Relationship</strong>]</td>
</tr>
<tr>
<td>Gson-&gt;parent = parent</td>
</tr>
<tr>
<td>son-&gt;parent = grandparent</td>
</tr>
<tr>
<td>if(grandparent==NULL)root = son</td>
</tr>
<tr>
<td>else {relation = parent-&gt;getRelation(grandparent)</td>
</tr>
<tr>
<td>grandparent-&gt;son[relation] = son}</td>
</tr>
<tr>
<td>son-&gt;son[<strong>Reverse Relationship</strong>] = parent</td>
</tr>
<tr>
<td>parent-&gt;parent = son</td>
</tr>
</tbody>
</table>
</div>
<p>Now we can integrate left rotate and right rotate into one function-rotate! Writing two same function is a waste of life.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(RBTNode&lt;T&gt; *&amp;root, RBTNode&lt;T&gt; *node, RBTNode&lt;T&gt; *son)</span></span>&#123;</span><br><span class="line">    <span class="comment">/* Initialization:</span></span><br><span class="line"><span class="comment">     *             parent</span></span><br><span class="line"><span class="comment">     *              / (ATTENTION: Maybe left son or right son.)</span></span><br><span class="line"><span class="comment">     *            node</span></span><br><span class="line"><span class="comment">     *           /    \</span></span><br><span class="line"><span class="comment">     *      leftSon    son</span></span><br><span class="line"><span class="comment">     *                /   \</span></span><br><span class="line"><span class="comment">     *            grandSon  ?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RBTNode&lt;T&gt; *parent = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">    RBTRelation relation = son-&gt;<span class="built_in">getRelation</span>(node);</span><br><span class="line">    RBTRelation oppRelation = <span class="keyword">static_cast</span>&lt;RBTRelation&gt;(<span class="number">1</span> - relation);</span><br><span class="line">    RBTNode&lt;T&gt; *grandSon = son-&gt;<span class="built_in">getSon</span>(oppRelation);</span><br><span class="line">    node-&gt;<span class="built_in">setSon</span>(grandSon, relation);</span><br><span class="line">    <span class="keyword">if</span> (grandSon != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        grandSon-&gt;<span class="built_in">setParent</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* After the steps before, grandSon is settled.</span></span><br><span class="line"><span class="comment">     *              parent</span></span><br><span class="line"><span class="comment">     *             /</span></span><br><span class="line"><span class="comment">     *           node   &lt;=parent  son</span></span><br><span class="line"><span class="comment">     *           /  \             /     \</span></span><br><span class="line"><span class="comment">     *      leftSon  grandSon        ?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    son-&gt;<span class="built_in">setParent</span>(parent);</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        root = son;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        RBTRelation rRelation = node-&gt;<span class="built_in">getRelation</span>(parent);</span><br><span class="line">        <span class="keyword">if</span> (rRelation == ERROR)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ERROR: These two nodes are not parent and son.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent-&gt;<span class="built_in">setSon</span>(son, rRelation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *                  parent</span></span><br><span class="line"><span class="comment">     *                  /</span></span><br><span class="line"><span class="comment">     *             son</span></span><br><span class="line"><span class="comment">     *              /    \</span></span><br><span class="line"><span class="comment">     *           node     ?</span></span><br><span class="line"><span class="comment">     *           /  \ </span></span><br><span class="line"><span class="comment">     *      leftSon  grandSon</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    son-&gt;<span class="built_in">setSon</span>(node, oppRelation);</span><br><span class="line">    node-&gt;<span class="built_in">setParent</span>(son);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now we finish the function of ‘rotate’. At the end part of rotate, I’d like to talk about why we need rotate. Many books just tell us to remember rotate and it’s useful, but why? The reason that rotate is useful is first, after rotate, tree is still a VALID binary search tree. The relationships between each nodes are still correct. It’s impossible that after rotate a node’s left son’s value is larger than this node. This is useful while we want to balance a tree and we can adjust the height of tree without worrying about destroy the Binary search tree. Second, rotate enables us to move one node from one subtree to another, lift the current node and put down the parent node. This is useful to RB tree and some other special binary search tree like splay. In the part ‘insert’, you will see how we use rotate to move extra black nodes from one subtree to another.</p>
<h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><p>Insert is a basic operation for all the binary search trees. The only difference is that RB tree need a re-balance after the insert operation. The process of insert is like this:</p>
<ol>
<li>Get the value of Node V.</li>
<li>From the root of the tree,  compare the V and the current node’s value(Begin with root). If V is smaller than the current node’s value, go to the left son of the current node. If V is bigger than the current node’s value, go to the right son of the current node. You should record current node as PARENT because we need it afterwards. Then set current node as the left son(right son). Here we suppose there is no duplicated value in an RB tree. If you want your RB tree contain duplicated value, you can add a property to the node class like “cnt” to count the times of the value. We will stop the loop when the current node is NULL.</li>
<li>Set the parent of node v as PARENT. </li>
<li>If PARENT is not NULL, compare the value of PARENT and the value of node. If the value of node is less than the value of PARENT, set the PARENT’s left son as node, else set the PARENT’s  right son as node. </li>
<li>If PARENT is NULL, set the root as PARENT.</li>
<li>Set the node as RED.</li>
<li>Re-balance the RB Tree. </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Insert new node</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(RBTNode&lt;T&gt; *&amp;root, RBTNode&lt;T&gt; *node)</span></span>&#123;</span><br><span class="line">    RBTNode&lt;T&gt; *parent = <span class="literal">NULL</span>;</span><br><span class="line">    RBTNode&lt;T&gt; *cur = root;</span><br><span class="line">    <span class="comment">// Here we want to find the node where we want to insert.</span></span><br><span class="line">    <span class="keyword">while</span> (cur)&#123;</span><br><span class="line">        parent = cur;</span><br><span class="line">        <span class="comment">// Left child&#x27;s value is less than the parent node, right child&#x27;s value is larger than the parent node.</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;<span class="built_in">getValue</span>() &lt; cur-&gt;<span class="built_in">getValue</span>())</span><br><span class="line">            cur = cur-&gt;<span class="built_in">getSon</span>(LEFT);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;<span class="built_in">getSon</span>(RIGHT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Here we know the position to insert and also know the parent of the node.</span></span><br><span class="line">    node-&gt;<span class="built_in">setParent</span>(parent);</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;<span class="built_in">getValue</span>() &lt; parent-&gt;<span class="built_in">getValue</span>())&#123;</span><br><span class="line">            parent-&gt;<span class="built_in">setSon</span>(node, LEFT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent-&gt;<span class="built_in">setSon</span>(node, RIGHT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don&#x27;t forget the condition that the RBtree is NULL.</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        root = node;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">    <span class="built_in">insertRebalance</span>(root, node);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Why we choose to set the node as RED? It’s because this will break as fewer rules of the RB tree as possible. Let’s consider the rules of RB tree:</p>
<ul>
<li>Each of its node is either black or red. (YES, we set the new node as RED)</li>
<li>The root node is black.(If at the beginning the tree is empty, we may break this rule).</li>
<li>Every leaf node is black. (In RB tree, the leaf node is a NIL node). (YES, although the node we insert is RED, we set two leaf nodes as BLACK by default).</li>
<li>If a node is red, its child node must be black.(NO, the node we insert is red, and its parent maybe red as well).</li>
<li>From any node to its descendant leaf node must have the same number of black nodes.  (YES, the node we insert is red, which won’t affect the number of black nodes. Be careful that actually we substitute a black node with the red node, that’s why the number of black nodes won’t change).</li>
</ul>
<p>So, we should do two things in the re-balance. First, we should set the root node as black. Second, we should solve the problem that the parent node and child node can’t be both red. To solve this problem, we have to discuss different situations. Here is the first situation.</p>
<p>(1)  Parent is red, uncle is red as well.</p>
<p><img src="https://i.loli.net/2021/06/24/LTPAKGR7JqMwDQX.png" alt="RBTree-insert-rebalance1.png"></p>
<p>Under this situation, the first thing we can do is to change parent to Black. Good! Now we won’t break rule 4. However, this may break rule 5. The black nodes on GParent-Parent-Node plus 1, and is no longer equal to the number of black nodes on GParent-Uncle, not to mention the other part of tree. The only thing we can do is to change uncle to black, and then change GParent to Red. Now at least the sub-tree obeys the rules of RB tree. But there is still possible that GParent’s parent is red. So we need to take GParent as Node and repeat.</p>
<p>P.S. GParent must be black because the RB tree before we insert is valid. So it’s impossible that parent is red and GParent is red as well.</p>
<p>(2)Parent is Red, Uncle is Black. The relationship between GParent and Parent, Parent and Node is same. </p>
<p><img src="https://i.loli.net/2021/06/24/nrmYzwAZdc19yH6.png" alt="RBTree-insert-rebalance2.png"></p>
<p>First we still change parent to black, then change GParent to red like what we did before. The RB tree seemed balance right? But actually GParent-Uncle used to have 2 black nodes, and they have only one now. We break the rule 5! The only thing we can do is to rotate parent and GParent to re-arrange the relationship of the subtree. </p>
<p>Does the re-balance over? No.</p>
<p>(3)Parent is Red, Uncle is Black. The relationship between GParent and Parent, Parent and Node is different. </p>
<p><img src="https://i.loli.net/2021/06/24/aeuvXC4MoAlRNjQ.png" alt="RBTree-insert-rebalance3.png"></p>
<p>Oh! Nothing changes! It is because we make Node the GParent’s son right? So the solution is to make the node that we will rotate Black. Be careful that we can’t change the Node black. Do you remember why we set Node red before. What shall we do? Let look back at situation (2). We are lazy, and how about change situation (3) to (2)? Ya, rotate parent and node right?</p>
<p><img src="https://i.loli.net/2021/06/24/k1EKLdy42CgzBwl.png" alt="RBTree-insert-rebalance4.png"></p>
<p>Now we can solve situation (3) like situation (2)! Remember that the parent and node’s relationship is a bit different, if you use pointers to point at node and parent, you may use swap(parent, node) to ‘repair’ the pointers.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertRebalance</span><span class="params">(RBTNode&lt;T&gt; *&amp;root, RBTNode&lt;T&gt; *node)</span></span>&#123;</span><br><span class="line">    RBTNode&lt;T&gt; *parent, *grandParent;</span><br><span class="line">    <span class="comment">// Check whether node has parent, and whether the parent is RED.</span></span><br><span class="line">    <span class="comment">// If the parent is black, we don&#x27;t need to change anything. </span></span><br><span class="line">    <span class="keyword">while</span> ((parent = node-&gt;<span class="built_in">getParent</span>()) &amp;&amp; parent-&gt;<span class="built_in">getRBTNodeColor</span>() == RED)&#123;</span><br><span class="line">        grandParent = parent-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        RBTNode&lt;T&gt; *uncle = grandParent-&gt;<span class="built_in">getSon</span>(<span class="keyword">static_cast</span>&lt;RBTRelation&gt;(<span class="number">1</span> - parent-&gt;<span class="built_in">getRelation</span>(grandParent)));</span><br><span class="line">        <span class="comment">// Parent is red and uncle is red, which is situation 1. </span></span><br><span class="line">        <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;<span class="built_in">getRBTNodeColor</span>() == RED)&#123;</span><br><span class="line">            uncle-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">            parent-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">            grandParent-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">            node = grandParent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// uncle maybe NULL, but keep in mind that NULL is a black node.</span></span><br><span class="line">        <span class="comment">// This branch is responsible for situation 2 and 3.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (uncle == <span class="literal">NULL</span> || uncle-&gt;<span class="built_in">getRBTNodeColor</span>() == BLACK)&#123;	</span><br><span class="line">            RBTRelation gPRelation = parent-&gt;<span class="built_in">getRelation</span>(grandParent);</span><br><span class="line">            RBTRelation pSRelation = node-&gt;<span class="built_in">getRelation</span>(parent);</span><br><span class="line">            <span class="comment">// Situation 3, and we will adjust it to situation 2.</span></span><br><span class="line">            <span class="keyword">if</span> (gPRelation != pSRelation)&#123;</span><br><span class="line">                <span class="built_in">rotate</span>(root, parent, node);</span><br><span class="line">                <span class="comment">// Remember to wap parent and node!</span></span><br><span class="line">                <span class="built_in">swap</span>(parent, node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Situation 2.</span></span><br><span class="line">            parent-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">            grandParent-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">            <span class="built_in">rotate</span>(root, grandParent, parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set root as black.</span></span><br><span class="line">    root-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><p>Search is a very basic operation of binary search Tree. As binary search tree has such a property that left sons’ value are smaller than the current node, the right sons’ values are larger than the current node, we can search from the root and compare the value and the current node’s value. If the value is smaller than the current node’s value, go to the left son. Else we go to the right son.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">RBTNode&lt;T&gt; *<span class="title">searchByValue</span><span class="params">(RBTNode&lt;T&gt; *cur, T val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur || cur-&gt;<span class="built_in">getValue</span>() == val)&#123;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val &lt; cur-&gt;<span class="built_in">getValue</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchByValue</span>(cur-&gt;<span class="built_in">getSon</span>(LEFT), val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchByValue</span>(cur-&gt;<span class="built_in">getSon</span>(RIGHT), val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FindMin-FindMax"><a href="#FindMin-FindMax" class="headerlink" title="FindMin, FindMax"></a>FindMin, FindMax</h3><p>For a subtree, we should be able to find the minimum and maximum element of it. It’s very easy because we just need to search the tree along the left/right node we will find the min/max value of the subtree.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Find the node with minimum value.</span></span><br><span class="line"><span class="function">RBTNode&lt;T&gt; *<span class="title">findMin</span><span class="params">(RBTNode&lt;T&gt; *node)</span></span>&#123;</span><br><span class="line">    RBTNode&lt;T&gt; *cur = node;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;<span class="built_in">getSon</span>(LEFT) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur = cur-&gt;<span class="built_in">getSon</span>(LEFT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Find the node with maximum value.</span></span><br><span class="line"><span class="function">RBTNode&lt;T&gt; *<span class="title">findMax</span><span class="params">(RBTNode&lt;T&gt; *node)</span></span>&#123;</span><br><span class="line">    RBTNode&lt;T&gt; *cur = node;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;<span class="built_in">getSon</span>(RIGHT) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        cur = cur-&gt;<span class="built_in">getSon</span>(RIGHT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Successor-Predecessor"><a href="#Successor-Predecessor" class="headerlink" title="Successor, Predecessor"></a>Successor, Predecessor</h3><p>The successor is the smallest node whose value is larger than the current node. The predecessor is the largest node whose value is smaller than the current node. Here I will explain how to get the successor, and you can get predecessor in almost the same way. If a node has right son node, then the minimum node in the right son’s subtree is the successor. If the node doesn’t have right son, we need to check the node’s parent. If the node is the left son of the parent, then the parent is the successor. If the node is the right son of the parent, we need to find the parent of the parent, until we find a node is the left son of its parent. Then the parent is the successor.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">RBTNode&lt;T&gt; *<span class="title">successor</span><span class="params">(RBTNode&lt;T&gt; *node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;<span class="built_in">getSon</span>(RIGHT) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMin</span>(node-&gt;<span class="built_in">getSon</span>(RIGHT));</span><br><span class="line">    &#125;</span><br><span class="line">    RBTNode&lt;T&gt; *nxt = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">    RBTNode&lt;T&gt; *cur = node;</span><br><span class="line">    <span class="keyword">while</span> ((nxt != <span class="literal">NULL</span>) &amp;&amp; (cur == nxt-&gt;<span class="built_in">getSon</span>(LEFT)))&#123;</span><br><span class="line">        cur = nxt;</span><br><span class="line">        nxt = nxt-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">RBTNode&lt;T&gt; *<span class="title">predecessor</span><span class="params">(RBTNode&lt;T&gt; *node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;<span class="built_in">getSon</span>(LEFT) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMax</span>(node-&gt;<span class="built_in">getSon</span>(LEFT));</span><br><span class="line">    &#125;</span><br><span class="line">    RBTNode&lt;T&gt; *nxt = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">    RBTNode&lt;T&gt; *cur = node;</span><br><span class="line">    <span class="keyword">while</span> ((nxt != <span class="literal">NULL</span>) &amp;&amp; (cur == nxt-&gt;<span class="built_in">getSon</span>(RIGHT)))&#123;</span><br><span class="line">        cur = nxt;</span><br><span class="line">        nxt = nxt-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>The delete operation is very similar to the delete operation in Binary search tree. We should first find out the node with the value we want to delete, then we should consider the following situation:</p>
<ol>
<li>The node to be deleted is a leaf node. (We can delete it without extra operation).</li>
<li>The node to be deleted has only one son. (We can replace the node with its son, keep in mind that we won’t change the color).</li>
<li>The node to be deleted has two sons. (We need to find out the successor of the node, then replace the node with its successor. Finally we can delete the successor. The successor must have no or only one child as it’s the successor of current node. So it fall into situation 1 or 2).</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeByVal</span><span class="params">(RBTNode&lt;T&gt; *&amp;root, RBTNode&lt;T&gt; *node)</span></span>&#123;</span><br><span class="line">    <span class="comment">// If node&#x27;s left and right are both not NULL.</span></span><br><span class="line">    <span class="keyword">if</span> ((node-&gt;getSon[LEFT] != <span class="literal">NULL</span>) &amp;&amp; (node-&gt;getSon[RIGHT] != <span class="literal">NULL</span>))&#123;</span><br><span class="line">        <span class="comment">// Get the successor first</span></span><br><span class="line">        <span class="comment">// The successor is very special here. As we already know node has both left and right sons, the successor must be in the right son&#x27;s subtree.</span></span><br><span class="line">        RBTNode&lt;T&gt; *replace = <span class="built_in">successor</span>(node);</span><br><span class="line">        RBTNode&lt;T&gt; *parent = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        <span class="comment">// Replace the node with the successor.</span></span><br><span class="line">        <span class="keyword">if</span> (parent)&#123;</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;<span class="built_in">getSon</span>(LEFT) == node)&#123;</span><br><span class="line">                parent-&gt;<span class="built_in">setSon</span>(LEFT) = replace;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                parent-&gt;<span class="built_in">setSon</span>(RIGHT) = replace;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure to consider the situation of root.</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root = replace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// replace is a successor node. Under the premise we mentioned before, it must only has a right son.</span></span><br><span class="line">        RBTNode&lt;T&gt; *succChild = replace-&gt;<span class="built_in">getSon</span>(RIGHT);</span><br><span class="line">        RBTNode&lt;T&gt; *succParent = replace-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        RBTNodeColor color = replace-&gt;<span class="built_in">getRBTNodeColor</span>();</span><br><span class="line">        <span class="keyword">if</span> (succParent == node)&#123;</span><br><span class="line">            succParent == replace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (succChild)</span><br><span class="line">                succChild-&gt;setParent = succParent;</span><br><span class="line">            succParent-&gt;<span class="built_in">setSon</span>(LEFT) = succChild;</span><br><span class="line">            replace-&gt;<span class="built_in">setSon</span>(RIGHT) = node-&gt;<span class="built_in">getSon</span>(RIGHT);</span><br><span class="line">            node-&gt;<span class="built_in">getSon</span>(RIGHT)-&gt;<span class="built_in">setParent</span>(replace);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Put replace into the position of node.</span></span><br><span class="line">        replace-&gt;<span class="built_in">setParent</span>(node-&gt;<span class="built_in">getParent</span>());</span><br><span class="line">        replace-&gt;<span class="built_in">setRBTNodeColor</span>(node-&gt;<span class="built_in">getRBTNodeColor</span>());</span><br><span class="line">        replace-&gt;<span class="built_in">setSon</span>(LEFT) = node-&gt;<span class="built_in">getSon</span>(LEFT);</span><br><span class="line">        node-&gt;<span class="built_in">getSon</span>(LEFT)-&gt;<span class="built_in">setParent</span>(replace);</span><br><span class="line">        <span class="keyword">if</span> (color == BLACK)&#123;</span><br><span class="line">            <span class="built_in">removeRebalance</span>(succChild, succParent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RBTNode&lt;T&gt; *child, *parent;</span><br><span class="line">    RBTNodeColor color;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;<span class="built_in">getSon</span>(LEFT) != <span class="literal">NULL</span>)</span><br><span class="line">        child = node-&gt;<span class="built_in">getSon</span>(LEFT);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        child = node-&gt;<span class="built_in">getSon</span>(RIGHT);</span><br><span class="line">    parent = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">    color = node-&gt;<span class="built_in">getRBTNodeColor</span>();</span><br><span class="line">    <span class="keyword">if</span> (child)&#123;</span><br><span class="line">        child-&gt;<span class="built_in">setParent</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent)&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;<span class="built_in">getSon</span>(LEFT) == node)&#123;</span><br><span class="line">            parent-&gt;<span class="built_in">setSon</span>(LEFT) = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent-&gt;<span class="built_in">setSon</span>(RIGHT) = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        root = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (color == BLACK)&#123;</span><br><span class="line">        <span class="built_in">removeRebalance</span>(child, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>After delete, of course, we need to re-balance the tree. Fortunately, as we delete the successor node, we can make sure that this is a leaf node, which means we don’t need to both re-balance the tree from the node to the root and from the node to the leaf. Great! Now let see we have broken which rules of RB tree:</p>
<ol>
<li>Each of its nodes is either black or red. (YES)</li>
<li>The root node is black. (NO, do you remember that we need to replace the root with the successor node?)</li>
<li>Every leaf node is black. (In the Red-Black tree, the leaf node is a NIL node).(YES)</li>
<li>If a node is red, its child node must be black. (NO, if there is one son, the parent maybe red and the son is red as well).</li>
<li>From any node to its descendant leaf node must have the same number of black nodes. (NO, the same reason as rule 2)</li>
</ol>
<p>Now we know the conflict we need to solve is 2, 4, 5. </p>
<p>For rule 2, we can simply set the root as black to solve it. </p>
<p>For rule 4, the only question is that for the node we want to delete, its parent and its only son may be both red. OK, after replace the node with its only son, just set it black. (Node is black, so we won’t break rule 5 as well!) </p>
<p>So, only question is 5 and only if the node has two sons! Now the question become how to re-balance the successor. If the successor is red, perfect! Delete it won’t break the rule 5. If the successor is black, we need to “add” a black node to the path from the root to the successor node. We can’t insert a node so the only way is to rotate.</p>
<h4 id="1-Successor-is-Black-Sibling-is-Black-Sibling’s-right-son-is-Red"><a href="#1-Successor-is-Black-Sibling-is-Black-Sibling’s-right-son-is-Red" class="headerlink" title="(1) Successor is Black, Sibling is Black, Sibling’s right son is Red"></a>(1) Successor is Black, Sibling is Black, Sibling’s right son is Red</h4><p><img src="https://i.loli.net/2021/06/30/T1DEtHJNeduVsMF.png" alt="RBTree-delete-rebalance1.png"></p>
<p>For such condition, left rotate can make the black nodes on the path from root to successor plus 1. Be careful that it’s possible that P is red and SL is red as well. So we need to set P as Black, but this may cause the number of black nodes change. So the best solution is to swap the color of P and S. Now we need to check rules 5 after the left rotate:</p>
<p>I. The black nodes on the path from root to successor remain the same.</p>
<p>Yes, the S node helps us solve the problem. Now we can delete the successor.</p>
<p>II. The black nodes on the path from root to SL remain the same.</p>
<p>As we swap the color of S and P, so this won’t be a problem. </p>
<p>III. The black nodes on the path from the root to SR remain the same.</p>
<p>As the left node minus 1, we need to change SR into Black.</p>
<p>Now I think you know why we emphasize that SR must be red. When we change a red node into black, we will only break rule 5, and by chance we need to add a black node on this path! As a result, the procedure is:</p>
<ol>
<li><p>Swap the color of parent and sibling.</p>
</li>
<li><p>Set the right son of sibling as black.</p>
</li>
<li><p>Rotate(parent, sibling).</p>
</li>
<li><p>The tree is balanced!</p>
</li>
</ol>
<h4 id="2-Successor-is-Black-Sibling-is-Black-Sibling’s-left-son-is-Red-Sibling’s-right-son-is-Black"><a href="#2-Successor-is-Black-Sibling-is-Black-Sibling’s-left-son-is-Red-Sibling’s-right-son-is-Black" class="headerlink" title="(2) Successor is Black, Sibling is Black, Sibling’s left son is Red, Sibling’s right son is Black."></a>(2) Successor is Black, Sibling is Black, Sibling’s left son is Red, Sibling’s right son is Black.</h4><p><img src="https://i.loli.net/2021/06/30/lisTtoB7Ve2SPxH.png" alt="RBTree-delete-rebalance2.png"></p>
<p>This situation is very similar to (1). A right rotate on(S, SR) , then set SL as black, S as red can change (2) to (1). </p>
<ol>
<li>Set SL as Black.</li>
<li>Set S as Red.</li>
<li>Rotate(S, SR).</li>
<li>Reset sibling of succ.</li>
</ol>
<h4 id="3-Successor-is-Black-Sibling-is-Black-both-of-Sibling’s-sons-are-Black"><a href="#3-Successor-is-Black-Sibling-is-Black-both-of-Sibling’s-sons-are-Black" class="headerlink" title="(3) Successor is Black, Sibling is Black, both of Sibling’s sons are Black."></a>(3) Successor is Black, Sibling is Black, both of Sibling’s sons are Black.</h4><p><img src="https://i.loli.net/2021/06/30/JIXPar5LxScsQ6i.png" alt="RBTree-delete-rebalance3.png"></p>
<p>Here the only thing we can do is to set S as red. Why? We all know that we need to add a black node to the path of successor, but we can do nothing here. So we will solve the problem at the parent. But keep in mind that if we do so, the path from the root to S will have an extra black node! As a result, we need to set S as red.</p>
<h4 id="4-Successor-is-Black-Sibling-is-Red"><a href="#4-Successor-is-Black-Sibling-is-Red" class="headerlink" title="(4) Successor is Black, Sibling is Red"></a>(4) Successor is Black, Sibling is Red</h4><p><img src="https://i.loli.net/2021/07/01/p5DAXYMevbGUSnq.png" alt="RBTree-delete-rebalance4.png"></p>
<p>In situation 1,2 and 3, the sibling node is always black. If we find the sibling node is red, we need to change it into 1,2 and 3. We just need to set sibling as black, set parent as red and rotate(parent, sibling).</p>
<p>OK! Now the re-balance of delete is done! Here is the code.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeRebalance</span><span class="params">(RBTNode&lt;T&gt; *node, RBTNode&lt;T&gt; *parent)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;removeRebalance starts\n&quot;</span>);</span><br><span class="line">    RBTNode&lt;T&gt; *sibling;</span><br><span class="line">    <span class="keyword">while</span> ((!node || node-&gt;<span class="built_in">getRBTNodeColor</span>()) == BLACK &amp;&amp; node != root)&#123;</span><br><span class="line">        RBTRelation relation = node-&gt;<span class="built_in">getRelation</span>(parent);</span><br><span class="line">        RBTRelation oppRelation = <span class="keyword">static_cast</span>&lt;RBTRelation&gt;(<span class="number">1</span> - relation);</span><br><span class="line">        sibling = parent-&gt;<span class="built_in">getSon</span>(oppRelation);</span><br><span class="line">        <span class="comment">// Case.4 If sibling is red</span></span><br><span class="line">        <span class="keyword">if</span> (sibling-&gt;<span class="built_in">getRBTNodeColor</span>() == RED)&#123;</span><br><span class="line">            sibling-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">            parent-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">            <span class="built_in">rotate</span>(root, parent, sibling);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Case.3 If sibling is black, the two sons of sibling is black as well.</span></span><br><span class="line">        <span class="keyword">if</span> ((!sibling-&gt;<span class="built_in">getSon</span>(LEFT) || sibling-&gt;<span class="built_in">getSon</span>(LEFT)-&gt;<span class="built_in">getRBTNodeColor</span>() == BLACK) &amp;&amp;</span><br><span class="line">            (!sibling-&gt;<span class="built_in">getSon</span>(RIGHT) || sibling-&gt;<span class="built_in">getSon</span>(RIGHT)-&gt;<span class="built_in">getRBTNodeColor</span>() == BLACK))&#123;</span><br><span class="line">            sibling-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">            node = parent;</span><br><span class="line">            parent = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!sibling-&gt;<span class="built_in">getSon</span>(oppRelation) || sibling-&gt;<span class="built_in">getSon</span>(oppRelation)-&gt;<span class="built_in">getRBTNodeColor</span>() == BLACK)&#123;</span><br><span class="line">                sibling-&gt;<span class="built_in">getSon</span>(relation)-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                sibling-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">                <span class="built_in">rotate</span>(root, sibling, sibling-&gt;<span class="built_in">getSon</span>(relation));</span><br><span class="line">                sibling = parent-&gt;<span class="built_in">getSon</span>(oppRelation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sibling-&gt;<span class="built_in">setRBTNodeColor</span>(parent-&gt;<span class="built_in">getRBTNodeColor</span>());</span><br><span class="line">                parent-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                sibling-&gt;<span class="built_in">getSon</span>(oppRelation)-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                <span class="built_in">rotate</span>(root, parent, sibling);</span><br><span class="line">                node = root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node)</span><br><span class="line">        node-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;removeRebalance ends\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK! Now the RB tree is done. Enjoy it.</p>
<h1 id="Full-Version-of-Code-in-C"><a href="#Full-Version-of-Code-in-C" class="headerlink" title="Full Version of Code in C++"></a>Full Version of Code in C++</h1><p>Annotation may be a bit different from the code before.<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEBUG = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RBTNodeColor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    RED,</span><br><span class="line">    BLACK</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RBTRelation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LEFT,</span><br><span class="line">    RIGHT,</span><br><span class="line">    ERROR</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class T should override the operator &lt;,&gt;,==</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line">    RBTNodeColor color;</span><br><span class="line">    RBTNode&lt;T&gt; *child[<span class="number">2</span>], *parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RBTNode</span>(T value, RBTNodeColor color = BLACK, RBTNode&lt;T&gt; *left = <span class="literal">NULL</span>, RBTNode&lt;T&gt; *right = <span class="literal">NULL</span>, RBTNode&lt;T&gt; *parent = <span class="literal">NULL</span>) : <span class="built_in">value</span>(value), <span class="built_in">color</span>(color), <span class="built_in">parent</span>(parent)</span><br><span class="line">    &#123;</span><br><span class="line">        child[<span class="number">0</span>] = left, child[<span class="number">1</span>] = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">getSon</span><span class="params">(RBTRelation relation)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;child[relation];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setSon</span><span class="params">(RBTNode&lt;T&gt; *node, RBTRelation relation)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;child[relation] = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">getParent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(RBTNode&lt;T&gt; *parent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTNodeColor <span class="title">getRBTNodeColor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRBTNodeColor</span><span class="params">(RBTNodeColor color)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTRelation <span class="title">getRelation</span><span class="params">(RBTNode *parent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;<span class="built_in">getSon</span>(LEFT) == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> LEFT;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (parent-&gt;<span class="built_in">getSon</span>(RIGHT) == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> RIGHT;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This RBTree doesn&#x27;t allow duplicated elements.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RBTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RBTNode&lt;T&gt; *root;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(RBTNode&lt;T&gt; *&amp;root, RBTNode&lt;T&gt; *node, RBTNode&lt;T&gt; *son)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Rotate Start\n&quot;</span>);</span><br><span class="line">        <span class="comment">/* Initialization:</span></span><br><span class="line"><span class="comment">         *             parent</span></span><br><span class="line"><span class="comment">         *              / (ATTENTION: Maybe left son or right son.)</span></span><br><span class="line"><span class="comment">         *            node</span></span><br><span class="line"><span class="comment">         *           /    \</span></span><br><span class="line"><span class="comment">         *      leftSon    son</span></span><br><span class="line"><span class="comment">         *                /   \</span></span><br><span class="line"><span class="comment">         *            grandSon  ?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RBTNode&lt;T&gt; *parent = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        RBTRelation relation = son-&gt;<span class="built_in">getRelation</span>(node);</span><br><span class="line">        RBTRelation oppRelation = <span class="keyword">static_cast</span>&lt;RBTRelation&gt;(<span class="number">1</span> - relation);</span><br><span class="line">        RBTNode&lt;T&gt; *grandSon = son-&gt;<span class="built_in">getSon</span>(oppRelation);</span><br><span class="line">        node-&gt;<span class="built_in">setSon</span>(grandSon, relation);</span><br><span class="line">        <span class="keyword">if</span> (grandSon != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            grandSon-&gt;<span class="built_in">setParent</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* After the steps before, grandSon is settled.</span></span><br><span class="line"><span class="comment">         *              parent</span></span><br><span class="line"><span class="comment">         *             /</span></span><br><span class="line"><span class="comment">         *           node   &lt;=parent  son</span></span><br><span class="line"><span class="comment">         *           /  \             /     \</span></span><br><span class="line"><span class="comment">         *      leftSon  grandSon        ?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        son-&gt;<span class="built_in">setParent</span>(parent);</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = son;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            RBTRelation rRelation = node-&gt;<span class="built_in">getRelation</span>(parent);</span><br><span class="line">            <span class="keyword">if</span> (rRelation == ERROR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ERROR: These two nodes are not parent and son.\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                parent-&gt;<span class="built_in">setSon</span>(son, rRelation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *                  parent</span></span><br><span class="line"><span class="comment">         *                  /</span></span><br><span class="line"><span class="comment">         *             son</span></span><br><span class="line"><span class="comment">         *              /    \</span></span><br><span class="line"><span class="comment">         *           node     ?</span></span><br><span class="line"><span class="comment">         *           /  \ </span></span><br><span class="line"><span class="comment">         *      leftSon  grandSon</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        son-&gt;<span class="built_in">setSon</span>(node, oppRelation);</span><br><span class="line">        node-&gt;<span class="built_in">setParent</span>(son);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Rotate end\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Insert new node</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(RBTNode&lt;T&gt; *&amp;root, RBTNode&lt;T&gt; *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Insert starts\n&quot;</span>);</span><br><span class="line">        RBTNode&lt;T&gt; *parent = <span class="literal">NULL</span>;</span><br><span class="line">        RBTNode&lt;T&gt; *cur = root;</span><br><span class="line">        <span class="comment">// Here we want to find the node where we want to insert.</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            <span class="comment">// Left child&#x27;s value is less than the parent node, right child&#x27;s value is larger than the parent node.</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;<span class="built_in">getValue</span>() &lt; cur-&gt;<span class="built_in">getValue</span>())</span><br><span class="line">                cur = cur-&gt;<span class="built_in">getSon</span>(LEFT);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur-&gt;<span class="built_in">getSon</span>(RIGHT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Here we know the position to insert and also know the parent of the node.</span></span><br><span class="line">        node-&gt;<span class="built_in">setParent</span>(parent);</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;<span class="built_in">getValue</span>() &lt; parent-&gt;<span class="built_in">getValue</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                parent-&gt;<span class="built_in">setSon</span>(node, LEFT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                parent-&gt;<span class="built_in">setSon</span>(node, RIGHT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don&#x27;t forget the condition that the RBtree is NULL.</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* When we are inserting a new node, we should always set it RED.</span></span><br><span class="line"><span class="comment">         * Considering the rules of RBTree:</span></span><br><span class="line"><span class="comment">         * 1. Each of its node is either black or red.(√. We won&#x27;t break it)</span></span><br><span class="line"><span class="comment">         * 2. The root node is always black.(×.If the tree isn&#x27;t NULL, the insert operation won&#x27;t affect the root node. </span></span><br><span class="line"><span class="comment">         * If the tree is NULL, the root is RED. So we need to fix it in the rebalance operation)</span></span><br><span class="line"><span class="comment">         * 3. Every leaf node is black.(√. We won&#x27;t break it)</span></span><br><span class="line"><span class="comment">         * 4. If a node is red, its child node must be black.(×. If the parent node is red, we may break this rule)</span></span><br><span class="line"><span class="comment">         * 5. From any node to its descendant leaf node must have the same number of black nodes. </span></span><br><span class="line"><span class="comment">         * (√. The node we insert is red, this operation won&#x27;t make the number of black nodes change)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        node-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">        <span class="built_in">insertRebalance</span>(root, node);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Insert ends\n&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertRebalance</span><span class="params">(RBTNode&lt;T&gt; *&amp;root, RBTNode&lt;T&gt; *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RBTNode&lt;T&gt; *parent, *grandParent;</span><br><span class="line">        <span class="keyword">while</span> ((parent = node-&gt;<span class="built_in">getParent</span>()) &amp;&amp; parent-&gt;<span class="built_in">getRBTNodeColor</span>() == RED)</span><br><span class="line">        &#123;</span><br><span class="line">            grandParent = parent-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">            RBTNode&lt;T&gt; *uncle = grandParent-&gt;<span class="built_in">getSon</span>(<span class="keyword">static_cast</span>&lt;RBTRelation&gt;(<span class="number">1</span> - parent-&gt;<span class="built_in">getRelation</span>(grandParent)));</span><br><span class="line">            <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;<span class="built_in">getRBTNodeColor</span>() == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                uncle-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                parent-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                grandParent-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">                node = grandParent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (uncle == <span class="literal">NULL</span> || uncle-&gt;<span class="built_in">getRBTNodeColor</span>() == BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                RBTRelation gPRelation = parent-&gt;<span class="built_in">getRelation</span>(grandParent);</span><br><span class="line">                RBTRelation pSRelation = node-&gt;<span class="built_in">getRelation</span>(parent);</span><br><span class="line">                <span class="keyword">if</span> (gPRelation != pSRelation)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">rotate</span>(root, parent, node);</span><br><span class="line">                    <span class="built_in">swap</span>(parent, node);</span><br><span class="line">                &#125;</span><br><span class="line">                parent-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                grandParent-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">                <span class="built_in">rotate</span>(root, grandParent, parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Find the node with minimum value.</span></span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">findMin</span><span class="params">(RBTNode&lt;T&gt; *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RBTNode&lt;T&gt; *cur = node;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;<span class="built_in">getSon</span>(LEFT) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;<span class="built_in">getSon</span>(LEFT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Find the node with maximum value.</span></span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">findMax</span><span class="params">(RBTNode&lt;T&gt; *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RBTNode&lt;T&gt; *cur = node;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;<span class="built_in">getSon</span>(RIGHT) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;<span class="built_in">getSon</span>(RIGHT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">successor</span><span class="params">(RBTNode&lt;T&gt; *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;<span class="built_in">getSon</span>(RIGHT) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMin</span>(node-&gt;<span class="built_in">getSon</span>(RIGHT));</span><br><span class="line">        &#125;</span><br><span class="line">        RBTNode&lt;T&gt; *nxt = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        RBTNode&lt;T&gt; *cur = node;</span><br><span class="line">        <span class="keyword">while</span> ((nxt != <span class="literal">NULL</span>) &amp;&amp; (cur == nxt-&gt;<span class="built_in">getSon</span>(LEFT)))</span><br><span class="line">        &#123;</span><br><span class="line">            cur = nxt;</span><br><span class="line">            nxt = nxt-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">predecessor</span><span class="params">(RBTNode&lt;T&gt; *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;<span class="built_in">getSon</span>(LEFT) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMax</span>(node-&gt;<span class="built_in">getSon</span>(LEFT));</span><br><span class="line">        &#125;</span><br><span class="line">        RBTNode&lt;T&gt; *nxt = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        RBTNode&lt;T&gt; *cur = node;</span><br><span class="line">        <span class="keyword">while</span> ((nxt != <span class="literal">NULL</span>) &amp;&amp; (cur == nxt-&gt;<span class="built_in">getSon</span>(RIGHT)))</span><br><span class="line">        &#123;</span><br><span class="line">            cur = nxt;</span><br><span class="line">            nxt = nxt-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">searchByValue</span><span class="params">(RBTNode&lt;T&gt; *cur, T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur || cur-&gt;<span class="built_in">getValue</span>() == val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; cur-&gt;<span class="built_in">getValue</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchByValue</span>(cur-&gt;<span class="built_in">getSon</span>(LEFT), val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchByValue</span>(cur-&gt;<span class="built_in">getSon</span>(RIGHT), val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeByVal</span><span class="params">(RBTNode&lt;T&gt; *&amp;root, RBTNode&lt;T&gt; *node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// If node&#x27;s left and right are both not NULL.</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Remove starts\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ((node-&gt;<span class="built_in">getSon</span>(LEFT) != <span class="literal">NULL</span>) &amp;&amp; (node-&gt;<span class="built_in">getSon</span>(RIGHT) != <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Situation of node has two sons.\n&quot;</span>);</span><br><span class="line">            RBTNode&lt;T&gt; *replace = <span class="built_in">successor</span>(node);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Successor is:&quot;</span> &lt;&lt; replace-&gt;<span class="built_in">getValue</span>() &lt;&lt; endl;</span><br><span class="line">            RBTNode&lt;T&gt; *parent = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">            <span class="keyword">if</span> (parent)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;<span class="built_in">getSon</span>(LEFT) == node)</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;<span class="built_in">setSon</span>(replace, LEFT);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;<span class="built_in">setSon</span>(replace, RIGHT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root = replace;</span><br><span class="line">            &#125;</span><br><span class="line">            RBTNode&lt;T&gt; *succChild = replace-&gt;<span class="built_in">getSon</span>(RIGHT);</span><br><span class="line">            RBTNode&lt;T&gt; *succParent = replace-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">            RBTNodeColor color = replace-&gt;<span class="built_in">getRBTNodeColor</span>();</span><br><span class="line">            <span class="keyword">if</span> (succParent == node)</span><br><span class="line">            &#123;</span><br><span class="line">                succParent = replace;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (succChild)</span><br><span class="line">                    succChild-&gt;<span class="built_in">setParent</span>(succParent);</span><br><span class="line">                succParent-&gt;<span class="built_in">setSon</span>(succChild, LEFT);</span><br><span class="line">                replace-&gt;<span class="built_in">setSon</span>(node-&gt;<span class="built_in">getSon</span>(RIGHT), RIGHT);</span><br><span class="line">                node-&gt;<span class="built_in">getSon</span>(RIGHT)-&gt;<span class="built_in">setParent</span>(replace);</span><br><span class="line">            &#125;</span><br><span class="line">            replace-&gt;<span class="built_in">setParent</span>(node-&gt;<span class="built_in">getParent</span>());</span><br><span class="line">            replace-&gt;<span class="built_in">setRBTNodeColor</span>(node-&gt;<span class="built_in">getRBTNodeColor</span>());</span><br><span class="line">            replace-&gt;<span class="built_in">setSon</span>(node-&gt;<span class="built_in">getSon</span>(LEFT), LEFT);</span><br><span class="line">            node-&gt;<span class="built_in">getSon</span>(LEFT)-&gt;<span class="built_in">setParent</span>(replace);</span><br><span class="line">            <span class="keyword">if</span> (color == BLACK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">removeRebalance</span>(succChild, succParent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RBTNode&lt;T&gt; *child, *parent;</span><br><span class="line">        RBTNodeColor color;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;<span class="built_in">getSon</span>(LEFT) != <span class="literal">NULL</span>)</span><br><span class="line">            child = node-&gt;<span class="built_in">getSon</span>(LEFT);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            child = node-&gt;<span class="built_in">getSon</span>(RIGHT);</span><br><span class="line">        parent = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">        color = node-&gt;<span class="built_in">getRBTNodeColor</span>();</span><br><span class="line">        <span class="keyword">if</span> (child)</span><br><span class="line">        &#123;</span><br><span class="line">            child-&gt;<span class="built_in">setParent</span>(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;<span class="built_in">getSon</span>(LEFT) == node)</span><br><span class="line">            &#123;</span><br><span class="line">                parent-&gt;<span class="built_in">setSon</span>(child, LEFT);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                parent-&gt;<span class="built_in">setSon</span>(child, RIGHT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (color == BLACK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">removeRebalance</span>(child, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeRebalance</span><span class="params">(RBTNode&lt;T&gt; *node, RBTNode&lt;T&gt; *parent)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;removeRebalance starts\n&quot;</span>);</span><br><span class="line">        RBTNode&lt;T&gt; *sibling;</span><br><span class="line">        <span class="keyword">while</span> ((!node || node-&gt;<span class="built_in">getRBTNodeColor</span>()) == BLACK &amp;&amp; node != root)</span><br><span class="line">        &#123;</span><br><span class="line">            RBTRelation relation = node-&gt;<span class="built_in">getRelation</span>(parent);</span><br><span class="line">            RBTRelation oppRelation = <span class="keyword">static_cast</span>&lt;RBTRelation&gt;(<span class="number">1</span> - relation);</span><br><span class="line">            sibling = parent-&gt;<span class="built_in">getSon</span>(oppRelation);</span><br><span class="line">            <span class="comment">// Case.4 If sibling is red</span></span><br><span class="line">            <span class="keyword">if</span> (sibling-&gt;<span class="built_in">getRBTNodeColor</span>() == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                sibling-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                parent-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">                <span class="built_in">rotate</span>(root, parent, sibling);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Case.3 If sibling is black, the two sons of sibling is black as well.</span></span><br><span class="line">            <span class="keyword">if</span> ((!sibling-&gt;<span class="built_in">getSon</span>(LEFT) || sibling-&gt;<span class="built_in">getSon</span>(LEFT)-&gt;<span class="built_in">getRBTNodeColor</span>() == BLACK) &amp;&amp;</span><br><span class="line">                (!sibling-&gt;<span class="built_in">getSon</span>(RIGHT) || sibling-&gt;<span class="built_in">getSon</span>(RIGHT)-&gt;<span class="built_in">getRBTNodeColor</span>() == BLACK))</span><br><span class="line">            &#123;</span><br><span class="line">                sibling-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">                node = parent;</span><br><span class="line">                parent = node-&gt;<span class="built_in">getParent</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sibling-&gt;<span class="built_in">getSon</span>(oppRelation) || sibling-&gt;<span class="built_in">getSon</span>(oppRelation)-&gt;<span class="built_in">getRBTNodeColor</span>() == BLACK)</span><br><span class="line">                &#123;</span><br><span class="line">                    sibling-&gt;<span class="built_in">getSon</span>(relation)-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                    sibling-&gt;<span class="built_in">setRBTNodeColor</span>(RED);</span><br><span class="line">                    <span class="built_in">rotate</span>(root, sibling, sibling-&gt;<span class="built_in">getSon</span>(relation));</span><br><span class="line">                    sibling = parent-&gt;<span class="built_in">getSon</span>(oppRelation);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    sibling-&gt;<span class="built_in">setRBTNodeColor</span>(parent-&gt;<span class="built_in">getRBTNodeColor</span>());</span><br><span class="line">                    parent-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                    sibling-&gt;<span class="built_in">getSon</span>(oppRelation)-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">                    <span class="built_in">rotate</span>(root, parent, sibling);</span><br><span class="line">                    node = root;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node)</span><br><span class="line">            node-&gt;<span class="built_in">setRBTNodeColor</span>(BLACK);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;removeRebalance ends\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Construction Function</span></span><br><span class="line">    <span class="built_in">RBTree</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// insert Key into RBTree</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RBTNode&lt;T&gt; *newNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> ((newNode = <span class="keyword">new</span> RBTNode&lt;T&gt;(value)) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Create Node Failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">insertNode</span>(<span class="keyword">this</span>-&gt;root, newNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RBTNode&lt;T&gt; *cur = root;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">preOrder</span>(cur) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">preOrder</span><span class="params">(RBTNode&lt;T&gt; *cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string ret = <span class="string">&quot;(&quot;</span>;</span><br><span class="line">        ret += <span class="built_in">to_string</span>(cur-&gt;<span class="built_in">getValue</span>());</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;<span class="built_in">getRBTNodeColor</span>() == RED)</span><br><span class="line">            ret += <span class="string">&quot; RED&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ret += <span class="string">&quot; BLACK&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;<span class="built_in">getSon</span>(LEFT) != <span class="literal">NULL</span>)</span><br><span class="line">            ret = ret + <span class="string">&quot;LEFT:&quot;</span> + <span class="built_in">preOrder</span>(cur-&gt;<span class="built_in">getSon</span>(LEFT));</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;<span class="built_in">getSon</span>(RIGHT) != <span class="literal">NULL</span>)</span><br><span class="line">            ret = ret + <span class="string">&quot;RIGHT:&quot;</span> + <span class="built_in">preOrder</span>(cur-&gt;<span class="built_in">getSon</span>(RIGHT));</span><br><span class="line">        ret += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">RBTNode&lt;T&gt; *<span class="title">search</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchByValue</span>(root, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RBTNode&lt;T&gt; *node;</span><br><span class="line">        <span class="keyword">if</span> ((node = <span class="built_in">search</span>(value)) != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">removeByVal</span>(root, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t find the value in the RB tree!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Test our rb Tree here!</span></span><br><span class="line">    RBTree&lt;<span class="keyword">int</span>&gt; rbTree;</span><br><span class="line">    <span class="keyword">int</span> oper, value;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; oper)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (oper)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// Test insert</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cin &gt;&gt; value;</span><br><span class="line">            rbTree.<span class="built_in">insert</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// Test delete</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cin &gt;&gt; value;</span><br><span class="line">            rbTree.<span class="built_in">remove</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// Test find</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; value;</span><br><span class="line">            RBTNode&lt;<span class="keyword">int</span>&gt; *node = rbTree.<span class="built_in">search</span>(value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Print tree in preorder.</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;------------------\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Print RBTree begin\n&quot;</span>);</span><br><span class="line">            rbTree.<span class="built_in">print</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Print RBTree end\n&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;------------------\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Oops, operation can&#x27;t be recognized.\n&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Test-Cases"><a href="#Test-Cases" class="headerlink" title="Test Cases"></a>Test Cases</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 10</span><br><span class="line">1 40</span><br><span class="line">1 30</span><br><span class="line">1 60</span><br><span class="line">1 90</span><br><span class="line">1 70</span><br><span class="line">1 20</span><br><span class="line">1 50</span><br><span class="line">1 80</span><br><span class="line">4</span><br><span class="line">Output: </span><br><span class="line">(30 BLACK LEFT:(10 BLACK RIGHT:(20 RED))RIGHT:(60 RED LEFT:(40 BLACK RIGHT:(50 RED))RIGHT:(80 BLACK LEFT:(70 RED)RIGHT:(90 RED))))</span><br><span class="line">2 30</span><br><span class="line">Output:</span><br><span class="line">Situation of node has two sons.</span><br><span class="line">Successor is:40</span><br><span class="line">4</span><br><span class="line">Output:</span><br><span class="line">(40 BLACKLEFT:(10 BLACKRIGHT:(20 RED))RIGHT:(60 REDLEFT:(50 BLACK)RIGHT:(80 BLACKLEFT:(70 RED)RIGHT:(90 RED))))</span><br><span class="line">2 10</span><br><span class="line">4</span><br><span class="line">(40 BLACKLEFT:(20 BLACK)RIGHT:(60 REDLEFT:(50 BLACK)RIGHT:(80 BLACKLEFT:(70 RED)RIGHT:(90 RED))))</span><br></pre></td></tr></table></figure>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p><a href="https://www.cnblogs.com/skywang12345/p/3245399.html">The red-black tree: Introduction and algorithm</a><br><a href="https://www.cnblogs.com/skywang12345/p/3624291.html">The red-black tree: Implement of C++</a><br>Introduction of Algorithm(The third edition)<br><a href="https://www.programiz.com/dsa/deletion-from-a-red-black-tree">Deletion From a Red-Black Tree</a><br><a href="https://www.scaler.com/topics/data-structures/red-black-tree/">Red Black Tree in DSA</a> <strong>Thanks for Sandeep Mishra’s Contribution!</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>平衡树</category>
        <category>红黑树</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - 376 Wiggle Subsequence</title>
    <url>/2022/06/18/Leetcode%20-%20376%20Wiggle%20Subsequence/</url>
    <content><![CDATA[<p>It taked me a long time to understand the solutions in Discussion, so I decided to explain it by myself.<br><span id="more"></span> </p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>It’s easy to reach a O(n^2) solution. However, the follow up asks us to solve this problem in linear time. We can’t define upper[i], down[i] as the longest wiggle subsequence ends at i and is upper/lower case. When you define the state in this way, you can’t avoid to traverse back and make the time complexity O(n^2). One solution is to define upper[i], down[i] as the longest wiggle subsequence before i. This state prevent us from traversing again. But we can’t always define dp in this way because this needs the transistion equation <strong>only use the i-1 state to update state i</strong>. Why this defination works? See the following proof:<br><img src="https://s2.loli.net/2022/06/20/rH4nLb2qM1K7uU8.jpg" alt="leetcode376.jpeg"></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> up[<span class="number">1005</span>], down[<span class="number">1005</span>];</span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&gt;nums[i]) &#123;</span><br><span class="line">                down[i] = up[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                up[i] = up[i<span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&lt;nums[i]) &#123;</span><br><span class="line">                up[i] = down[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                down[i] = down[i<span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                down[i] = down[i<span class="number">-1</span>];</span><br><span class="line">                up[i] = up[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(down[nums.<span class="built_in">size</span>()<span class="number">-1</span>], up[nums.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1422 Halloween Costumes</title>
    <url>/2017/11/20/LightOJ%20-%201422%20Halloween%20Costumes/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意是一个人要参加不同的晚会需要穿不同的衣服，衣服可以意见套一件然后再反序脱掉，问最少需要多少件衣服。容易想到使用区间dp。一开始想的状态转移方程是当两端不匹配时，dp[l][r]=min(dp[l+1][r],dp[l][r-1])+1。当两端匹配时，dp[l][r]=dp[l+1][r-1]+1。一开始还觉得没问题，结果得了WA。发现不能只考虑两端的复用，要考虑第一件衣服和中间某件（假设为k）的复用，因为有可能在中间复用会使得dp[l][r]更小。<br>状态转移方程:<br>对于两端不匹配的情况:dp[l][r]=min(dp[l+1][r],dp[l][r-1])+1;<br>对于l-r范围中我们枚举k，如果cloth[l]==cloth[k]，代表我们考虑中间第k件复用:dp[l][r]=min(dp[l][r],dp[l][k-1]+dp[k+1][r]);<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>],a[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t,n;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;t;z++) &#123;</span><br><span class="line">		<span class="built_in">ms</span>(dp, <span class="number">0</span>);</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">			dp[i][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>;len &lt;= n;len++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>;l + len - <span class="number">1</span> &lt; n;l++) &#123;</span><br><span class="line">				<span class="keyword">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">				dp[l][r] = <span class="built_in">min</span>(dp[l][r<span class="number">-1</span>],dp[l + <span class="number">1</span>][r]) + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>;k &lt;= r;k++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (a[l] == a[k]) &#123;</span><br><span class="line">						dp[l][r] = <span class="built_in">min</span>(dp[l][r], dp[l][k - <span class="number">1</span>] + dp[k + <span class="number">1</span>][r]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Case &quot;</span>&lt;&lt;z+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;dp[<span class="number">0</span>][n - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.824分布式系统笔记</title>
    <url>/2022/01/18/MIT%206.824%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>基于MIT 6.824 2021Spring 课程笔记</p>
<span id="more"></span>
<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>MapReduce的算法流程如下：</p>
<ol>
<li>map函数将文件分成M个文件，通常是16-64MB然后储存到文件。</li>
<li>多台机器上会有map程序的拷贝在同时运行。其中一台为Master，负责将输入分配到不同的机器上运行。</li>
<li>每台Map机器会产生许多个{key, value}对。这些对会使用一个hash函数将key映射到大小为R的空间上，并存储到<strong>本机</strong>相应位置。这些文件的地址会被传回master。</li>
<li>Master根据一定的映射关系，将这些地址传给worker。</li>
<li>根据Master 的地址，reduce worker会读取这些文件。当文件被完全读取时，reduce worker会首先根据key进行排序，保证相同key的pair会放在一起（这步非常重要，很多例子给的是一个key对一个ruduce worker。但实际上根本没有这么多机器，所以hash是必须的。但是hash又导致了不同的key挤在了同一个worker上的问题，所以需要排序）然后再进行用户定义的Reduce操作。最后得到的结果会输出到R个文件。</li>
</ol>
<p><img src="https://s2.loli.net/2022/12/15/aUtHZ3NKePTFYvO.jpg" alt="mapreduce-overview.jpg"></p>
<h2 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h2><p>常见的如统计字符个数，URL计数。当然，最为经典的就是在搜索引擎的反向索引上的应用。对于一个网页，我们定义它的索引为{document, {keywords}}。那么它的反向索引就是{keyword, {documents}}通过这种方式我们就能根据关键字找到可能相关的文件。</p>
<h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><h3 id="Worker失效"><a href="#Worker失效" class="headerlink" title="Worker失效"></a>Worker失效</h3><p>Master会使用类似心跳包的机制检测worker是否存活。如果发现failure则会将当前worker的任务记为idle,这样其他空余的worker就能够重新开始这个worker的工作。</p>
<p>如果Map机器A fail，那么我们需要重新进行一遍map。原因是map后的结果保存在了worker的本地文件中。同时，如果一台新机器B重新对同一份数据重新跑map，那么会有一个全局的通知让所有还没读取A（因为两份结果都是正确的，所以读完的可以继续跑，但是没读完的没法再读A了，所以转到B）的Reduce机器转而读取B的数据。如果worker fail了那么它的文件我们显然是读取不到的。</p>
<p>如果Reduce机器fail了那么就不需要重新跑。因为Reduce的结果是保存在gfs而不是worker的local file中。</p>
<h3 id="Master失效"><a href="#Master失效" class="headerlink" title="Master失效"></a>Master失效</h3><p>一种方法是对master设立checkpoint，这样master fail我们也能从checkpoint重新开始。但是对于单点master，只能让client自己检查是否正确运行。</p>
<h2 id="带宽管理"><a href="#带宽管理" class="headerlink" title="带宽管理"></a>带宽管理</h2><p>由于带宽很宝贵，所以MapReduce的一个原则是尽可能在保存数据的机器上执行map操作。Map的worker既能执行map操作，同时它的文件也被gfs管理。在不同的worker上，保存了不同的input的副本。当我们对某个输入A进行map操作时，map会尽可能选择拥有目标输入A的woker进行map。如果所有满足要求的worker都不能进行map操作，那么会选择在同一个网络（机房）的机器进行数据传输以最大可能节约带宽。</p>
<h2 id="备份任务"><a href="#备份任务" class="headerlink" title="备份任务"></a>备份任务</h2><p>有的时候，部分机器会在执行任务时运行得异常地慢。比如部分机器的磁盘出现故障，导致其读写速度从30mb/s下降到1mb/s。不同的机器可能有不同的问题，而对停下机器去检查原因是不能接受的。所以mapreduce的论文中提到，他们在任务快要完成时，会同时在另外一台机器上启动backup任务。这个任务是与即将完成的任务完全相同的。当两个任务的其中一个完成时，另一个没有完成的任务将被终止。</p>
<h2 id="跳过损坏记录"><a href="#跳过损坏记录" class="headerlink" title="跳过损坏记录"></a>跳过损坏记录</h2><p>有时候由于用户代码的问题，mapreduce会无法完成。通常的操作是找到这个bug并修复。但是有的时候错误如果发生在第三方库，那么就很难修复这个bug。同时，我们在部分场景下，可以接受忽略一些记录，比如在大数据集下的数据统计。Mapreduce提供了一个方法使得用户能够在运行中，判断哪些数据需要丢弃。在MapReduce的worker中有一个handler，会catch段错误和总线错误。出现了这种错误后，worker会发一个udp包到master。如果master发现一个记录有多次错误，那么就会判断要抛弃这个record。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote>
<p><a href="http://nil.csail.mit.edu/6.824/2020/papers/mapreduce.pdf">MapReduce论文</a></p>
</blockquote>
]]></content>
      <categories>
        <category>公开课笔记</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1330 Nearest Common Ancestors(倍增LCA)</title>
    <url>/2017/11/08/POJ%20-%201330%20Nearest%20Common%20Ancestors(%E5%80%8D%E5%A2%9ELCA)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在有根树中，我们称距离u和v所有公共祖先中距离最近的称为最近公共祖先(LCA)。<br><img src="https://i.loli.net/2020/12/14/uPVlqKyWm73dH5I.jpg" alt="LCA"><br>一个朴素的求u和v的LCA的想法是让u和v先深度相同，然后逐层向上直到碰到相同元素。复杂度为O(n)。虽然看着简单有效，但对多次查询来说这个复杂度十分不友好。<br>为了高效求解公共祖先，我们有三种方式：</p>
<ul>
<li>倍增法（在线，实现简单）</li>
<li>RMQ（在线，实现复杂）</li>
<li>Tarjan（离线）  </li>
</ul>
<p>本题我们使用倍增法求LCA。倍增法构造LCA预处理复杂度为O(nlogn),查询复杂度为O(logn)。<br>下面会涉及到的一些元素：</p>
<ul>
<li>parent[k][v]:距离v元素2^k距离的祖先</li>
<li>depth[v]:v元素的深度  </li>
</ul>
<p>我们首先通过dfs(int v,int p,int d)初始化parent[0][v],depth[v],根的祖先为-1<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> p, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	parents[<span class="number">0</span>][v] = p;</span><br><span class="line">	depth[v] = d;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = G[v].<span class="built_in">begin</span>();it != G[v].<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(*it!=p)<span class="built_in">dfs</span>(*it, v, d + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接着倍增初始化。外循环是倍增的k，内循环是节点，因为要先求出所有节点的parent[k][v]才能初始化k+1的情况（考虑parent[k+1][v]=parent[k][parent[k][v]])。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">dfs</span>(root, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k + <span class="number">1</span> &lt; MAX_LOG_V;k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>;v &lt;= n;v++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (parents[k][v] &lt; <span class="number">0</span>)parents[k + <span class="number">1</span>][v] = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span> parents[k + <span class="number">1</span>][v] = parents[k][parents[k][v]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果我们用朴素的方法，令数组parent[k][v]为v的k祖先的话预处理时间复杂度会达到O(n^2)，所以是不可接受的。而倍增的话我们在初始化后先将u，v放到同一高度，然后可以进行类似二分搜索的方式。从MAX_LOG_V - 1开始，如果parent[k][v]!=parent[k][u]，那么就向上倍增，这样能保证往上后的节点还没到最近公共祖先，有点类似十进制数贪心变成二进制数的方式。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (depth[u] &gt; depth[v])<span class="built_in">swap</span>(u, v);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; MAX_LOG_V;k++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (((depth[v] - depth[u]) &gt;&gt; k) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			v = parents[k][v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (u == v)<span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = MAX_LOG_V - <span class="number">1</span>;k &gt;= <span class="number">0</span>;k--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (parents[k][u] != parents[k][v]) &#123;</span><br><span class="line">			u = parents[k][u];</span><br><span class="line">			v = parents[k][v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parents[<span class="number">0</span>][u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10005</span>, MAX_LOG_V = <span class="number">20</span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="keyword">int</span> root,deg[MAXN],parents[MAX_LOG_V][MAXN],depth[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> p, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	parents[<span class="number">0</span>][v] = p;</span><br><span class="line">	depth[v] = d;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = G[v].<span class="built_in">begin</span>();it != G[v].<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(*it!=p)<span class="built_in">dfs</span>(*it, v, d + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">dfs</span>(root, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k + <span class="number">1</span> &lt; MAX_LOG_V;k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>;v &lt;= n;v++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (parents[k][v] &lt; <span class="number">0</span>)parents[k + <span class="number">1</span>][v] = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span> parents[k + <span class="number">1</span>][v] = parents[k][parents[k][v]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (depth[u] &gt; depth[v])<span class="built_in">swap</span>(u, v);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; MAX_LOG_V;k++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (((depth[v] - depth[u]) &gt;&gt; k) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			v = parents[k][v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (u == v)<span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = MAX_LOG_V - <span class="number">1</span>;k &gt;= <span class="number">0</span>;k--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (parents[k][u] != parents[k][v]) &#123;</span><br><span class="line">			u = parents[k][u];</span><br><span class="line">			v = parents[k][v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parents[<span class="number">0</span>][u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t,u,v;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="built_in">ms</span>(deg, <span class="number">0</span>),<span class="built_in">ms</span>(parents,<span class="number">0</span>),<span class="built_in">ms</span>(depth,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">			deg[v]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (deg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				root = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">lca</span>(u, v) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAXN;i++)G[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1743 Musical Theme(不可重叠最长重复子串)</title>
    <url>/2017/11/10/POJ%20-%201743%20Musical%20Theme(%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%8F%A0%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题是后缀数组一个常见的应用，不可重叠最长重复子串。后缀数组的基本知识参考<a href="https://manushi98.github.io/post/978515b9.html">SPOJ - SUBST1 New Distinct Substrings</a>一文。对于一个不可重叠最长子串的问题，我们首先对长度二分答案，然后对height数组分段，连续的height值&gt;=k的我们分在一起，然后记录段内sa的最小值和最大值，如果两者的差大于等于k+1（题意要求重复子串之间要有一个字符的间隔）那么现在的k就是符合条件的。需要注意的是这道题卡了cin,cout。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">int</span> ranks[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;<span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123; <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123; x = x * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倍增计算rank</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ranks[i] != ranks[j])<span class="keyword">return</span> ranks[i]&lt;ranks[j];</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> ri = i + k &lt;= n ? ranks[i + k] : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> rj = j + k &lt;= n ? ranks[j + k] : <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> ri&lt;rj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> *sa)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//n = strlen(S);</span></span><br><span class="line">	<span class="comment">//对长度为1的字符直接使用ascii码,长度为0的后缀rank值为-1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		sa[i] = i;</span><br><span class="line">		ranks[i] = i&lt;n ? S[i] : <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>;k &lt;= n;k *= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">sort</span>(sa, sa + n + <span class="number">1</span>, compare_sa);</span><br><span class="line">		tmp[sa[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">			tmp[sa[i]] = tmp[sa[i - <span class="number">1</span>]] + (<span class="built_in">compare_sa</span>(sa[i - <span class="number">1</span>], sa[i]) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) &#123;</span><br><span class="line">			ranks[i] = tmp[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> *sa, <span class="keyword">int</span> *lcp)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//int n = strlen(S);</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)ranks[sa[i]] = i;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">	lcp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = sa[ranks[i] - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (h&gt;<span class="number">0</span>)h--;</span><br><span class="line">		<span class="keyword">for</span> (;j + h&lt;n&amp;&amp;i + h&lt;n;h++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (S[j + h] != S[i + h])<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		lcp[ranks[i] - <span class="number">1</span>] = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">int</span> *sa,<span class="keyword">int</span> *lcp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mins = n + <span class="number">5</span>, maxs = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lcp[i] &gt;= len) &#123;</span><br><span class="line">			mins = <span class="built_in">min</span>(mins, sa[i]), maxs = <span class="built_in">max</span>(maxs, sa[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			mins = <span class="built_in">min</span>(mins, sa[i]), maxs = <span class="built_in">max</span>(maxs, sa[i]);</span><br><span class="line">			<span class="keyword">if</span> (maxs - mins &gt;= len + <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			mins = n + <span class="number">5</span>, maxs = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">int</span> a[MAX_N], diff[MAX_N];</span><br><span class="line">		<span class="keyword">int</span> lcp[MAX_N + <span class="number">1</span>], sa[MAX_N + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">ms</span>(lcp, <span class="number">0</span>), <span class="built_in">ms</span>(sa, <span class="number">0</span>), <span class="built_in">ms</span>(ranks, <span class="number">0</span>), <span class="built_in">ms</span>(tmp, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++)diff[i] = a[i + <span class="number">1</span>] - a[i]+<span class="number">88</span>;</span><br><span class="line">		n--;</span><br><span class="line">		<span class="built_in">construct_sa</span>(diff, sa);</span><br><span class="line">		<span class="built_in">construct_lcp</span>(diff, sa, lcp);</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">3</span>, right = n / <span class="number">2</span>,ans;</span><br><span class="line">		<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (left + right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">judge</span>(mid, sa, lcp))ans = mid,left=mid+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (left == <span class="number">3</span>)<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>后缀数组</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1860 Currency Exchange</title>
    <url>/2018/01/29/POJ%20-%201860%20Currency%20Exchange/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为要最后钱变多，那么要么存在一个包含s的环，绕一圈后钱变多，要么是通过不断绕正环增加自己的钱。所以本题我们需要找正环。类比Bellman-ford找负环计算即可，不同在于初始dist数组为0。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,s;</span><br><span class="line"><span class="keyword">double</span> V;</span><br><span class="line"><span class="keyword">double</span> dist[<span class="number">1005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">double</span> r,c;</span><br><span class="line">    <span class="built_in">edge</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">double</span> r,<span class="keyword">double</span> c):<span class="built_in">u</span>(u),<span class="built_in">v</span>(v),<span class="built_in">r</span>(r),<span class="built_in">c</span>(c)&#123;&#125;;</span><br><span class="line">&#125;e[<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bellman_ford</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">double</span> val)</span></span>&#123;</span><br><span class="line">    <span class="built_in">ms</span>(dist,<span class="number">0</span>);</span><br><span class="line">    dist[s]=val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>*m;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dist[e[j].v]&lt;(dist[e[j].u]-e[j].c)*e[j].r)&#123;</span><br><span class="line">                dist[e[j].v]=(dist[e[j].u]-e[j].c)*e[j].r;</span><br><span class="line">                <span class="keyword">if</span>(i==n<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">double</span> r1,c1,r2,c2;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%lf&quot;</span>,&amp;n,&amp;m,&amp;s,&amp;V))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lf%lf%lf%lf&quot;</span>,&amp;u,&amp;v,&amp;r1,&amp;c1,&amp;r2,&amp;c2);</span><br><span class="line">            e[<span class="number">2</span>*i]=<span class="built_in">edge</span>(u,v,r1,c1),e[<span class="number">2</span>*i+<span class="number">1</span>]=<span class="built_in">edge</span>(v,u,r2,c2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">bellman_ford</span>(s,V))<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
        <category>Bellman-Ford</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2104 K-th Number</title>
    <url>/2018/02/04/POJ%20-%202104%20K-th%20Number/</url>
    <content><![CDATA[<p>学习一下主席树的使用<br><span id="more"></span></p>
<h3 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h3><p>主席树是可持久化线段树的一种。应该可以看作是值域范围上的可持久化线段树？通常我们使用主席树解决区间第k大问题。</p>
<h3 id="先考虑一个问题……"><a href="#先考虑一个问题……" class="headerlink" title="先考虑一个问题……"></a>先考虑一个问题……</h3><blockquote>
<p>给定一个1e5大小的数组，多次询问l，r范围内第k大的数。</p>
</blockquote>
<p>常规解法：离线后莫队<br>emmmm一切看起来很美好，速度也很快。那我们加一个条件：强制在线。<br>现在我们先考虑把问题弱化，如果问1-n上的第k大，要求在线，我们该怎么做？</p>
<h3 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h3><p>为了解决上面这个问题，我们构造一棵权值线段树。每个叶子节点储存一个数字出现的次数（数字的范围可能要离散化），同时我们在每个节点上维护一个子节点数量。权值线段树的建树与线段树相同。查询第k大的时候，我们到一个节点观察其左儿子的子节点数量，如果大于等于k我们往左走，显然第k小数在左子树上，不然我们往右走，同时若子节点数量小于k显然在右子树，同时问题变成查右区间第（k-左子树子节点个数）大数。这样我们完美解决了这个弱化的问题。</p>
<h3 id="回到主席树"><a href="#回到主席树" class="headerlink" title="回到主席树"></a>回到主席树</h3><p>那么现在的问题变成了怎么修改权值线段树让其支持区间第k大。我们考虑用一种类似“前缀和”的思想。一个常规的想法是我们先考虑建n（假定数组n个数)棵值域为1-m(假定我们已经处理好)的权值线段树，显然因为值域的预处理，我们能把它们放在一棵树上，然后节点上维护一个数组，表示第i次插入后节点的sum值，然后被询问l,r区间的时候，我们用把弱化问题中子节点数量变成sum[r]-sum[l-1]（可以理解为变成了[l,r]区间的权值线段树），这样问题就转化为了上面的那个问题。但问题来了，这相当于建了n棵线段树，空间。。好像有点不够用啊？那我们现在观察一下，我们每次插入一个数x，那些节点修改了？显然只有从根到表示x的节点路径上的sum值发生了变化。所以我们考虑在插入的时候先新建一个根，然后复制前一个根给新建的根（为了链接左右儿子），然后就像我之前说的那样，只修改有影响的节点，没影响的指向之前树的节点（还是不理解的看下图）。通过对共同部分的利用，我们完成了节约空间的目的。<br><img src="https://i.loli.net/2020/12/14/oOfR7u5AvtQxV3e.jpg" alt="主席树"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> nodecnt=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;</span><br><span class="line">&#125;tree[MAXN*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> roots[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tree[nodecnt].ls=tree[nodecnt].rs=<span class="number">-1</span>,tree[nodecnt].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> nodecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inserts</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    tree[root].sum++;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="built_in">newnode</span>(),mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=mid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[root].ls!=<span class="number">-1</span>)tree[t]=tree[tree[root].ls];</span><br><span class="line">        tree[root].ls=t;</span><br><span class="line">        <span class="built_in">inserts</span>(num,l,mid,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[root].rs!=<span class="number">-1</span>)tree[t]=tree[tree[root].rs];</span><br><span class="line">        tree[root].rs=t;</span><br><span class="line">        <span class="built_in">inserts</span>(num,mid+<span class="number">1</span>,r,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rootl,<span class="keyword">int</span> rootr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> t=tree[tree[rootr].ls].sum-tree[tree[rootl].ls].sum;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=t)<span class="keyword">return</span> <span class="built_in">query</span>(tree[rootl].ls,tree[rootr].ls,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(tree[rootl].rs,tree[rootr].rs,mid+<span class="number">1</span>,r,k-t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[MAXN],car[MAXN],id[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        nodecnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);</span><br><span class="line">        <span class="built_in">memcpy</span>(car,arr,<span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">        <span class="built_in">sort</span>(car,car+n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)id[i]=<span class="built_in">lower_bound</span>(car,car+n,arr[i])-car+<span class="number">1</span>;</span><br><span class="line">        roots[<span class="number">0</span>]=<span class="built_in">newnode</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            roots[i]=<span class="built_in">newnode</span>();</span><br><span class="line">            tree[roots[i]]=tree[roots[i<span class="number">-1</span>]];</span><br><span class="line">            <span class="built_in">inserts</span>(id[i<span class="number">-1</span>],<span class="number">1</span>,n,roots[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left,right,k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;left,&amp;right,&amp;k);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,car[<span class="built_in">query</span>(roots[left<span class="number">-1</span>],roots[right],<span class="number">1</span>,n,k)<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>主席树</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2115 C Looooops</title>
    <url>/2018/01/30/POJ%20-%202115%20C%20Looooops/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>构造线性方程cx+2^k*y=b-a，直接extgcd即可，注意对线性方程有通解计算公式:x1=x0+k*b/(gcd(a,b)),y1=y0-k*a/(gcd(a,b))。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">extgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    ll d=a;</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        d=<span class="built_in">extgcd</span>(b,a%b,y,x);</span><br><span class="line">        y-=(a/b)*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a,b,c,k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%I64d%I64d%I64d%I64d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;k))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a&amp;&amp;!b&amp;&amp;!c&amp;&amp;!k)<span class="keyword">break</span>;</span><br><span class="line">        ll x,y;</span><br><span class="line">        ll tgcd=<span class="built_in">extgcd</span>(c,(<span class="number">1ll</span>&lt;&lt;k),x,y);</span><br><span class="line">        <span class="keyword">if</span>((b-a)%tgcd)<span class="built_in">printf</span>(<span class="string">&quot;FOREVER\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll B=(<span class="number">1ll</span>&lt;&lt;k)/tgcd,C=(b-a)/tgcd;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,((x%B*C%B+B)%B));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>扩展欧几里得</category>
      </categories>
      <tags>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2114 Boatherds(点分治)</title>
    <url>/2018/04/10/POJ%20-%202114%20Boatherds(%E7%82%B9%E5%88%86%E6%B2%BB)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>点分治裸题，但统计长度为k的路径时需要注意要使用O(n)的算法（我用了O(n^2)的居然没发现，TLE。。）具体思路就是先对depth排序，然后当depth[l]+depth[r]==k是，因为可能有与depth[l],depth[r]深度相同的，所以统计相同的个数直接numl*numr计算。若depth[l]+depth[r]&lt;k那么l++，因为这时对当前的l能满足条件的r都已经计算过了，所以直接l++。若depth[l]+depth[r]&gt;k，思路一样，r—。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10005</span>,MAXM=<span class="number">10005</span>*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> head[MAXN],nxt[MAXM],to[MAXM],val[MAXM],edgecnt,n,sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    to[edgecnt]=v;</span><br><span class="line">    val[edgecnt]=w;</span><br><span class="line">    nxt[edgecnt]=head[u];</span><br><span class="line">    head[u]=edgecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> son[MAXN],maxson[MAXN],vis[MAXN],root,depth[MAXN],d[MAXN],ans,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    son[u]=<span class="number">1</span>,maxson[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v!=fa&amp;&amp;!vis[v])&#123;</span><br><span class="line">            <span class="built_in">getroot</span>(v,u);</span><br><span class="line">            son[u]+=son[v];</span><br><span class="line">            maxson[u]=<span class="built_in">max</span>(maxson[u],son[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxson[u]=<span class="built_in">max</span>(maxson[u],sum-son[u]);</span><br><span class="line">    <span class="keyword">if</span>(maxson[u]&lt;maxson[root])root=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdeep</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    depth[++depth[<span class="number">0</span>]]=d[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(v!=fa&amp;&amp;!vis[v])&#123;</span><br><span class="line">            d[v]=d[u]+val[i];</span><br><span class="line">            <span class="built_in">getdeep</span>(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> cost)</span></span>&#123;</span><br><span class="line">    d[u]=cost,depth[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getdeep</span>(u,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(depth+<span class="number">1</span>,depth+depth[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> r=depth[<span class="number">0</span>],res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;r;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[l]+depth[r]==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(depth[l]==depth[r])&#123;</span><br><span class="line">                res+=(r-l)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tl=l,tr=r;</span><br><span class="line">            <span class="keyword">while</span>(depth[tl]==depth[l])tl++;</span><br><span class="line">            <span class="keyword">while</span>(depth[tr]==depth[r])tr--;</span><br><span class="line">            res+=(tl-l)*(r-tr);</span><br><span class="line">            l=tl,r=tr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(depth[l]+depth[r]&lt;k)l++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    ans+=<span class="built_in">cal</span>(u,<span class="number">0</span>);</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=to[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            ans-=<span class="built_in">cal</span>(v,val[i]);</span><br><span class="line">            sum=son[v];</span><br><span class="line">            root=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">getroot</span>(v,<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">solve</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)&#123;</span><br><span class="line">        <span class="built_in">ms</span>(head,<span class="number">-1</span>);</span><br><span class="line">        edgecnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v,w;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v)&amp;&amp;v)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w);</span><br><span class="line">                <span class="built_in">addedge</span>(i,v,w),<span class="built_in">addedge</span>(v,i,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q)&amp;&amp;q)&#123;</span><br><span class="line">            <span class="built_in">ms</span>(depth,<span class="number">0</span>),<span class="built_in">ms</span>(son,<span class="number">0</span>),<span class="built_in">ms</span>(maxson,<span class="number">0</span>),<span class="built_in">ms</span>(vis,<span class="number">0</span>);</span><br><span class="line">            ans=<span class="number">0</span>,k=q,root=<span class="number">0</span>,sum=n,maxson[<span class="number">0</span>]=INF;</span><br><span class="line">            <span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">solve</span>(root);</span><br><span class="line">            <span class="keyword">if</span>(ans)<span class="built_in">printf</span>(<span class="string">&quot;AYE\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NAY\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>点分治</category>
      </categories>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2449 Remmarguts&#39; Date</title>
    <url>/2018/02/18/POJ%20-%202449%20Remmarguts&#39;%20Date/</url>
    <content><![CDATA[<h3 id="关于A"><a href="#关于A" class="headerlink" title="关于A*"></a>关于A*</h3><p>A*算法是一种启发式搜索的算法，通过设定合理的估价函数，我们能够减少不必要的搜索从而达到减低时间复杂度的目的。当我们计算A*算法时，我们维护一个优先队列，同时按照我们规定的估价函数来进行排序。我们这样定义一个估价函数：F=G+H。这里：<br>F：需要排序的估价函数值<br>G：从起点到当前点的花费<br>H：我们人为设定的估价函数值<br>在这里我们这样理解这个估价函数，我们从起点到终点，我们定义H为当前点到终点的距离，很显然根据G+H，绕路走的F是比较大的，F就是我们人为观感上的“绕路走”，A*的估价函数的意义就是少“绕路走”，同时我们常常使用的BFS就是没有估价函数的，所以即便一些步骤我们明明知道不会产生最优解，我们依然遍历了这些步骤，A*的估价函数则避免了这个问题。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题我们先用dijkstra计算t到每个点的距离，然后这个距离就是我们的估价函数，然后我们从s出发使用A*，然后等第k次出队列碰到t点我们输出距离。需要注意的是当s==t时k++，因为题目要求必须要走一条路。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cppblog.com/mythit/archive/2009/04/19/80492.aspx">A*算法入门</a><br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1005</span>,MAXM=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p1,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.first!=p2.first)<span class="keyword">return</span> p1.first&lt;p2.first;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p1.second&lt;p2.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,g,v;</span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> f,<span class="keyword">int</span> g,<span class="keyword">int</span> v):<span class="built_in">f</span>(f),<span class="built_in">g</span>(g),<span class="built_in">v</span>(v)&#123;&#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> A a)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.f==f)<span class="keyword">return</span> a.g&lt;g;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a.f&lt;f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> dist[MAXN];</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; G[MAXN],H[MAXN];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;,cmp&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)dist[i]=INF;</span><br><span class="line">    dist[V]=<span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>,V));</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; temp=pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> val=temp.first,pos=temp.second;</span><br><span class="line">        <span class="keyword">if</span>(val&gt;dist[pos])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator it=G[pos].<span class="built_in">begin</span>();it!=G[pos].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[it-&gt;first]&gt;dist[pos]+it-&gt;second)&#123;</span><br><span class="line">                dist[it-&gt;first]=dist[pos]+it-&gt;second;</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dist[it-&gt;first],it-&gt;first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;A&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aStar</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())p.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(from==to)k++;</span><br><span class="line">    <span class="keyword">if</span>(dist[from]==INF)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="function">A <span class="title">t</span><span class="params">(dist[from],<span class="number">0</span>,from)</span></span>;</span><br><span class="line">    p.<span class="built_in">push</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        A temp=p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(temp.v==to)&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt==k)<span class="keyword">return</span> temp.g;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;::iterator it=H[temp.v].<span class="built_in">begin</span>();it!=H[temp.v].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            <span class="function">A <span class="title">te</span><span class="params">(temp.g+it-&gt;second+dist[it-&gt;first],temp.g+it-&gt;second,it-&gt;first)</span></span>;</span><br><span class="line">            p.<span class="built_in">push</span>(te);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,w;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            G[v].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u,w));</span><br><span class="line">            H[u].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(v,w));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;s,&amp;t,&amp;k);</span><br><span class="line">        <span class="built_in">dijkstra</span>(t);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">aStar</span>(s,t));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAXN;i++)G[i].<span class="built_in">clear</span>(),H[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>A*</category>
      </categories>
      <tags>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 3252 Round Numbers</title>
    <url>/2017/10/15/POJ%20-%203252%20Round%20Numbers/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意是找[l,r]范围中转换成二进制后0的数量大于1的数（前导零不算）。做了几道数位dp的题后发现数位dp的大致思路大概有两种。一种是在最开始通过init打出所有情况再进行dp，另外一种就是这道题使用的dfs。对于数位dp中的dfs，我们大致使用类似如下的模板：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int dfs(int pos,状态(这道题是0，1的个数，是否是第一位),int limit(判断前一位是否到上限，到了现在这位就要用digit[pos]))&#123;</span><br><span class="line">    if(pos==-1)return -1;//显然当pos等于-1的时候说明我们搜索到了合法数的边界，返回1</span><br><span class="line">    if(!limit&amp;&amp;!lead&amp;&amp;dp[pos][状态]!=-1)return dp[pos][状态];//使用记忆化减少计算量</span><br><span class="line">    int ans=0;</span><br><span class="line">    int up=limit?digit[pos]:9;//如前所说，limit==true该位就同样有了限制</span><br><span class="line">    for(int i=0;i&lt;up;i++)&#123;</span><br><span class="line">        if()...</span><br><span class="line">        else if()...</span><br><span class="line">        //状态转移：ans+=dfs(pos-1,status,lead&amp;&amp;i==0,limit&amp;&amp;i==digit[pos]);最后两个参数必须这样写，因为前导零需要之前的lead也为true同时limit也是如此</span><br><span class="line">    &#125;</span><br><span class="line">    if(!limit&amp;&amp;!lead)dp[pos][状态]=ans;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里有一个我之前搞不懂的问题，为什么记忆化的时候需要!limit&amp;&amp;!lead?考虑前导零是因为有前导零的时候状态少计算了，很显然当前位也是零的情况需要特别计算，只有没有前导零的状态下dp的状态是一样的，limit也是一样，有limit状态会比没有limit少，需要视为特殊情况，不做记录。</p>
<p>参考博客：<a href="http://blog.csdn.net/wust_zzwh/article/details/52100392">数位dp总结 之 从入门到模板</a><br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">50</span>][<span class="number">50</span>][<span class="number">50</span>], digit[<span class="number">50</span>],length;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">bool</span> lead,<span class="keyword">int</span> z,<span class="keyword">int</span> o,<span class="keyword">bool</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (pos == <span class="number">-1</span>&amp;&amp;z&gt;=o)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!limit&amp;&amp;!lead &amp;&amp; dp[pos][z][o] != <span class="number">-1</span>)<span class="keyword">return</span> dp[pos][z][o];</span><br><span class="line">	<span class="keyword">int</span> l = limit ? digit[pos]:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= l;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (lead) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>)ans+=<span class="built_in">dfs</span>(pos - <span class="number">1</span>, <span class="literal">true</span>, <span class="number">0</span>, <span class="number">0</span>, limit&amp;&amp;i == digit[pos]);</span><br><span class="line">			<span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(pos - <span class="number">1</span>, <span class="literal">false</span>, <span class="number">0</span>, <span class="number">1</span>, limit&amp;&amp;i == digit[pos]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">0</span>)ans+=<span class="built_in">dfs</span>(pos - <span class="number">1</span>, <span class="literal">false</span>, z+<span class="number">1</span>, o, limit&amp;&amp;i == digit[pos]);</span><br><span class="line">			<span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(pos - <span class="number">1</span>, <span class="literal">false</span>, z, o + <span class="number">1</span>, limit&amp;&amp;i == digit[pos]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!limit)dp[pos][z][o] = ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = n,k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i) &#123;</span><br><span class="line">		digit[k++] = i % <span class="number">2</span>;</span><br><span class="line">		i /= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	length = i;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(k - <span class="number">1</span>, <span class="literal">true</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; l &gt;&gt; r) &#123;</span><br><span class="line">		<span class="built_in">ms</span>(dp, <span class="number">-1</span>);</span><br><span class="line">		cout &lt;&lt; <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>数位dp</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 3167 Cow Patterns</title>
    <url>/2017/11/18/POJ%20-%203167%20Cow%20Patterns/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道非常好的kmp题。如果我们想要使用kmp的话，模式串一定要是固定的才行，而本题中，我们是要找一个排名串。这一就要用到一个结论：两个排名串相等，当且仅当对于两个排名串其中相同位置的数，他俩之前比他俩小的数字个数相等而且小于等于他俩的数字个数也相等。这样就转化为了固定的模式串的问题。然后我们需要修改makenext这个函数和kmp的匹配函数，因为其中有动态的增加减少，比如我们失配的时候，我们需要减掉一部分不必要的数字前缀（见代码）。为了取得比一个数小的个数和小于等于他的数，我们使用树状数组（也可以枚举）。题意给了数字最大不超过30，我们开一个BIT[30],然后维护这个树状数组。最后的问题就是POJ的g++似乎对cin，cout很不友好啊？我用c++得了ac，用g++居然TLE???真是玄学。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nexts[<span class="number">25005</span>], a[<span class="number">100005</span>], b[<span class="number">25005</span>],bs[<span class="number">25005</span>],be[<span class="number">25005</span>], n, m,s;</span><br><span class="line"><span class="keyword">int</span> BIT[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = pos;</span><br><span class="line">	<span class="keyword">while</span> (x &lt; <span class="number">30</span>) &#123;</span><br><span class="line">		BIT[x] += val;</span><br><span class="line">		x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = pos,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		sum += BIT[x];</span><br><span class="line">		x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makenext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> q, k;</span><br><span class="line">	<span class="built_in">ms</span>(BIT, <span class="number">0</span>);</span><br><span class="line">	nexts[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (q = <span class="number">1</span>, k = <span class="number">0</span>;q &lt; m;q++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; (<span class="built_in">sum</span>(b[q]) != be[k] || <span class="built_in">sum</span>(b[q] - <span class="number">1</span>) != bs[k])) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = q - k;j &lt; q - nexts[k - <span class="number">1</span>];j++)<span class="built_in">add</span>(b[j], <span class="number">-1</span>);</span><br><span class="line">			k = nexts[k - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">sum</span>(b[q]) == be[k] &amp;&amp; <span class="built_in">sum</span>(b[q] - <span class="number">1</span>) == bs[k]))k++;</span><br><span class="line">		nexts[q] = k;</span><br><span class="line">		<span class="built_in">add</span>(b[q], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">kmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, q;</span><br><span class="line">	set&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="built_in">makenext</span>();</span><br><span class="line">	<span class="built_in">ms</span>(BIT, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, q = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (q &gt; <span class="number">0</span> &amp;&amp; (<span class="built_in">sum</span>(a[i]) != be[q] || <span class="built_in">sum</span>(a[i] - <span class="number">1</span>) != bs[q])) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i - q;j &lt; i - nexts[q - <span class="number">1</span>];j++)<span class="built_in">add</span>(a[j], <span class="number">-1</span>);</span><br><span class="line">			q = nexts[q - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">sum</span>(a[i]) == be[q] &amp;&amp; <span class="built_in">sum</span>(a[i] - <span class="number">1</span>) == bs[q]))q++;</span><br><span class="line">		<span class="keyword">if</span> (q == m) &#123;</span><br><span class="line">			ans.<span class="built_in">insert</span>(i - q + <span class="number">2</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i - q+<span class="number">1</span>;j &lt;= i - nexts[q - <span class="number">1</span>];j++)<span class="built_in">add</span>(a[j], <span class="number">-1</span>);</span><br><span class="line">			q = nexts[q - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s)!=EOF) &#123;</span><br><span class="line">		<span class="built_in">ms</span>(BIT, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">			be[i] = <span class="built_in">sum</span>(b[i]),bs[i]=<span class="built_in">sum</span>(b[i]<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">add</span>(b[i], <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		set&lt;<span class="keyword">int</span>&gt; ans=<span class="built_in">kmp</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)ans.<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = ans.<span class="built_in">begin</span>();it != ans.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>kmp</category>
      </categories>
      <tags>
        <tag>kmp</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ – 1141 Brackets Sequence</title>
    <url>/2017/10/13/POJ%20%E2%80%93%201141%20Brackets%20Sequence/</url>
    <content><![CDATA[<p><em>思路：</em><br>区间上的动态规划，计算区间上的失配数。如果外围区间上()[]已经配好，dp值为dp[l+1][r-1]很显然我们要做的就是把失配的括号边上添一个括号。</p>
<span id="more"></span>
<p><em>代码：</em><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>], pos[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">string str;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prints</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st &gt; ed)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (st == ed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[st] == <span class="string">&#x27;(&#x27;</span> || str[st] == <span class="string">&#x27;)&#x27;</span>)cout &lt;&lt; <span class="string">&quot;()&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pos[st][ed] == <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; str[st];</span><br><span class="line">        <span class="built_in">prints</span>(st + <span class="number">1</span>, ed - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; str[ed];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">prints</span>(st, pos[st][ed]);</span><br><span class="line">        <span class="built_in">prints</span>(pos[st][ed] + <span class="number">1</span>, ed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;str) &#123;</span><br><span class="line">        <span class="built_in">ms</span>(dp, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; str.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>;l &lt;str.<span class="built_in">length</span>();l++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>;left+l&lt; str.<span class="built_in">length</span>();left++) &#123;</span><br><span class="line">                <span class="keyword">int</span> right = left + l;</span><br><span class="line">                <span class="keyword">if</span> ((str[left] == <span class="string">&#x27;(&#x27;</span>&amp;&amp;str[right] == <span class="string">&#x27;)&#x27;</span>) || (str[left] == <span class="string">&#x27;[&#x27;</span>&amp;&amp;str[right] == <span class="string">&#x27;]&#x27;</span>))dp[left][right] = dp[left + <span class="number">1</span>][right - <span class="number">1</span>], pos[left][right] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[left][right] = INF;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right;k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[left][k] + dp[k + <span class="number">1</span>][right] &lt; dp[left][right])dp[left][right] = dp[left][k] + dp[k + <span class="number">1</span>][right], pos[left][right] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">prints</span>(<span class="number">0</span>, str.<span class="built_in">length</span>() - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ – 2299 Ultra-QuickSort</title>
    <url>/2017/10/13/POJ%20%E2%80%93%202299%20Ultra-QuickSort/</url>
    <content><![CDATA[<p><em>思路：</em><br>一道典型的树状数组求逆序对题，不详细写了，主要就是练习一下离散化.</p>
<span id="more"></span>
<p><em>代码：</em><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> bit[<span class="number">500005</span>],a[<span class="number">500005</span>],b[<span class="number">500005</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=pos,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans += bit[i];</span><br><span class="line">        i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">500004</span>) &#123;</span><br><span class="line">        bit[i] += x;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;n&amp;&amp;n) &#123;</span><br><span class="line">        ll ans= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ms</span>(bit, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">        <span class="keyword">int</span> size = <span class="built_in">unique</span>(a, a + n)-a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="built_in">lower_bound</span>(a, a + size, b[i]) - a+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">add</span>(index, <span class="number">1</span>);</span><br><span class="line">            ans =ans+(ll)(i-<span class="built_in">sum</span>(index)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组,逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ – 2352 Stars</title>
    <url>/2017/10/13/POJ%20%E2%80%93%202352%20Stars/</url>
    <content><![CDATA[<p><em>思路：</em><br>说来惭愧，看到这道题的第一反应是一个二维的树状数组（因为题没读完）。在读二维树状数组的资料时恰好看到了别人的资料，发现读入数据是按照y坐标的递增序读入的。那么对于y的考虑显然是不必要的，所以只需要一维就能够完成这道题。这道题使用y递增序化二维问题为一维问题似乎是个不错的解题思路？然后由于是第一次手写BIT的板子，在这里稍微做一些笔记吧。</p>
<p><img src="https://i.loli.net/2020/12/14/toecQj2qKE83Ji6.jpg" alt="BIT"><br>在白书上对于树状数组提供的功能有两个：<br><em>1.给定位置，计算前缀和</em></p>
<p>通过上图的二进制我们能够发现为了求到n的区间和，我们可以通过不断去掉末尾的1（即lowbit）然后对BIT[n]求和的方法来计算前缀和。那么怎么理解这个过程？我的理解是在建立树状数组的时候我们可以把每个部分看成一个小的树状数组。很显然应该能够理解类似100这样的二进制数在维护一个大区间，然后对于后面的两个0位，我们通过添加一个1（对于两个0位每添加一个1就是一个新区间，不能添加两个，不然就跑到7去了，可以对照着图理解）构成了一个小的树状数组的空间（101，110），通过这样不断递归的定义最终完成了整个树状数组。所以在回过头去求的时候我们就要去掉末尾的1返回到前面那个区间。<br><em>2.给定位置的变化量，更新维护的前缀和</em><br>根据上面的介绍，不难理解对于形如1xxx（x为0或者1）的数都处于一个类似小树状数组的空间中，通过左移1可以在同一个树状数组中逐层向上，所以而1xxx又处在10000（即多一位）的区间中，所以显然是可以这样更新的。</p>
<p>树状数组通常用来求解逆序对以及前缀和询问。<br><span id="more"></span><br><em>代码：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> bit[<span class="number">35000</span>],level[<span class="number">17000</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=pos,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans += bit[i];</span><br><span class="line">        i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">35000</span>) &#123;</span><br><span class="line">        bit[i] += x;</span><br><span class="line">        i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">ms</span>(bit, <span class="number">0</span>),<span class="built_in">ms</span>(level,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="keyword">int</span> lev = <span class="built_in">sum</span>(x+<span class="number">1</span>);</span><br><span class="line">            level[lev]++;</span><br><span class="line">            <span class="built_in">add</span>(x+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) cout &lt;&lt; level[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ – 2387 Til the Cows Come Home（Dijkstra堆优化）</title>
    <url>/2017/10/13/POJ%20%E2%80%93%202387%20Til%20the%20Cows%20Come%20Home%EF%BC%88Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96%EF%BC%89/</url>
    <content><![CDATA[<p><em>思路：</em><br>最短路的裸题，不过想尝试一下以前没用过的Dijkstra的堆优化。Dijkstra的思路简单的说就是找目前没有扫描过的，且到出发点最近的点。标记其为使用过后再更新其周围的点的最短路径。常规时间复杂度为O(|V|^2)。在算法中我们可以使用一个小顶堆维护当前的离出发点最近的点，避免了多余的扫描，使得复杂度变为O(|E|log|V|)。这题一眼扫过去是个裸题就直接做了，没看到题目说可以有重边。。</p>
<span id="more"></span>
<p><em>代码：</em><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.first != b.first)<span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果要对结构体比较，在priority_queue第三个参数要传greater(from &lt;functional&gt;)或者一个拟函数，即如上的结构体，重载一个括号运算符.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1005</span>,MAXV=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN], used[MAXN],line[MAXN];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, cmp&gt; pq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ms</span>(used, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++) line[i] = INF;</span><br><span class="line">    line[N<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, N - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> x = p.second, min = p.first;</span><br><span class="line">        <span class="keyword">if</span> (line[x] &lt; min)<span class="keyword">continue</span>;</span><br><span class="line">        used[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line[j] &gt; line[x] + a[x][j]) &#123;</span><br><span class="line">                line[j]=line[x] + a[x][j];</span><br><span class="line">                pq.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(line[j], j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> T, N,f,t,l;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; T &gt;&gt; N) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++) &#123;</span><br><span class="line">                a[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; T;i++) &#123;</span><br><span class="line">            cin &gt;&gt; f &gt;&gt; t &gt;&gt; l;</span><br><span class="line">            <span class="keyword">if</span>(a[f<span class="number">-1</span>][t<span class="number">-1</span>]&gt;l)a[f<span class="number">-1</span>][t<span class="number">-1</span>] = l,a[t<span class="number">-1</span>][f<span class="number">-1</span>]=l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>(N);</span><br><span class="line">        cout &lt;&lt; line[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>最短路</category>
        <category>Dijkstra</category>
      </categories>
      <tags>
        <tag>最短路,Dijkstra堆优化</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOJ - SUBST1 New Distinct Substrings</title>
    <url>/2017/10/18/SPOJ%20-%20SUBST1%20New%20Distinct%20Substrings/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题意是计算字符串所有本质不同的子串。主要思路是利用后缀数组的性质。因为是第一次使用后缀数组，所以在这里稍微做一些笔记。</p>
<h3 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h3><p>后缀指的是从字符串的某个位置到字符串结尾的子串（包括原串和空串）。而后缀数组指的是包括所有字符串后缀的一个数组，同时其中的后缀已经完成了字典序的排序<br><img src="https://i.loli.net/2020/12/14/oeQlwBjrqGpvg42.jpg" alt="Suffix-Array"><br>上图就是白书中后缀数组的样例，其中sa[i]指的是从第几个字符开始的后缀。</p>
<h4 id="后缀数组的生成"><a href="#后缀数组的生成" class="headerlink" title="后缀数组的生成"></a>后缀数组的生成</h4><p>在了解了后缀数组的内容后我们首先来讲讲如何实现。后缀数组的实现类似于基数排序，先比较各个后缀的第一个字符，然后利用这次的比较结果，我们能够计算长度为2的rank（先比较前一个长度为一的字符串，在比较后一个）。通过不断倍增长度最后完成对所有长度字符串的排序，如果发现后半部分长度超过字符串长度的话，就令他为最小的（-1）,可以参考下面第二张图的a的第二个rank。这里或许会不能理解为什么可以这样比，难道不会有遗漏的字符使得这样的比较不能够进行吗？答案是否定的。实际上每一个后缀的第一个字符拼在一起就是整个字符串，所以不用担心有缺漏的情况。这个过程的时间复杂度为O(nlog^2n)。<br><img src="https://i.loli.net/2020/12/14/DKMmyi7k9pgNQae.jpg" alt="Suffix-Array-Sort1"><br><img src="https://i.loli.net/2020/12/14/mB7ypiRSKghlbso.jpg" alt="Suffix-Array-Sort2"></p>
<h4 id="高度数组"><a href="#高度数组" class="headerlink" title="高度数组"></a>高度数组</h4><p>高度数组指的是相邻两个后缀的公共最长前缀。<br><img src="https://i.loli.net/2020/12/14/SD4tHBVPcXZWLI3.jpg" alt="Suffix-Array-Height-Array"><br>在高度数组中，最关键的就是height[i] ≥ height[i - 1] - 1这个性质。i与i-1指的是sa中相邻的两个后缀，比如abra和bra，从上图中我们能够看到abra后面三个子串和bra后面三个子串只是差一个前面的a，那么我们就能复用之前abra的height数组，所以显然有height[i] ≥ height[i - 1] - 1，构造的时间复杂度为O(n)。</p>
<h3 id="本题思路"><a href="#本题思路" class="headerlink" title="本题思路"></a>本题思路</h3><p>在了解了后缀数组的性质后，我们可以发现，一个后缀对子串数量的贡献是str.length()-sa[i]-height[i]。原理是height就是重复的子串，减掉就是去重的过程。<br><span id="more"></span></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">60000</span>;</span><br><span class="line"><span class="keyword">int</span> ranks[MAX_N+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[MAX_N+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//倍增计算rank</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare_sa</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ranks[i]!=ranks[j])<span class="keyword">return</span> ranks[i]&lt;ranks[j];</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ri=i+k&lt;=n?ranks[i+k]:<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> rj=j+k&lt;=n?ranks[j+k]:<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> ri&lt;rj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_sa</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> *sa)</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">strlen</span>(S);</span><br><span class="line">	<span class="comment">//对长度为1的字符直接使用ascii码,长度为0的后缀rank值为-1</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		sa[i]=i;</span><br><span class="line">		ranks[i]=i&lt;n?S[i]:<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k*=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">sort</span>(sa,sa+n+<span class="number">1</span>,compare_sa);</span><br><span class="line">		tmp[sa[<span class="number">0</span>]]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			tmp[sa[i]]=tmp[sa[i<span class="number">-1</span>]]+(<span class="built_in">compare_sa</span>(sa[i<span class="number">-1</span>],sa[i])?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			ranks[i]=tmp[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_lcp</span><span class="params">(<span class="keyword">char</span> S[],<span class="keyword">int</span> *sa,<span class="keyword">int</span> *lcp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n=<span class="built_in">strlen</span>(S);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)ranks[sa[i]]=i;</span><br><span class="line">	<span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">	lcp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j=sa[ranks[i]<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(h&gt;<span class="number">0</span>)h--;</span><br><span class="line">		<span class="keyword">for</span>(;j+h&lt;n&amp;&amp;i+h&lt;n;h++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(S[j+h]!=S[i+h])<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		lcp[ranks[i]<span class="number">-1</span>]=h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="keyword">char</span> s[MAX_N+<span class="number">1</span>];</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> lcp[MAX_N+<span class="number">1</span>],sa[MAX_N+<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">ms</span>(lcp,<span class="number">0</span>),<span class="built_in">ms</span>(sa,<span class="number">0</span>),<span class="built_in">ms</span>(ranks,<span class="number">0</span>),<span class="built_in">ms</span>(tmp,<span class="number">0</span>);</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		<span class="built_in">construct_sa</span>(s,sa);</span><br><span class="line">		<span class="built_in">construct_lcp</span>(s,sa,lcp);</span><br><span class="line">		<span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">			ans+=len-sa[i]-lcp[i];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>后缀数组</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOJ – QTREE Query on a tree</title>
    <url>/2017/10/13/SPOJ%20%E2%80%93%20QTREE%20Query%20on%20a%20tree/</url>
    <content><![CDATA[<p><em>思路：</em><br>树链剖分模板题，TLE11次结果发现是自己细节上蠢了。。<br><em>树链剖分的原理</em></p>
<p>树链剖分是对一棵树进行轻重链划分，然后使用数据结构来维护每条链的一种算法。通常是为了解决树上点到点（也可以是点到边）值的更新与查询。在树链剖分中，核心的算法是两次dfs。第一次dfs我们对每个节点都确定其儿子节点中最“重”的节点（也就是size最大的节点），并记录一些关键信息，如深度，父亲节点等。第二次中我们对树上节点重新编号（因为优先对重儿子赋值，使得其id在线段树上连续，使得更新更加方便），同时确定其祖先节点。重儿子的祖先是其父亲的祖先，轻儿子的祖先是自己。在查询的过程中，如果两个节点的祖先节点相同，那么我们显然可以直接在线段树上查询，而不同的话我们就先更新其到其祖先节点的val，然后用之前记录的父亲节点爬到另一根链上（这里要注意，要优先用depth较深的节点进行更新）。这样交替进行直到成为我们之前碰到的两个点在一条链上，最后完成查询。</p>
<p><em>本题思路</em></p>
<p>本题与常规提不同，查询的是边的权值。碰到这种情况我们通常把边权值赋到较低的节点上，转换成点的问题。本题还闲得蛋疼卡string和cin，需要注意。</p>
<span id="more"></span>
<p><em>代码：</em><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1|1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10005</span>;</span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; v[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f, t, val;</span><br><span class="line">&#125;EDGES[MAXN];</span><br><span class="line"><span class="keyword">int</span> tid[MAXN * <span class="number">2</span>], dep[MAXN * <span class="number">2</span>], fa[MAXN * <span class="number">2</span>], son[MAXN*<span class="number">2</span>],sizes[MAXN*<span class="number">2</span>],top[MAXN*<span class="number">2</span>],label,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxsize = <span class="number">0</span>;</span><br><span class="line">    fa[root] = father, dep[root] = depth, sizes[root] = <span class="number">1</span>,son[root]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator it = v[root].<span class="built_in">begin</span>();it != v[root].<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;first == father)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(it-&gt;first, root, depth + <span class="number">1</span>);</span><br><span class="line">        sizes[root] += sizes[it-&gt;first];</span><br><span class="line">        <span class="keyword">if</span> (sizes[it-&gt;first] &gt; maxsize)maxsize = sizes[it-&gt;first], son[root] = it-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father, <span class="keyword">int</span> ancestor)</span> </span>&#123;</span><br><span class="line">    tid[root] = ++label,top[root]=ancestor;</span><br><span class="line">    <span class="keyword">if</span> (son[root]!=<span class="number">0</span>)<span class="built_in">dfs2</span>(son[root], root, ancestor);</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator it = v[root].<span class="built_in">begin</span>();it != v[root].<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;first == father || it-&gt;first == son[root])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(it-&gt;first, root, it-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tree[MAXN * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r&amp;&amp;l == pos) tree[root] = val;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid)<span class="built_in">update</span>(root * <span class="number">2</span>, l, mid, pos, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(root * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, pos, val);</span><br><span class="line">        tree[root] = <span class="built_in">max</span>(tree[root * <span class="number">2</span>], tree[root * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql,<span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l&amp;&amp;qr &gt;= r)<span class="keyword">return</span> tree[root];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (qr &lt;= mid)<span class="keyword">return</span> <span class="built_in">query</span>(root * <span class="number">2</span>, l, mid, ql, qr);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ql &gt; mid)<span class="keyword">return</span> <span class="built_in">query</span>(root * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(root * <span class="number">2</span>, l, mid, ql, qr), <span class="built_in">query</span>(root * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = x, j = y,maxs=-INF;</span><br><span class="line">    <span class="keyword">while</span> (top[i] != top[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[i]] &lt; dep[top[j]])<span class="built_in">swap</span>(i, j);</span><br><span class="line">        maxs=<span class="built_in">max</span>(maxs,<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, tid[top[i]], tid[i]));</span><br><span class="line">        i = fa[top[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == j)<span class="keyword">return</span> maxs;</span><br><span class="line">    <span class="keyword">if</span> (dep[i] &gt; dep[j])<span class="built_in">swap</span>(i, j);</span><br><span class="line">    maxs = <span class="built_in">max</span>(maxs, <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, tid[son[i]], tid[j]));</span><br><span class="line">    <span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> k,f,t,val,pos,left,right;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">105</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">while</span> (k--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAXN;i++)v[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">ms</span>(tid, <span class="number">0</span>), <span class="built_in">ms</span>(dep, <span class="number">0</span>), <span class="built_in">ms</span>(fa, <span class="number">0</span>), <span class="built_in">ms</span>(son, <span class="number">0</span>), <span class="built_in">ms</span>(sizes, <span class="number">0</span>), <span class="built_in">ms</span>(top, <span class="number">0</span>), <span class="built_in">ms</span>(tree,<span class="number">-1</span>);</span><br><span class="line">        label = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;f, &amp;t, &amp;val);</span><br><span class="line">            v[f].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(t, val)), v[t].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(f, val));</span><br><span class="line">            EDGES[i] = &#123; f,t,val &#125;;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//update(1, 1, n, tid[1], -INF);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = dep[EDGES[i].f] &gt; dep[EDGES[i].t] ? tid[EDGES[i].f] : tid[EDGES[i].t];</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, u, EDGES[i].val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str)!=EOF) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;D&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;pos, &amp;val);</span><br><span class="line">                <span class="keyword">int</span> u = dep[EDGES[pos<span class="number">-1</span>].f] &gt; dep[EDGES[pos<span class="number">-1</span>].t] ? tid[EDGES[pos - <span class="number">1</span>].f] : tid[EDGES[pos - <span class="number">1</span>].t];</span><br><span class="line">                <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, u, val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;left, &amp;right);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(left, right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>树链剖分</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>System Design Notes</title>
    <url>/2021/03/17/System%20Design%20Notes/</url>
    <content><![CDATA[<p>系统设计笔记，自用。<br><span id="more"></span></p>
<h1 id="系统设计的大致流程"><a href="#系统设计的大致流程" class="headerlink" title="系统设计的大致流程"></a>系统设计的大致流程</h1><p>系统设计的流程可以大致分为以下的步骤：</p>
<h2 id="1-需求分类"><a href="#1-需求分类" class="headerlink" title="1. 需求分类"></a>1. 需求分类</h2><p>由于在面试时我们只有30-40分钟的时间，所以知道准确的需求是必要的。比如设计一个类推特软件，我们要知道：</p>
<ol>
<li>用户要推送推文或关注其他用户吗？</li>
<li>我们是否需要用户时间线功能？</li>
<li>推文是否有图片或视频？</li>
<li>只制作后端还是前后端同时？</li>
<li>需要搜索功能吗？</li>
<li>需要热搜榜吗？</li>
<li>是否需要对重要推文进行推送？</li>
</ol>
<h2 id="2-系统接口定义"><a href="#2-系统接口定义" class="headerlink" title="2. 系统接口定义"></a>2. 系统接口定义</h2><p>通过定义API,我们能够知道系统需要包含什么，同时能够确认是否搞错了需求。我们设计一个类推特软件时，接口会像这样：</p>
<ul>
<li>postTweet(user_id, tweet_data, tweet_location, user_location, timestamp,…)</li>
<li>generateTimeline(user_id, current_time, user_location…)</li>
<li>markTweetFavourite(user_id, tweet_id, timestamp…)</li>
</ul>
<h2 id="3-规模估算"><a href="#3-规模估算" class="headerlink" title="3. 规模估算"></a>3. 规模估算</h2><p>在设计系统前了解问题的规模是非常有帮助的，能帮助我们了解系统规模，系统划分，负载均衡和缓存策略。</p>
<ul>
<li>系统的期望规模（推文篇数，推文的阅读数，我们每秒需要设计多少时间轴等）</li>
<li>储存空间的大小是多少？（当我们允许用户发送带图片的推文时，需要的存储空间是不同的）</li>
<li>带宽是多少？（这能帮我们决定我们怎样管理服务器网络和负载均衡。）</li>
</ul>
<h2 id="4-定义数据模型"><a href="#4-定义数据模型" class="headerlink" title="4. 定义数据模型"></a>4. 定义数据模型</h2><p>定义数据模型能让我们知道系统中数据是怎么流动的。这能帮我们划分和管理数据。在定义数据模型时，最好我们能够通过数据模型了解到系统中有多少实体（表名的划分），知道数据如何交互（外键，多对多对应表），还有不同的数据管理策略如储存，传输，加密（密码）等。如果实现一个类推特我们可以这样设计：</p>
<ul>
<li>User: UserID, Name, Email, DoB, CreationData, LastLogin, etc</li>
<li>Tweet: TweetID, Content, TweetLocation, NumberOfLikes, TimeStamp, etc</li>
<li>UserFollow: UserID1, UserID2</li>
<li>FavouriteTweets: UserID, TweetID, TimeStamp</li>
</ul>
<p>设计时我们就要考虑：我们用什么数据库系统？用MySQL固然是传统的选择，但是noSQL是否更好（noSQL在多对多上查询很方便，mysql需要查多张表）？我们是否需要固定的空间存储照片和视频？</p>
<h2 id="5-高级设计"><a href="#5-高级设计" class="headerlink" title="5. 高级设计"></a>5. 高级设计</h2><p>现在我们应该画一个框图来确定我们需要实现哪些功能模块。<br><br>比如对于推特来说，我们需要多个程序/服务器来满足读写请求，同时在信息流前设置负载均衡。如果我们认为读请求相对写请求比较多的话，我们就应该让不同的服务器来分别处理读写请求（mysql读写分离）。在后端，我们需要一个高效的数据库来储存所有推文，同时支持大量写请求。我们还需要一个分布式的文件系统来保存照片和视频。<br><img src="https://i.loli.net/2021/03/16/F2hvKlQWpwuoHOb.png" alt="1-highlevel-design.png"></p>
<h2 id="6-细节设计"><a href="#6-细节设计" class="headerlink" title="6. 细节设计"></a>6. 细节设计</h2><p>在与面试官的交流中，我们会知道他希望我们能够更加深入讨论哪些部分。此时，我们应当能够展示不同的架构，他们的优点缺点，以及为什么我们选择其中一个而不是另一个。系统设计没有固定答案，不同的条件下，我们要做出不同的选择。</p>
<ul>
<li>在大量数据下，我们是否需要进行分库分表？我们需要将所有数据保存在同一个数据库吗？这会导致什么问题？</li>
<li>我们要怎么处理大量发帖或大量关注的用户？（多对多需要维护一张过渡表，该表只有两列，但行数很多）</li>
<li>想象一下翻阅朋友圈的场景，我们通常翻阅的总是最新的推文，所以不难想到用户请求的推文大部分是最新的（或者相关的）推文，我们是否应该对数据进行优化来加快读取最新推文的速度？</li>
<li>我们应该使用多少缓存，在哪里使用缓存来加速浏览？</li>
<li>哪个部分需要更多负载均衡？</li>
</ul>
<h2 id="7-找到并解决系统的性能瓶颈"><a href="#7-找到并解决系统的性能瓶颈" class="headerlink" title="7. 找到并解决系统的性能瓶颈"></a>7. 找到并解决系统的性能瓶颈</h2><ul>
<li>这个系统存在单点失效吗？（这个服务器宕机整个服务失效）我们要怎么避免单点失效？</li>
<li>我们是否有足够用户数据备份，使得即便一部分服务器失效，我们依然能够提供服务？</li>
<li>相似的，我们是否有足够的服务备份，在一部分服务失效时，仍能用备份服务顶上？</li>
<li>我们要怎么监控服务的性能？能否获得预警？能否在系统关键模块出错或效率降低时得到警告？</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，提前准备与良好的行动框架，是系统设计面试的关键。不论处理什么系统设计问题，都应当遵循这个流程。</p>
<h1 id="设计一个短链接服务"><a href="#设计一个短链接服务" class="headerlink" title="设计一个短链接服务"></a>设计一个短链接服务</h1><h2 id="我们为什么需要短链接服务？"><a href="#我们为什么需要短链接服务？" class="headerlink" title="我们为什么需要短链接服务？"></a>我们为什么需要短链接服务？</h2><p>将形如<br></p>
<blockquote>
<p><a href="https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904/">https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904/</a></p>
</blockquote>
<p>转为</p>
<blockquote>
<p><a href="http://tinyurl.com/jlg8zpc">http://tinyurl.com/jlg8zpc</a></p>
</blockquote>
<p>这能够帮助我们避免字数限制（微博），隐藏来源网站（网站链接分享限制），特定页面统计（短链接提供的功能）。</p>
<h2 id="系统需求和目标"><a href="#系统需求和目标" class="headerlink" title="系统需求和目标"></a>系统需求和目标</h2><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ol>
<li>对于给定的URL,我们的服务应该能够返回一个更短的链接，同时这个链接有它独一无二的标识。（通常格式是第三方网站地址/压缩后标识）</li>
<li>当用户访问我们提供的短链接，我们需要将其重定向原本的网址</li>
<li>用户应当能够选择定制独特的短链接</li>
<li>在一定时间后，短链接应该会过期。用户应当能够自主选择合适的过期时间</li>
</ol>
<h3 id="非功能需求"><a href="#非功能需求" class="headerlink" title="非功能需求"></a>非功能需求</h3><ol>
<li>这个系统应当是高可用的，否则如果无门无法提供服务，所有的URL重定向都会失效</li>
<li>URL重定向应当尽可能实时，以最小的延迟实现。</li>
<li>短链不应当是能被猜出来原意的</li>
</ol>
<h3 id="拓展需求"><a href="#拓展需求" class="headerlink" title="拓展需求"></a>拓展需求</h3><ol>
<li>分析 比如对一个短链来说，重定向发生了多少次</li>
<li>我们的服务应当是Restful API的形式，方便其他服务访问。</li>
</ol>
<h2 id="资源占用和限制"><a href="#资源占用和限制" class="headerlink" title="资源占用和限制"></a>资源占用和限制</h2><p>整个系统是读频繁系统。我们假定读：写需求比例为100：1.</p>
<h3 id="并发估计"><a href="#并发估计" class="headerlink" title="并发估计"></a>并发估计</h3><p>假定我们每月有5亿URL短链转化需求，那么根据读写需求比例，我们可以知道每月会有500亿短链重定向需求。那么QPS（query per second）就是200URLs/s。而重定向需求是20000次/秒。</p>
<h3 id="储存需求"><a href="#储存需求" class="headerlink" title="储存需求"></a>储存需求</h3><p>对于一个五年周期，由于我们每月有5亿URL短链转化需求，所以5年有300亿累计需求。假定每条记录需要500字节存储，我们就需要15TB来储存这些数据。</p>
<h3 id="带宽估计"><a href="#带宽估计" class="headerlink" title="带宽估计"></a>带宽估计</h3><p>对于写请求，因为我们估计每秒有200个URL短链转化需求，每条500字节，所以写入带宽需要在100KB/s左右。对于读请求来说，则是10MB/s左右。</p>
<h3 id="内存估计"><a href="#内存估计" class="headerlink" title="内存估计"></a>内存估计</h3><p>如果我们想储存一些被访问次数较多的“热点数据”，我们需要多少内存？按照2-8定律，我们会缓存20%的热点短链接。因为我们每秒重定向20000次，我们一天会有17亿次请求。所以乘以20%再乘以500字节，所需要的储存空间是170GB.值得一提的是由于有很多重复请求，最后我们用不到170GB.</p>
<h3 id="最终估计"><a href="#最终估计" class="headerlink" title="最终估计"></a>最终估计</h3><p>因此，我们知道这个服务需要：</p>
<ul>
<li>新短链接请求：200/s</li>
<li>URL重定向：20000/s</li>
<li>写带宽：100KB/s</li>
<li>读带宽：10MB/s</li>
<li>5年所需储存空间：15TB</li>
<li>内存：170GB</li>
</ul>
<h2 id="系统API"><a href="#系统API" class="headerlink" title="系统API"></a>系统API</h2><p>这时候，我们就能设计一个REST api了。</p>
<h3 id="createURL-api-dev-key-original-url-custom-alias-None-user-name-None-expire-date-None"><a href="#createURL-api-dev-key-original-url-custom-alias-None-user-name-None-expire-date-None" class="headerlink" title="createURL(api_dev_key, original_url, custom_alias=None, user_name=None, expire_date=None)"></a>createURL(api_dev_key, original_url, custom_alias=None, user_name=None, expire_date=None)</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>api_dev_key(string):</strong> 开发者key,主要是方便记录用户的使用次数，计算配额。<br><br><strong>original_url(string):</strong> 需要缩短的url<br><br><strong>custom_alias(string):</strong> URL定制变量（可选）<br><br><strong>user_name(string:</strong> 用户名（可选）<br><br><strong>expire_date(string):</strong> 短链接的过期时间<br></p>
<h4 id="返回值-string"><a href="#返回值-string" class="headerlink" title="返回值(string)"></a>返回值(string)</h4><p>成功返回短链接地址，否则返回错误代码。</p>
<h3 id="deleteURL-api-dev-key-url-key"><a href="#deleteURL-api-dev-key-url-key" class="headerlink" title="deleteURL(api_dev_key, url_key)"></a>deleteURL(api_dev_key, url_key)</h3><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p><strong>api_dev_key(string):</strong> 开发者key,主要是方便记录用户的使用次数，计算配额。<br><br><strong>url_key(string)</strong> 需要修改的短链接。</p>
<h3 id="怎样避免API滥用？"><a href="#怎样避免API滥用？" class="headerlink" title="怎样避免API滥用？"></a>怎样避免API滥用？</h3><p>恶意用户会将我们的所有URL全部耗尽，所以我们需要通过api_dev_key限制用户。每个key只能访问特定次数的服务，同时在一个时间段内，只能进行有限的重定向（避免服务过载）。</p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>通过之前的研究我们能发现：</p>
<ol>
<li>我们需要储存上10亿的数据</li>
<li>每个数据单元都很小（不足1K）</li>
<li>除了哪个用户创造了这个短链接，在表之前没有其他的关系（1对多，多对多）</li>
<li>我们的服务是读频繁服务</li>
</ol>
<h3 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h3><h4 id="URL表"><a href="#URL表" class="headerlink" title="URL表"></a>URL表</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列名</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HashURL</td>
<td style="text-align:center">varchar(16)</td>
<td style="text-align:center">主键</td>
</tr>
<tr>
<td style="text-align:center">OriginalURL</td>
<td style="text-align:center">varchar(512)</td>
<td style="text-align:center">非空</td>
</tr>
<tr>
<td style="text-align:center">CreationDate</td>
<td style="text-align:center">datetime</td>
<td style="text-align:center">非空</td>
</tr>
<tr>
<td style="text-align:center">ExpirationDate</td>
<td style="text-align:center">datetime</td>
<td style="text-align:center">非空</td>
</tr>
<tr>
<td style="text-align:center">UserId</td>
<td style="text-align:center">int</td>
<td style="text-align:center">外键</td>
</tr>
</tbody>
</table>
</div>
<h4 id="User表"><a href="#User表" class="headerlink" title="User表"></a>User表</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列名</th>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UserId</td>
<td style="text-align:center">int</td>
<td style="text-align:center">主键</td>
</tr>
<tr>
<td style="text-align:center">Name</td>
<td style="text-align:center">varchar(20)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Email</td>
<td style="text-align:center">varchar(32)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">CreationDate</td>
<td style="text-align:center">datetime</td>
<td style="text-align:center">非空</td>
</tr>
<tr>
<td style="text-align:center">LastLogin</td>
<td style="text-align:center">datetime</td>
<td style="text-align:center">非空</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>工程</category>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>System Design</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA - 10048 Audiophobia</title>
    <url>/2017/11/01/UVA%20-%2010048%20Audiophobia/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="最小瓶颈路"><a href="#最小瓶颈路" class="headerlink" title="最小瓶颈路"></a>最小瓶颈路</h4><p>给定两个点u,v求两点间路径上最大边权最小，这就是最小瓶颈路问题。</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>对于最小瓶颈路，我们通常有两种解法：</p>
<ol>
<li>Floyd<br>通过将原先dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j])改为dp[i][j]=min(dp[i][j],max(dp[i][k],dp[k][j]))来计算，复杂度O(n^3)</li>
<li>最小生成树<br>通过观察Kruskal算法的过程我们显然能够发现最小瓶颈路在最小生成树上。对于单点查询dfs就可解决问题。如果多次查询可以使用类似Floyd的处理。对于本题，我们可以离线询问，然后每次判断询问的两点是否已经相连，如果相连那么现在加入的边就是我们要求的边。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson(x) (x&lt;&lt;1+1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> c, s, q;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">105</span>], ranks[<span class="number">105</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, v, val;</span><br><span class="line">	<span class="built_in">edge</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val) :<span class="built_in">u</span>(u), <span class="built_in">v</span>(v), <span class="built_in">val</span>(val) &#123;&#125;;</span><br><span class="line">&#125;E[<span class="number">1005</span>];</span><br><span class="line"><span class="comment">//vector&lt;pair&lt;int,int&gt;&gt; G[105];</span></span><br><span class="line">vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; qu;</span><br><span class="line">map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; dict;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge e1, edge e2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> e1.val &lt; e2.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_union</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= c;i++) &#123;</span><br><span class="line">		fa[i] = i, ranks[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fa[x] == x)<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> fa[x] = <span class="built_in">getfa</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getfa</span>(i) == <span class="built_in">getfa</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="built_in">getfa</span>(i), b = <span class="built_in">getfa</span>(j);</span><br><span class="line">	<span class="keyword">if</span> (a == b)<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (ranks[a] &lt; ranks[b]) &#123;</span><br><span class="line">			fa[a] = b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			fa[b] = a;</span><br><span class="line">			<span class="keyword">if</span> (ranks[a] == ranks[b])ranks[a]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">init_union</span>();</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(E, E + s, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">same</span>(E[i].u, E[i].v)) &#123;</span><br><span class="line">			ans += E[i].val;</span><br><span class="line">			<span class="built_in">unite</span>(E[i].u, E[i].v);</span><br><span class="line">			<span class="comment">//G[E[i].u].push_back(make_pair(E[i].v, E[i].val)), G[E[i].v].push_back(make_pair(E[i].u, E[i].val));</span></span><br><span class="line">			<span class="keyword">for</span> (map&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;::iterator it = dict.<span class="built_in">begin</span>();it != dict.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">				<span class="keyword">int</span> fi = it-&gt;first.first, se = it-&gt;first.second;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">same</span>(fi, se) &amp;&amp; !it-&gt;second)it-&gt;second = E[i].val;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*void dfs(int index) &#123;</span></span><br><span class="line"><span class="comment">	vis[index] = 1;</span></span><br><span class="line"><span class="comment">	for (vector&lt;pair&lt;int,int&gt;&gt;::iterator it = G[index].begin();it != G[index].end();it++) &#123;</span></span><br><span class="line"><span class="comment">		int to = it-&gt;first;</span></span><br><span class="line"><span class="comment">		if (!vis[to]) &#123;</span></span><br><span class="line"><span class="comment">			for (int i = 1;i &lt;= c;i++) &#123;</span></span><br><span class="line"><span class="comment">				if (vis[i]) &#123;</span></span><br><span class="line"><span class="comment">					dp[i][to] = dp[to][i] = max(dp[i][index], it-&gt;second);</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			dfs(to);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> u, v, val,cal=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; c &gt;&gt; s &gt;&gt; q) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="number">0</span> &amp;&amp; s == <span class="number">0</span> &amp;&amp; q == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s;i++) &#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;</span><br><span class="line">			<span class="function">edge <span class="title">e</span><span class="params">(u, v, val)</span></span>;</span><br><span class="line">			E[i] = e;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; q;i++) &#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			qu.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u, v));</span><br><span class="line">			dict[<span class="built_in">make_pair</span>(u, v)] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">kruskal</span>();</span><br><span class="line">		<span class="keyword">if</span> (cal)cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; cal + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator it = qu.<span class="built_in">begin</span>();it != qu.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">			<span class="keyword">int</span> ans = dict[*it];</span><br><span class="line">			<span class="keyword">if</span> (!ans)cout &lt;&lt; <span class="string">&quot;no path\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cal++;</span><br><span class="line">		qu.<span class="built_in">clear</span>(),dict.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA - 10534 Wavio Sequence</title>
    <url>/2018/03/01/UVA%20-%2010534%20Wavio%20Sequence/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>LIS变形，本来想O(n^2)暴力踩10^8结果TLE的悲伤故事，所以学习了一下O(nlogn)的LIS求法。<br>对于最朴素的做法我们使用dp在n^2时间可以求出一个数列的LIS，程序如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN],maxs=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));   <span class="comment">//假装可以这么写</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;dp[j])dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    maxs=<span class="built_in">max</span>(dp[i],maxs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然而我们还有更机智的做法。考虑维护一个单调增的数列q[MAXN],令一个计数器cnt=0，我们从头扫到尾，然后会有两种情况:</p>
<ol>
<li>!cnt||a[i]&gt;q[cnt-1],那我们直接在数列尾部加上a[i]，得到的数列就是当前最大公共子序列</li>
<li>不然我们能得到a[i]小于等于q数组最后一个元素。我们在这里对q进行二分查找，找到第一个大于等于a[i]的数然后<strong>将该位置的数替换为a[i]</strong>。</li>
</ol>
<p>这样就能nlogn求出数列的LIS，我们维护1-i的递增子序列长度和i-n的递减子序列长度然后处理即可。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN],dp1[MAXN],dp2[MAXN],q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">		<span class="keyword">int</span> maxs=<span class="number">-1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">ms</span>(q,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!cnt||q[cnt<span class="number">-1</span>]&lt;a[i])q[cnt++]=a[i],dp1[i]=cnt;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> pos=<span class="built_in">lower_bound</span>(q,q+cnt,a[i])-q;</span><br><span class="line">                q[pos]=a[i];</span><br><span class="line">                dp1[i]=pos+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		maxs=<span class="number">-1</span>;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!cnt||q[cnt<span class="number">-1</span>]&lt;a[i])q[cnt++]=a[i],dp2[i]=cnt;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> pos=<span class="built_in">lower_bound</span>(q,q+cnt,a[i])-q;</span><br><span class="line">                q[pos]=a[i];</span><br><span class="line">                dp2[i]=pos+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		maxs=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;dp1[i]&lt;&lt;&quot; &quot;&lt;&lt;dp2[i]&lt;&lt;endl;</span></span><br><span class="line">            maxs=<span class="built_in">max</span>(maxs,<span class="number">2</span>*<span class="built_in">min</span>(dp1[i],dp2[i])<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>LIS</category>
      </categories>
      <tags>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA - 12018 Juice Extractor(dp)</title>
    <url>/2018/05/19/UVA%20-%2012018%20Juice%20Extractor(dp)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先对水果按出现时间为第一关键字，消失时间为第二关键字来排序。dp[i]为当物品i出现时将它及它之前的水果全切完的最大价值。转移时第一重循环顺序枚举物品，设置一个计数器记录从i水果到第二重循环的那个水果之间有几个还在空中。第二重循环从当前物品往前找，每当发现其还在空中时计数器++。然后就是dp[i]=max(dp[i],dp[j-1]+cnt&gt;2?cnt:0)来转移。这里要注意的一点是如果左端点重合的区间要取数组中最左边的一个区间，因为题意要求我们对在空中的水过一次切完不能有剩，不这样做的话可能会让结果的答案变大。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node n1)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==n1.left)<span class="keyword">return</span> right&lt;n1.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left&lt;n1.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">1</span>;z&lt;=T;z++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,left,right,maxs=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;arr[i].left,&amp;arr[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[<span class="number">0</span>].left=arr[<span class="number">0</span>].right=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(arr+<span class="number">1</span>,arr+n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">ms</span>(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j].right&gt;=arr[i].left)cnt++;</span><br><span class="line">                <span class="keyword">if</span>(arr[j<span class="number">-1</span>].left!=arr[j].left&amp;&amp;cnt&gt;<span class="number">2</span>)dp[i]=<span class="built_in">max</span>(dp[i],dp[j<span class="number">-1</span>]+cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            maxs=<span class="built_in">max</span>(maxs,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,z,maxs);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>线性dp</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA - 13250 Balance Game(扩展欧几里得)</title>
    <url>/2018/05/26/UVA%20-%2013250%20Balance%20Game(%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们要解的一个方程是ax+by+cz=w。显然枚举是O(n^3)会超时，生成函数无法解决x,y,z是负数的情况。注意到m的范围只有5000，所以考虑将方程转化为ax+by=w-cz然后枚举z(-5000,5000)再跑extgcd。由于x*(res/gcds)+k*b/gcds,y*(res/gcds)-k*a/gcds都属于[-m,m]，我们能得到两个k的范围，它们的交集长度的累加就是答案。时间复杂度O(nlogn)<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">extgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    ll d=a;</span><br><span class="line">    <span class="keyword">if</span>(b)&#123;</span><br><span class="line">        d=<span class="built_in">extgcd</span>(b,a%b,y,x);</span><br><span class="line">        y-=(a/b)*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getBound</span><span class="params">(ll b,ll g,ll l,ll r,ll &amp;low,ll &amp;high)</span></span>&#123;</span><br><span class="line">    <span class="comment">// compute l &lt;= b + g * k &lt;= r, k in [lk, rk]</span></span><br><span class="line">    <span class="keyword">if</span> (g &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		low = <span class="built_in">ceil</span>((<span class="keyword">double</span>) (l-b)/g);</span><br><span class="line">		high = <span class="built_in">floor</span>((<span class="keyword">double</span>) (r-b)/g);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		low = <span class="built_in">ceil</span>((<span class="keyword">double</span>) (r-b)/g);</span><br><span class="line">		high = <span class="built_in">floor</span>((<span class="keyword">double</span>) (l-b)/g);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll a,ll b,ll res,ll n)</span></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    ll gcds=<span class="built_in">extgcd</span>(a,b,x,y);</span><br><span class="line">    <span class="keyword">if</span>(res%gcds)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll lowa,higha,lowb,highb;</span><br><span class="line">    <span class="built_in">getBound</span>(x*(res/gcds),b/gcds,-n,n,lowa,higha);</span><br><span class="line">    <span class="keyword">if</span>(lowa&gt;higha)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">getBound</span>(y*(res/gcds),-a/gcds,-n,n,lowb,highb);</span><br><span class="line">    <span class="keyword">if</span>(lowb&gt;highb)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    lowa=<span class="built_in">max</span>(lowa,lowb);</span><br><span class="line">    higha=<span class="built_in">min</span>(higha,highb);</span><br><span class="line">    <span class="keyword">return</span> higha-lowa+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll m,w,n1,n2,n3;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;m,&amp;w))&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n1,&amp;n2,&amp;n3);</span><br><span class="line">        <span class="keyword">if</span>(n1&lt;n2)<span class="built_in">swap</span>(n1,n2);</span><br><span class="line">        <span class="keyword">if</span>(n1&lt;n3)<span class="built_in">swap</span>(n1,n3);</span><br><span class="line">        <span class="keyword">for</span>(ll i=-m;i&lt;=m;i++)&#123;</span><br><span class="line">            ll tw=w+i*n1;</span><br><span class="line">            <span class="keyword">if</span>(tw&gt;=-m*(n2+n3)&amp;&amp;tw&lt;=m*(n2+n3))&#123;</span><br><span class="line">                ans+=<span class="built_in">solve</span>(n2,n3,tw,m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>扩展欧几里得</category>
      </categories>
      <tags>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>SGU - 101 Domino(欧拉路径)</title>
    <url>/2018/08/17/SGU%20-%20101%20Domino(%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题意是给你n个多米诺骨牌，骨牌的两面都有数字，要求你找出一个放置序列使得相邻两个骨牌相对的两面数字相同。注意到如果我们以数字为点（0-7），同时以骨牌建边的话，那么这个问题就是一个欧拉路径问题。欧拉路径是否存在可以用是否所有点度数都是偶数或者图中是否仅有两个奇数度的点这种方法来判定，注意本题的No solution还有图不连通的可能性，要特别判断。在完成欧拉路径是否存在的判定后，我们考虑如何输出路径。我们不能dfs暴力尝试，这样的复杂度显然是不能接受的。看了题解后学习到了一个全新的fleury算法，时间复杂度O(m)，即将所有边遍历一次。<br>hihocoder上的伪代码，如果有奇数度的点，我们从奇数度的点开始dfs，否则任取一个出现过的点。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DFS</span>(u):</span><br><span class="line">	<span class="built_in">While</span> (u存在未被删除的边<span class="built_in">e</span>(u,v))</span><br><span class="line">		删除边<span class="built_in">e</span>(u,v)</span><br><span class="line">		<span class="built_in">DFS</span>(v)</span><br><span class="line">	End</span><br><span class="line">	PathSize ← PathSize + <span class="number">1</span></span><br><span class="line">	Path[ PathSize ] ← u</span><br></pre></td></tr></table></figure><br>这样做为什么是正确的？想象一下我们dfs第一次终止的时候是什么样的，当有两个奇数度的点的时候，这样一条链显然是从一个奇数度点到另外一个奇数度的点（偶数时候可以随便取两个点，本质上其实是这个链形成了一个环），而其他的点可以看作一个一个在链上的环（因为我们已经知道了图中一定有一个欧拉路径）。知道了这个我们在dfs回退时记录一下边（见伪代码），就相当于从链回退，进入环，退出环，继续沿链回退的过程，最终我们得到的就是该图的欧拉路径。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://hihocoder.com/problemset/problem/1181">hihocoder-欧拉路·二</a><br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10</span>,MAXM=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],nxt[MAXM],to[MAXM],vis[MAXM],dir[MAXM],id[MAXM],edgecnt;</span><br><span class="line"><span class="keyword">int</span> sta[MAXM][<span class="number">2</span>],total;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w,<span class="keyword">int</span> tid)</span></span>&#123;</span><br><span class="line">    to[edgecnt]=v;</span><br><span class="line">    dir[edgecnt]=w;</span><br><span class="line">    id[edgecnt]=tid;</span><br><span class="line">    nxt[edgecnt]=head[u];</span><br><span class="line">    head[u]=edgecnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fleury</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];~i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            vis[i]=vis[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">fleury</span>(to[i]);</span><br><span class="line">            sta[total][<span class="number">0</span>]=id[i];</span><br><span class="line">            sta[total++][<span class="number">1</span>]=dir[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">ms</span>(cnt,<span class="number">0</span>),<span class="built_in">ms</span>(vis,<span class="number">0</span>),<span class="built_in">ms</span>(head,<span class="number">-1</span>);</span><br><span class="line">        edgecnt=<span class="number">0</span>,total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            <span class="built_in">addedge</span>(u,v,<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">addedge</span>(v,u,<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">            cnt[u]++,cnt[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>||sum==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((!sum&amp;&amp;cnt[i])||(sum==<span class="number">2</span>&amp;&amp;cnt[i]%<span class="number">2</span>==<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="built_in">fleury</span>(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(total!=n)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No solution\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d %c\n&quot;</span>,sta[i][<span class="number">0</span>],sta[i][<span class="number">1</span>]?<span class="string">&#x27;-&#x27;</span>:<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No solution\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>欧拉路径</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>UVALive - 8488 Suffix(二分+hash)</title>
    <url>/2018/08/23/UVALive%20-%208488%20Suffix(%E4%BA%8C%E5%88%86+hash)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们可以首先取最后一个字符串字典序最小的后缀，然后把它接到前一个串的后面，再求这个串字典序最小的后缀，不断重复以上操作我们就能得到题目需要的字符串。其正确性可以用反证法证明：假设我们最后一个字符串不取字典序最小的后缀，那么我们一定能通过替换最小的后缀来得到一个更小的字符串，与原串是字典序最小的字符串矛盾。但这样的时间复杂度是O(n^2)的(字符串比较O(n))，我们期望的是一个O(nlogn)的算法。注意到我们取的过程是从最后一个字符慢慢往前走，如果我们保存每个位置的hash值（这里hash的方法需要是Hash=Hash*seed+letter），然后通过现在的hash值减之前的hash值乘以偏移量，那么我们就能得到一段前缀的hash值，也就是可以O(1)的比较一段前缀是否相等。因此我们可以想到二分前缀的长度（显然具有单调性），通过上述hash的方法来得到两个字符串最长的LCP。知道了两个字符串最长的公共前缀后，我们只要比较最长公共前缀后面的第一个字符即可比较两个字符串的大小。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTINF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLINF 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;a%=MOD;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1ll</span>)ans=ans*a%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MAXN=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">const</span> ll seed=<span class="number">131</span>;</span><br><span class="line">string str[MAXN];</span><br><span class="line"><span class="keyword">char</span> ans[MAXN];</span><br><span class="line">ull len[MAXN],hashVal[MAXN],po[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lb=<span class="number">0</span>,ub=pos;</span><br><span class="line">    <span class="keyword">while</span>(lb&lt;=ub)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(lb+ub)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        ull num1=hashVal[now]-hashVal[now-mid]*po[mid],num2=hashVal[pos]-hashVal[pos-mid]*po[mid];</span><br><span class="line">        <span class="keyword">if</span>(num1==num2)lb=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ub=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lb==pos+<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans[now-ub<span class="number">-1</span>]&lt;ans[pos-ub<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    po[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)po[i]=po[i<span class="number">-1</span>]*seed;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">ms</span>(hashVal,<span class="number">0</span>);</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            cin&gt;&gt;str[i];</span><br><span class="line">            len[i]=str[i].<span class="built_in">length</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ans[pans]=str[i][len[i]<span class="number">-1</span>];</span><br><span class="line">            hashVal[pans+<span class="number">1</span>]=hashVal[pans]*seed+str[i][len[i]<span class="number">-1</span>];</span><br><span class="line">            pans++;</span><br><span class="line">            <span class="keyword">int</span> pnow=pans;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=len[i]<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                ans[pnow]=str[i][j];</span><br><span class="line">                hashVal[pnow+<span class="number">1</span>]=hashVal[pnow]*seed+str[i][j];</span><br><span class="line">                pnow++;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(pnow,pans))&#123;</span><br><span class="line">                    pans=pnow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=pans<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;ans[i];</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
        <category>Hash</category>
      </categories>
      <tags>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>View的动态添加-Android</title>
    <url>/2021/07/31/View%E7%9A%84%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0-Android/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2021/07/31/PvN6kAniyt41OLd.png" alt="android11.png"><br>Android 11 (Image credit: Shutterstock / TechRadar)</p>
<p>在安卓小列表展示的情况下，我们应该使用什么样的UI结构？使用写死的xml？很容易缺乏灵活性，如果列表变动就会需要更改多个模块。使用recycleview？虽然拥有灵活性但是太重，有杀鸡用牛刀之感。在实习的过程中我就碰到了这样的问题，通过同事的指点学习了为视图动态添加view的方式。在学习的过程中，我发现相关的文章相对较少，而且很多文章是在kotlin/java文件中添加布局，而不是xml文件，灵活性相对较差。所以在此与大家分享这个问题上我的实践方式。</p>
<span id="more"></span>
<h1 id="布局文件"><a href="#布局文件" class="headerlink" title="布局文件"></a>布局文件</h1><p>在动态生成布局的时候，我们应当使用一个诸如LinearLayout或是ConstraintLayout作为我们动态视图的容器。这样能够很方便定位动态view的位置。同时，这给我们kotlin代码中确定父视图提供了方便。注意不要使用EditText或是TextView，当然我觉得大部分人不会无聊到想测试安卓代码的鲁棒性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--activity_main.xml--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/test_title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/test_title&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--The Container--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/test_container&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述的布局文件中，test_container就是我们的父容器。接下来就是动态view的布局。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--view_item.xml--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;260dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;50dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;20dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@color/grey&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_avatar&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;36dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;36dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@drawable/samira&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/test_title&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/item_test_content&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述的很多地方都可以根据需求灵活地改变，但是有两点是确定的：我们需要有一个父容器，以及一个子容器的xml布局。</p>
<h1 id="在Kotlin文件中结合父子布局"><a href="#在Kotlin文件中结合父子布局" class="headerlink" title="在Kotlin文件中结合父子布局"></a>在Kotlin文件中结合父子布局</h1><p>既然布局文件很简单，那么很多的工作就是在Kotlin中完成了。下面首先是完整代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> championConfig: MutableList&lt;ChampionConfig&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        initChampionConfig()</span><br><span class="line">        <span class="comment">// 获取父容器</span></span><br><span class="line">        <span class="keyword">val</span> container = findViewById&lt;LinearLayout&gt;(R.id.test_container)</span><br><span class="line">        <span class="keyword">for</span>(config <span class="keyword">in</span> championConfig)&#123;</span><br><span class="line">            <span class="comment">// 动态加载子项，并挂载到父容器</span></span><br><span class="line">            <span class="keyword">val</span> v: View = layoutInflater.inflate(R.layout.view_item,container, <span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">val</span> avatar = v.findViewById&lt;ImageView&gt;(R.id.item_avatar)</span><br><span class="line">            avatar.setImageResource(config.avatarId)</span><br><span class="line">            <span class="keyword">val</span> championName = v.findViewById&lt;TextView&gt;(R.id.item_name)</span><br><span class="line">            championName.text = config.championName</span><br><span class="line">            v.setOnClickListener&#123;</span><br><span class="line">                config.clickFunction()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果inflate第三个参数是false，这里需要手动addView</span></span><br><span class="line">            container.addView(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChampionConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        championConfig = mutableListOf()</span><br><span class="line">        championConfig.add(ChampionConfig(R.drawable.kayn,<span class="string">&quot;Kayn&quot;</span>)&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;This is kayn&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        championConfig.add(ChampionConfig(R.drawable.samira,<span class="string">&quot;samira&quot;</span>)&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;This is samira&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        championConfig.add(ChampionConfig(R.drawable.khazix,<span class="string">&quot;khazix&quot;</span>)&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MainActivity&quot;</span>,<span class="string">&quot;This is khazix&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据配置类</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ChampionConfig</span></span>(</span><br><span class="line">    <span class="keyword">var</span> avatarId: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">var</span> championName: String,</span><br><span class="line">    <span class="keyword">var</span> clickFunction: ()-&gt;<span class="built_in">Unit</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的核心部分就是两句话：inflate和addview。获取父容器非常简单我们就不再赘述了。在获取到父容器后，我们使用inflater动态加载子项布局。inflate的三个参数分配代表子项布局id，要挂载的父布局，是否立刻挂载。如果第三个参数我们选择false，我们就需要使用container.addview手动添加子项的view。这里有一个小坑，细心的同学可能发现，这个addview，似乎就能确定父子容器的关系啊？那inflate的第二个参数我们可以传null吗？这是可以的，但是这样会导致子项根节点（这里是view_item.xml中的LinearLayout）属性失效。通过下图我们能够发现，如果设定为null则view_item的宽高margin全部失效了，这是非常不符合预期的。</p>
<p><img src="https://i.loli.net/2021/07/31/rKMU4VTpZm2YvB1.png" alt="root-view-compare.png"></p>
<p>另外一个值得一提的点是如果你需要绑定点击事件，那么最好在添加子视图的时候直接添加。实际上我们在父容器中添加了很多个带有相同id的view，如果添加完动态view后再修改我们就不能使用id获取到控件了，处理起来会比较麻烦。</p>
<h1 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h1><p>在感受了Vue的美好之后，安卓麻烦的布局文件确实震惊到我。为什么不能够像vue的v-for一样动态添加节点，动态设定id？查阅了资料后我发现这个问题在安卓最大的阻碍是xml文件的编译。因为xml的编译占了大量的CPU处理时间，我们不能够在运行时动态修改xml。导致动态布局的实现及其麻烦。能否开发一种新的布局方式优化布局的问题？我认为这或许会是一个非常有趣的研究方向。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://blog.csdn.net/u012556114/article/details/105897634/">Android两种方式实现动态添加View</a> 因为他将root设定为null了，导致我第一次调试样式一直不对</p>
<p><a href="https://blog.csdn.net/fangchao3652/article/details/34116443">android 动态添加控件并实现每个子控件的点击事件</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工程</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展欧几里得补档</title>
    <url>/2017/10/13/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%A1%A5%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="POJ-–-1061-青蛙的约会"><a href="#POJ-–-1061-青蛙的约会" class="headerlink" title="POJ – 1061 青蛙的约会"></a>POJ – 1061 青蛙的约会</h2><p><em>思路：</em><br>不能直接暴力，看网上的题解说这道题卡了使用mod的运行时间。所以要使用extgcd。方程由m<em>t+x=k</em>l+n<em>t+y推出得到(m-n)</em>t-k*l=y-x计算这个方程即可</p>
<span id="more"></span>
<p><em>代码：</em><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">extgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    ll d = a;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        d = <span class="built_in">extgcd</span>(b, a%b, y, x);</span><br><span class="line">        y -= (a / b)*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ll x,y,m,n,l;</span><br><span class="line">    <span class="comment">//freopen(&quot;sample.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;sample.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l) &#123;</span><br><span class="line">        ll x1, y1;</span><br><span class="line">        ll gcds = <span class="built_in">extgcd</span>(m - n, -l, x1, y1);</span><br><span class="line">        <span class="keyword">if</span> ((y - x) % gcds != <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x1 = x1*(y - x) / gcds;</span><br><span class="line">            ll t = l / gcds;</span><br><span class="line">            t = t &gt; <span class="number">0</span> ? t : -t;</span><br><span class="line">            <span class="keyword">if</span> (x1 &gt;= <span class="number">0</span>)</span><br><span class="line">                x1 = x1%t;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                x1 = x1%t + t;</span><br><span class="line">            cout &lt;&lt; x1 &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fclose(stdin);</span></span><br><span class="line">    <span class="comment">//fclose(stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="UVA-10104-Euclid-Problem"><a href="#UVA-10104-Euclid-Problem" class="headerlink" title="UVA-10104 Euclid Problem"></a>UVA-10104 Euclid Problem</h2><p><em>代码：</em><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a) memset(a,0,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">extgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    ll d = a;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d = <span class="built_in">extgcd</span>(b, a%b, y, x);</span><br><span class="line">        y -= (a / b)*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ll a,b;</span><br><span class="line">    <span class="comment">//freopen(&quot;sample.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;sample.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;a&gt;&gt;b) &#123;</span><br><span class="line">        ll x, y, gcds;</span><br><span class="line">        gcds = <span class="built_in">extgcd</span>(a, b, x, y);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; gcds &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fclose(stdin);</span></span><br><span class="line">    <span class="comment">//fclose(stdout);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
        <category>扩展欧几里得</category>
      </categories>
      <tags>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title>iris学习笔记</title>
    <url>/2022/05/10/iris%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>iris后端开发笔记整理</p>
<span id="more"></span>
<h1 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;main/router_Controller&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/kataras/iris/v12&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Get context</span></span><br><span class="line">	app := iris.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Integrate router into one controller</span></span><br><span class="line">	router_Controller.Hub(app)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Listens and serves incoming http requests</span></span><br><span class="line">	<span class="comment">// on http://localhost:8080.</span></span><br><span class="line">	app.Listen(<span class="string">&quot;:8988&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Database-connection"><a href="#Database-connection" class="headerlink" title="Database connection"></a>Database connection</h1><p>We use XORM to connect database.</p>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install driver for mysqsl</span></span><br><span class="line">go get -u github.com/go-sql-driver/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">go get xorm.io/xorm <span class="comment"># install xorm</span></span><br><span class="line">go get xorm.io/builder <span class="comment"># install builder</span></span><br><span class="line">go get xorm.io/reverse <span class="comment"># install reverse tool, this can help you generate code automatically accroding to the database we already have.</span></span><br></pre></td></tr></table></figure>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1>]]></content>
      <categories>
        <category>工程</category>
        <category>Go</category>
        <category>Iris</category>
      </categories>
      <tags>
        <tag>iris</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 EC-Final 总结</title>
    <url>/2017/12/17/2017%20EC-Final%20%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>热身赛两个队友考四六级去了，就我一个人调机子。。前一个多小时电脑无限连不上网，10多个志愿者一个一个过来让我刷新网页？热身赛的题目是google的kickstart的题，第四题比较简单，一个裸的最小生成树（分析选取过程可以发现是kruskal），然后b题感觉可以三分x再三分y？开始无限乱搞然后无限WA？就这样结束了热身赛，赛后听说三分和模拟退火都能过B，感觉自己裸写三分的能力非常捉急。。在座的各位大佬还是强，花式AK</p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>现场赛三道水题，A开始队友想用Lucas结果TLE，然后我来搞发现N范围小可以发现把C(k,n)变成C(n-k,n)，然后使用组合数的递推公式让复杂度来到10^5*100，第一发因为有一个地方忘取模爆long long所以WA了，第二发过了。最后一道水题，判断票位于哪一轮比赛即可，不过我题读完没搞懂赛制？就让另一个队友再读了一遍（大锅，不怎么看世界杯不了解，重复读题有点浪费时间），读完后2发A了。K题陷入了三个人都读不懂题的困境？？？我到最后都没读懂，不过幸好队友脑袋清醒A了。然后我开始无脑推J，J的思路其实就是枚举起点终点然后对每个起点贪心判最近终点距离是不是&gt;=3。这题我推得实在是太慢了，封榜后才推出结论。然后第一发蜜汁TLE，改了个错A了，然后4题到结束。在后面的时间我猜了个C，结论跟正确的就差一点，我本来以为只需要考虑第一个红灯，之后的就都能绿灯了，交了猜想WA，然后队友跟我说让我枚举红灯，我：？？？，队友：？？？我俩交流出了问题，不然C题就A了。然后B题又没读懂。。队友很早就告诉了我D题的题意，我开始觉得能够枚举比例来打表，但后来考虑到存不下就没跟队友说，结果思路其实没问题。。E题大模拟我们没看，题目太长，而且需要的机时太长了。F题用了KMP的next思想，我看了题解才明白，这题是真的不会。G题LCA，没看。H题DP，我居然没看出来。。（大锅）I题似乎是三分，但我们队计算几何不是很好，比赛中没有看。L题推结论推到最后也没推出来。。<br><img src="https://i.loli.net/2020/12/14/hzRCONZPc4mDWG7.jpg" alt="Rank"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>要加强读题，比赛中两道题因为读题浪费了时间</li>
<li>模的时候怎么总是忘了要所有地方都要取模啊？以后最后交的时候一定要检查一遍</li>
<li>队友交流的时候最好举两个例子</li>
<li>CCPC，ecfinal都反映出我dp巨烂无比，寒假把cf所有dp标签的题都刷一遍<br>就是这些吧，主要原因还是自己水平不够，知识点覆盖太少，接下来准备这两周不弄算法了，专心准备考试，然后寒假好好训练一下，就酱</li>
</ol>
]]></content>
      <categories>
        <category>比赛总结</category>
      </categories>
      <tags>
        <tag>比赛总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Relearn Front End Technology</title>
    <url>/2021/04/24/%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Note of relearn Front End. <a href="https://time.geekbang.org/column/intro/100023201">Course URL</a><br><span id="more"></span></p>
<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><h3 id="undefined，null"><a href="#undefined，null" class="headerlink" title="undefined，null"></a>undefined，null</h3><p>有的编程规范要求使用void 0代替undefined。因为undefined是一个变量，为了避免无意的撰改，通常使用void 0来代替。虽然es5中undefined的值是read-only的，但是在局部作用域仍可能被修改。void后跟任何表达式的值都是undefined，而void 0又是最短和表意最清楚的。<br><br>undefined和null的表意略有不同， undefined表示未定义，而null表示定义了但是为空。null是javascript的关键字，所以可以放心使用。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>string是有最大长度2^53-1的。但是考虑到我们通常使用utf-8或者utf-16,所以字符串的最大长度，实际上是受字符串编码长度影响的。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。其中9007199254740990代表NaN,Infinity表示无穷大，-Infinity表示负无穷大。<br><br>另外，javascript中有+0和-0.区别是除零时的结果一个是正无穷大，另一个是负无穷大。也可以用1/x是正无穷大还是负无穷大检测一个数是+0还是-0。<br><br>javascript存在浮点数不精确的问题（IEEE754）。一个经典的问题就是0.1+0.2不等于0.3.为了解决这个问题<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">0.1</span>+<span class="number">0.2</span>-<span class="number">0.3</span>)&lt;=<span class="built_in">Number</span>.EPSILON;</span><br></pre></td></tr></table></figure><br>是一个正确的做法。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><img src="https://i.loli.net/2021/04/08/ogVYRTkwWCsiQLE.jpg" alt="js类型转换.jpg"></p>
<h3 id="装箱转换"><a href="#装箱转换" class="headerlink" title="装箱转换"></a>装箱转换</h3><p>虽然Symbol无法使用new来调用，但是我们能够使用装箱得到一个Symbol对象。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> symbolObject = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">this</span>;&#125;).call(<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbolObject);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObject <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(symbolObject.constructor == <span class="built_in">Symbol</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol>
<li>对象具有唯一标识性：即便两个完全相同的对象，也并非同一对象。（{}!=={}）</li>
<li>对象具有状态：对象具有状态，同一对象可能处于不同状态之下。</li>
<li>对象具有行为：对象的状态，可能因为它的行为发生变迁。</li>
</ol>
<h3 id="js对象的两类属性"><a href="#js对象的两类属性" class="headerlink" title="js对象的两类属性"></a>js对象的两类属性</h3><p>javascript用一组特征（attribute）来描述属性（property）。第一类属性是<strong>数据属性</strong>。数据属性具有四个特征：</p>
<ol>
<li>value：属性的值</li>
<li>writable：是否是只读数据</li>
<li>enumerable：是否能够使用for in能否枚举该属性</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ol>
<p>第二类是访问器属性，他有四个特征：</p>
<ol>
<li>getter：函数或undefined，在取属性值的时候使用。</li>
<li>setter：函数或undefined，在设置属性的时候使用。</li>
<li>enumerable：是否能够使用for in能否枚举该属性</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ol>
<p>通过Object的内置函数getOwnPropertyDescriptor可以查看属性<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDessciptor(o,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">//&#123;value:1, writable:true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><br>如果想要改变属性的特征，可以使用Object.defineProperty<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;b&quot;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>, <span class="attr">configurable</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="comment">//a和b都是数据属性，但特征值变化了</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;a&quot;</span>); <span class="comment">// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;b&quot;</span>); <span class="comment">// &#123;value: 2, writable: false, enumerable: false, configurable: true&#125;</span></span><br><span class="line">o.b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><br>也可以通过get和set创建访问器属性<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="keyword">get</span> <span class="title">a</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>c++,java使用了“类”的方式来模拟对象。而javascript使用了原型的方法来模拟对象。基于原型的对象系统通过复制来创建新对象。原型系统的复制操作有两种实现思路：</p>
<ol>
<li>并不是真的复制对象，而是新对象持有原型的引用</li>
<li>真正的复制对象，从此两个对象再无关联</li>
</ol>
<p>javascript使用了前一种方式。原型系统的大致概念为</p>
<ol>
<li>如果所有对象都有私有字段prototype, 那么就是对象的原型</li>
<li>读一个属性，如果对象本身没有，那么就会继续访问对象的原型，直到原型为空或者找到为止。</li>
</ol>
<p>ES6开始提供了一些方法让我们能够更加方便地操作原型。</p>
<ol>
<li>Object.create根据指定的原型创建新对象，原型可以为null</li>
<li>Object.getPrototypeOf获得一个对象的原型</li>
<li>Object.setPrototypeOf设置一个对象的原型</li>
</ol>
<h3 id="ES6中的类"><a href="#ES6中的类" class="headerlink" title="ES6中的类"></a>ES6中的类</h3><p>使用es6中的类就能够避免function和new的搭配。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.calcArea();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Method</span></span><br><span class="line">  <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>类同时赋予了继承能力<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// call the super class constructor and pass in the name parameter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; barks.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.speak(); <span class="comment">// Mitzie barks.</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Javascript执行"><a href="#Javascript执行" class="headerlink" title="Javascript执行"></a>Javascript执行</h2><p>我们应该形成一个感性的认识：一个javascript引擎会常驻内存中，等待着我们把javascript代码或者函数传递给它执行。在ES3或者更早的版本中，javascript本身还没有异步执行代码的能力，所以传递javascript代码后，引擎就直接把代码顺序执行了。这个任务是宿主发起的任务。在ES5后加入了promise，这样不需要浏览器的安排，javascript本身也可以发起任务了。我们称宿主发起的是宏观任务，javascript发起的是微观任务。</p>
<h3 id="宏观任务和微观任务"><a href="#宏观任务和微观任务" class="headerlink" title="宏观任务和微观任务"></a>宏观任务和微观任务</h3><p><img src="https://i.loli.net/2021/04/19/n9MjQ1C72yW3qiB.jpg" alt="marco-and-mirco-task.jpg"><br>通过宏观任务和微观任务机制，我们就可以实现javascript引擎级和宿主级的任务了。比如promise永远在队列尾部添加微观任务，setTimeout等宿主api，则会添加宏观任务。执行的顺序是同步任务=&gt;微观任务=&gt;宏观任务。在<a href="https://www.cnblogs.com/jiangyuzhen/p/11064408.html">这里</a>有非常详尽的例子。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>Javascript闭包的组成部分为两个，环境部分和表达式部分。<br>环境部分包括：</p>
<ol>
<li>环境：函数的词法环境（执行上下文的一部分）</li>
<li>标识符列表：函数中用到的未声明的变量</li>
</ol>
<p>表达式部分就是函数体</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>javascript把一段代码，执行所需的所有信息定义为：“执行上下文“。<br><br>在ES3中：<br></p>
<ul>
<li>scope: 作用域，常常叫做作用域链。</li>
<li>variable object: 变量对象，用于储存变量的对象。</li>
<li>this value： this值</li>
</ul>
<p>在ES5,执行上下文变成了：<br></p>
<ul>
<li>lexical environment: 词法环境，获取变量时使用。</li>
<li>variable environment： 变量环境，生命变量时使用。</li>
<li>this value： this值</li>
</ul>
<p>在ES2018中，执行上下文变成了：</p>
<ul>
<li>lexical environment: 词法环境，当获取变量或者this值时使用</li>
<li>variable environment： 变量环境，当声明变量时使用。</li>
<li>code evaluation state： 用于恢复代码执行位置。</li>
<li>Function： 执行的任务是函数时使用，表示正在被执行的函数。</li>
<li>ScriptOrModule： 执行的任务是脚本或者模块时使用，表示正在被执行的代码。</li>
<li>Realm： 使用的基础库和内置对象实例</li>
<li>Generator： 仅生成器上下文有这个属性，表示当前生成器。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>想要正确执行她，我们需要知道：</p>
<ol>
<li>var把b声明到哪里</li>
<li>b表示哪个变量</li>
<li>b的原型是哪个对象</li>
<li>let把c声明到哪里</li>
<li>this指向哪个对象</li>
</ol>
<p>这些信息就需要执行上下文。</p>
<h4 id="var声明与赋值"><a href="#var声明与赋值" class="headerlink" title="var声明与赋值"></a>var声明与赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>通常我们认为它声明了b,请求为它赋值为1,var声明作用于函数执行的作用域，就是说它会穿透for和if语句。在没有let时，我们通过创建一个立即执行函数来控制var的范围。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;());</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><br>不过如果function的上一行代码不写分号，括号会被解释为上一行代码最末的函数调用。一种推荐的写法是使用void关键字<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>let使用块级作用域，包括：</p>
<ul>
<li>for</li>
<li>if</li>
<li>switch</li>
<li>try/catch/finally</li>
</ul>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h4><p>在9.0标准中，js引入了realm.在js中，很少提到{}的原型问题。但是实际的前端开发中，通过iframe创建多window环境也比较常见。所以促成了新的Realm的诞生。Realm中包含一族完整的内置对象，而且是复制关系。因为，instanceOf基本是失效的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>)</span><br><span class="line"><span class="built_in">document</span>.documentElement.appendChild(iframe)</span><br><span class="line">iframe.src=<span class="string">&quot;javascript:var b = &#123;&#125;;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = iframe.contentWindow.b;</span><br><span class="line"><span class="keyword">var</span> b2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1, <span class="keyword">typeof</span> b2); <span class="comment">//object object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>, b2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//false true</span></span><br></pre></td></tr></table></figure><br>可以看到，{}在不同的realm中表现了不同的行为。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类（也是函数）"><a href="#类（也是函数）" class="headerlink" title="类（也是函数）"></a>类（也是函数）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步函数（async）"><a href="#异步函数（async）" class="headerlink" title="异步函数（async）"></a>异步函数（async）</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>不同的函数，一个明显的区别是this。同一个函数调用方式不同，得到的this也不同。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showThis</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">showThis</span>: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// global</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure><br>普通函数的this由“调用它所使用的引用“决定。我们获取函数的表达式，实际上返回的不是函数本身，而是Reference类型。Reference由两部分组成：一个对象和一个属性值。o.showThis产生的Reference是对象o和属性“showThis”组成。当做一些算数运算，Reference会被解引用，即获取真正的值。而函数调用，delete要用到Reference中的对象。在这个例子中Reference中的对象被当作this传入了执行函数的上下文。所以this即使<strong>调用函数时的引用，决定了函数执行时刻的this。</strong><br><br>值得一提的是箭头函数的this是不同的：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> showThis = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">showThis</span>: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// global</span></span><br><span class="line">o.showThis(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure><br>箭头函数不论是用什么引用来调用它，都不影响this。<br><br>另外方法的行为也不一样：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">showThis</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">var</span> showThis = o.showThis;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// undefined</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure><br>按照我们上面的方法，不难验证出：生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。</p>
<h4 id="this的机制"><a href="#this的机制" class="headerlink" title="this的机制"></a>this的机制</h4><p>在javascript标准中，为函数规定了用来保存定义时上下文的私有属性[[Environment]]。当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境会被设置成函数的[[Environment]]。这个动作就是切换上下文。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">在别处定义了foo：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里foo能够访问b（定义时词法环境），却不能访问a（执行时词法环境）就是上下文的切换机制。javascript用一个栈管理执行上下文，这个栈中的每一项又包含一个链表：<br><img src="https://i.loli.net/2021/04/26/dfBonHJOYypET9L.jpg" alt="context-stack.jpg"><br>函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。javascript定义了[[thisMode]]私有属性。[[thisMode]]有三个取值</p>
<ul>
<li>lexical： 表示从上下文中取this,对应了箭头函数。</li>
<li>global： 表示this为undefined时，取全局对象，对应了普通函数</li>
<li>strict： 严格模式下严格按照调用时传入的值，可能为null或者undefined.</li>
</ul>
<p>方法的行为和普通函数有差异，因为class设计成了默认按strict模式执行。严格模式下，之前的代码会是这样的结果：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showThis</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">showThis</span>: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// undefined</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure><br>函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来标记新记录的[[ThisBindingStatus]]私有属性。代码执行遇到this时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]],当找到有this的环境记录时获取this的值。这样规则的实际效果是嵌套的箭头函数中的代码都指向外层this<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">o.foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.foo()()(); <span class="comment">// o, o, o</span></span><br></pre></td></tr></table></figure><br>这个例子中，我们定义了三层嵌套的函数，最外层为普通函数，两层是箭头函数。三个函数的this都是对象o.</p>
<h4 id="操作this的内置函数"><a href="#操作this的内置函数" class="headerlink" title="操作this的内置函数"></a>操作this的内置函数</h4><p>Function.prototype.call和Function.prototype.apply可以指定函数调用传入的this,示例如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(&#123;&#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">foo.apply(&#123;&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure></p>
<h4 id="new与function"><a href="#new与function" class="headerlink" title="new与function"></a>new与function</h4><p><img src="https://i.loli.net/2021/04/26/9fY4KDRkCvxsoUH.png" alt="new-and-function.png"></p>
<h3 id="Completion类型"><a href="#Completion类型" class="headerlink" title="Completion类型"></a>Completion类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo());</span><br></pre></td></tr></table></figure>
<p>这段代码中，finally执行了，return也生效了。实际上，finally放return则finally中的return会覆盖try的return。Completion Record用于描述一个语句执行完的结果，它有三个字段：</p>
<ul>
<li>[[type]]表示完成的类型，有break, continue, return, throw和normal.</li>
<li>[[value]]表示语句的返回值，没有就是empty</li>
<li>[[target]]表示语句的目标，通常是javascript标签。</li>
</ul>
<p>js依靠completion record类型，在复杂的嵌套结构中实现各种控制。<br><img src="https://i.loli.net/2021/04/28/MEpYNXWP4TavZlH.jpg" alt="js-yuju.jpg"></p>
<h4 id="普通语句"><a href="#普通语句" class="headerlink" title="普通语句"></a>普通语句</h4><ul>
<li>声名类语句（var，const，let，函数声明，类声明）</li>
<li>表达式语句</li>
<li>空语句</li>
<li>debugger语句</li>
</ul>
<p>这些语句执行时从前到后顺此执行（忽略var和函数声明的预处理机制）没有任何分支或重复执行逻辑。普通语句执行后会得到[[type]]为normal的completion record,javascript引擎遇到这样的completion record会继续执行下一条语句。只有表达式语句会产生[[value]]。</p>
<h4 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h4><p>语句块completion record的[[type]]如果不为normal会打断语句块后续的语句执行。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>; <span class="comment">// normal, empty, empty</span></span><br><span class="line">  i ++; <span class="comment">// normal, 1, empty</span></span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">//normal, undefined, empty</span></span><br><span class="line">&#125; <span class="comment">// normal, undefined, empty</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>; <span class="comment">// normal, empty, empty</span></span><br><span class="line">  <span class="keyword">return</span> i; <span class="comment">// return, 1, empty</span></span><br><span class="line">  i ++; </span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125; <span class="comment">// return, 1, empty</span></span><br></pre></td></tr></table></figure></p>
<h4 id="控制类语句"><a href="#控制类语句" class="headerlink" title="控制类语句"></a>控制类语句</h4><p>带if，switch关键字，对不同类型的completion record产生反应。控制类语句分两部分，一类对内部产生影响，如if,switch,while/for,try.另一类对外部造成影响如break,continue,return,throw。<br><img src="https://i.loli.net/2021/04/28/sQkZHL5hdetbWzJ.png" alt="control-sentence-combination.png"><br>这里的穿透指跳出控制语句向外穿透，消费指控制语句接受语句。</p>
<h4 id="带标签的语句"><a href="#带标签的语句" class="headerlink" title="带标签的语句"></a>带标签的语句</h4><p>js语句是可以加标签的，在语句前加冒号：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">firstStatement: <span class="keyword">var</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>这种语句的作用是跳出多重循环，类似c语言中的go<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">outer: <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="attr">inner</span>: <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span> outer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;finished&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="javascript词法"><a href="#javascript词法" class="headerlink" title="javascript词法"></a>javascript词法</h2><p>javascript中有这些词法：</p>
<ul>
<li>whitespace 空白字符</li>
<li>lineTerminator 换行符</li>
<li>comment 注释</li>
<li>token 词<blockquote>
<ol>
<li>identifierName 标识符名称，如变量名和关键字</li>
<li>punctuator 符号</li>
<li>numericLiteral 数字直接量，就是我们写的数字</li>
<li>stringLiteral 字符串直接量，就是我们用单引号或双引号引起来的直接量。</li>
<li>template 字符串模板，用反括号`括起来的直接量。</li>
</ol>
</blockquote>
</li>
</ul>
<p>js中不但支持除法运算符’/‘和’/=’，也支持正则表达式’/abc/‘。这种情况对词法分析是没法处理的，所以js定义了两套词法，靠与法分析传一个标识给词法分析器，让它决定使用哪一套词法。另外”${}”内部可以放任何js代码，所以这部分不允许出现’}’。是否允许”}“两种情况和除法及正则表达式两种相乘就是四种词法定义，所以js中有四种定义：</p>
<ul>
<li>InputElementDiv</li>
<li>InputElementRegExp</li>
<li>InputElementRegExpOrTemplateTail</li>
<li>InputElementTemplateTail</li>
</ul>
<p>但为了方便起见，我们还是将其视为普通token.</p>
<h3 id="数字直接量"><a href="#数字直接量" class="headerlink" title="数字直接量"></a>数字直接量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">12.</span>toString()</span><br></pre></td></tr></table></figure>
<p>会报错，因为12被认为省略了小数点后面的数字，看作一个整体。所以想让’.’单独成为toke就要加入空格<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span> .toString()</span><br></pre></td></tr></table></figure></p>
<h3 id="自动插入分号"><a href="#自动插入分号" class="headerlink" title="自动插入分号"></a>自动插入分号</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">a</span><br><span class="line">++</span><br><span class="line">b</span><br><span class="line">++</span><br><span class="line">c</span><br><span class="line"><span class="comment">//a=1, b=2, c=2</span></span><br></pre></td></tr></table></figure>
<h3 id="import和export"><a href="#import和export" class="headerlink" title="import和export"></a>import和export</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> x <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span><span class="comment">//引入模块中export的值</span></span><br><span class="line"><span class="keyword">import</span> &#123;a <span class="keyword">as</span> x, modify&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;<span class="comment">//引入模块中的变量</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> x <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>;<span class="comment">//把模块中的所有变量以类似对象属性的方式引入</span></span><br></pre></td></tr></table></figure>
<p>直接export再import的值还是受原模块控制。仅有export default使导出的值无关。<br><img src="https://i.loli.net/2021/04/28/pgHSCmWn5cvG6MK.jpg" alt="function-and-script.jpg"></p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><h4 id="var提升"><a href="#var提升" class="headerlink" title="var提升"></a>var提升</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();<span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//===============</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();<span class="comment">//false,提升只看函数体/脚本/模块</span></span><br></pre></td></tr></table></figure>
<h4 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h4><p>原本函数与var相似，但函数不仅提升还会赋值。在if等语句中function仍然会产生变量，但不会提前赋值。</p>
<h4 id="class提升"><a href="#class提升" class="headerlink" title="class提升"></a>class提升</h4><p>class也会预处理，但是是为了避免class名被其他变量提前声明。所以是抛出错误。</p>
<h1 id="HTML和CSS"><a href="#HTML和CSS" class="headerlink" title="HTML和CSS"></a>HTML和CSS</h1><h2 id="带-规则"><a href="#带-规则" class="headerlink" title="带@规则"></a>带@规则</h2><h3 id="charset"><a href="#charset" class="headerlink" title="@charset"></a>@charset</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">&quot;utf-8&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>提示css的字符编码方式。</p>
<h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;mystyle.css&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;mystyle.css&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>引入css文件</p>
<h3 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h3><p>根据设备进行判断<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">300px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>:lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ol>
<li>[att]，只要元素有这个属性，不论属性是什么值都能被选中</li>
<li>[att=val]精确匹配，检查元素的值是否为val</li>
<li>[att~=val]检查一个元素的值是否是若干值之一，这里的val不是一个单一的值，可以是空格分割的序列。</li>
<li>[att|=val]检查一个元素的值是否以val开头，只要val开头即可，后面内容不管。</li>
</ol>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><ol>
<li>：root表示树的根元素，一般用html标签就可以选中根元素，但是随着scoped css和shadow root的出现，选择器可以针对某一子树选择，那么就要root伪类了。</li>
<li>：nth-child(even) 选中偶数节点</li>
<li>：nth-child(4n-1)选中4n-1的节点</li>
<li>：nth-child(3n+1 of li.important)选中第1,4,7个li.important。注意只有li.important会被计数。</li>
<li>：empty 伪类表示没有子节点的元素</li>
<li>：any-link 任意的链接包括a，area和link</li>
</ol>
<h3 id="选择器组合"><a href="#选择器组合" class="headerlink" title="选择器组合"></a>选择器组合</h3><ul>
<li>空格：所有后代</li>
<li>‘&gt;’:子代（仅往下一层）</li>
<li>‘~’:后继，父元素相同，一个节点的后续节点</li>
<li>‘+’:直接后继，连着的第一个</li>
<li>‘||’:列选择器，表示选中对应列中符合条件的单元格</li>
</ul>
<h3 id="选择器优先级"><a href="#选择器优先级" class="headerlink" title="选择器优先级"></a>选择器优先级</h3><p>令id选择器的数目为a,伪类和class的数目为b,伪元素和标签选择器数目为c则优先级为<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">specificity = base * base * a + base * b + c</span><br></pre></td></tr></table></figure><br>同一优先级遵循后面覆盖前面的。</p>
<h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><ol>
<li>::first-line元素的第一行</li>
<li>::first-letter第一个字母</li>
<li>::before在元素内容之前插入虚拟的元素</li>
<li>::after在元素之后插入虚拟的元素</li>
</ol>
<h2 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h2><h3 id="超链接类link标签"><a href="#超链接类link标签" class="headerlink" title="超链接类link标签"></a>超链接类link标签</h3><h4 id="canonical型link"><a href="#canonical型link" class="headerlink" title="canonical型link"></a>canonical型link</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;canonical&quot;</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>多个url指向同一个页面的情况，搜索引擎访问会去掉重复的页面，link会提示搜索引擎保留哪一个url.</p>
<h4 id="alternate型link"><a href="#alternate型link" class="headerlink" title="alternate型link"></a>alternate型link</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;alternate&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/rss+xml&quot;</span> <span class="attr">title</span>=<span class="string">&quot;RSS&quot;</span> <span class="attr">href</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>提示页面的变形形式比如rss</p>
<h4 id="prev和next型link"><a href="#prev和next型link" class="headerlink" title="prev和next型link"></a>prev和next型link</h4><p>提示当前页面的前一项和后一项，next型link告诉浏览器这是很可能访问的下一个页面。</p>
<h3 id="外部资源类link标签"><a href="#外部资源类link标签" class="headerlink" title="外部资源类link标签"></a>外部资源类link标签</h3><h4 id="icon型link"><a href="#icon型link" class="headerlink" title="icon型link"></a>icon型link</h4><p>图标会被浏览器下载和使用，未指定会使用avicon.ico。</p>
<h4 id="预处理类link"><a href="#预处理类link" class="headerlink" title="预处理类link"></a>预处理类link</h4><p>制定浏览器针对一些资源提前操作，提高性能。</p>
<ul>
<li>dns-prefetch型link提前对一个域名做dns查询</li>
<li>preconnect型link提前对服务器建立tcp链接</li>
<li>prefetch型link提前对href的url内容进行获取</li>
<li>preload型link提前加载href指定的url</li>
<li>prerender型link提前渲染href指定的url</li>
</ul>
<h4 id="modulepreload型的link"><a href="#modulepreload型的link" class="headerlink" title="modulepreload型的link"></a>modulepreload型的link</h4><p>提前加载javascript模块。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;modulepreload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;app.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;modulepreload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;helpers.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;modulepreload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;irc.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;modulepreload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fog-machine.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;app.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h3><p>有href时，与一些link一样会产生超链接，也就是用户不操作的时候，它们不会被主动下载的被动型链接。a标签也有类似link的rel,除了之前提到的还有tag表示网页所属的标签，bookmark到上级张杰的链接，nofollow的链接不会被搜索引擎索引，noopener无法用opener获得当前页面的窗口，noreferrer无法用referrer获得当前页面的url.</p>
<h3 id="area标签"><a href="#area标签" class="headerlink" title="area标签"></a>area标签</h3><p>area是区域型的链接。支持的rel与a一样。多了一个shape属性：</p>
<ul>
<li>圆形：circle或者circ。coords,支持三个之，表示中心点的x,y坐标和半径r.</li>
<li>矩形：rect或rectangle。coords支持两个之表示对角顶点x1,y1和x2,y2.</li>
<li>多边形： poly或者polygon.coords至少包括六个值，表示多边形的各个顶点。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"> Please select a shape:</span><br><span class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;shapes.png&quot;</span> <span class="attr">usemap</span>=<span class="string">&quot;#shapes&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;Four shapes are available: a red hollow box, a green circle, a blue triangle, and a yellow four-pointed star.&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;shapes&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">rect</span> <span class="attr">coords</span>=<span class="string">&quot;50,50,100,100&quot;</span>&gt;</span> <span class="comment">&lt;!-- the hole in the red box --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">rect</span> <span class="attr">coords</span>=<span class="string">&quot;25,25,125,125&quot;</span> <span class="attr">href</span>=<span class="string">&quot;red.html&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Red box.&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">circle</span> <span class="attr">coords</span>=<span class="string">&quot;200,75,50&quot;</span> <span class="attr">href</span>=<span class="string">&quot;green.html&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Green circle.&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">poly</span> <span class="attr">coords</span>=<span class="string">&quot;325,25,262,125,388,125&quot;</span> <span class="attr">href</span>=<span class="string">&quot;blue.html&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Blue triangle.&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">poly</span> <span class="attr">coords</span>=<span class="string">&quot;450,25,435,60,400,75,435,90,450,125,465,90,500,75,465,60&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">href</span>=<span class="string">&quot;yellow.html&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Yellow star.&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="CSS-trick"><a href="#CSS-trick" class="headerlink" title="CSS trick"></a>CSS trick</h2><h3 id="等分布局"><a href="#等分布局" class="headerlink" title="等分布局"></a>等分布局</h3><p>用百分比布局可能会有空档，因为换行被当作空格。如果不想代码格式混乱可以设置字号为0。注意不推荐float,因为float只能顶对齐，不够灵活。<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">33.33%</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">outline</span>:solid <span class="number">1px</span> blue;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="自适应宽"><a href="#自适应宽" class="headerlink" title="自适应宽"></a>自适应宽</h3><p>HTML<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;auto&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>CSS<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fixed</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>:top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.auto</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>:border-box;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>:top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>逻辑是把右边的放到左边div下面，然后padding把内容挤出来。</p>
<h1 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h1><h2 id="网页展示流程"><a href="#网页展示流程" class="headerlink" title="网页展示流程"></a>网页展示流程</h2><ol>
<li>使用http或https协议，向服务端请求页面</li>
<li>请求的html代码经过解析，构建dom树</li>
<li>计算dom上的css属性</li>
<li>根据css对元素逐个渲染，得到内存中的位图</li>
<li>可选：位图进行合成，增加后续绘制速度</li>
<li>合成后绘制到界面上</li>
</ol>
<p><img src="https://i.loli.net/2021/04/29/fGnzFEPjYgZKuSN.jpg" alt="how-browser-work.jpg"></p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>位图信息是DOM树中占据浏览器内存最多的信息，内存优化也主要是优化这一部分。<br><br>渲染可以分为两个大类：图形和文字。盒的背景、边框、SVG 元素、阴影等特性，都需要绘制，通常使用底层库实现。文字则使用字体库。渲染时子元素是不会绘制到渲染的位图上的，这样父子元素相对位置变化时，能够保证渲染的内容能够最大程度被缓存。</p>
<h2 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h2><p>把子元素合成到父元素的位图上。浏览器使用position和transform决定合成策略。新的css中规定了will-change属性。</p>
<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p>使用“脏矩形”策略，将屏幕分为几个区域。</p>
<h1 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h1><p>前端工具链大概要：</p>
<ol>
<li>初始化项目</li>
<li>运行和调试</li>
<li>测试</li>
<li>发布</li>
</ol>
<p>那么，常见的社区工具会是：</p>
<ol>
<li>Yeoman</li>
<li>webpack</li>
<li>ava/nyc</li>
<li>aws-cli</li>
</ol>
<p>但是这样不够，我们需要保证版本一致。一种方法是使用npm script并在依赖中规定版本好。重量级的做法是开发一个包装工具。重量级的好处是我们能够监控：</p>
<ol>
<li>调试/构建次数</li>
<li>构建平均时长</li>
<li>使用工具版本</li>
<li>发布次数</li>
</ol>
]]></content>
      <categories>
        <category>工程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Front-End</tag>
      </tags>
  </entry>
  <entry>
    <title>Aizu - 1313 Intersection of Two Prisms(辛普森积分)</title>
    <url>/2018/07/18/Aizu%20-%201313%20Intersection%20of%20Two%20Prisms(%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86)/</url>
    <content><![CDATA[<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先由题意，我们有一个平行于z轴的棱柱和一个平行于y轴的棱柱。想要通过三维几何运算来获得体积的方式显然是比较困难的。但我们注意到我们已经有的是<strong>两个保证底面为凸多边形的棱柱</strong>。这样有什么好处？我们考虑找一个垂直于x轴的平面，沿着平面对着这两个棱柱砍一刀会得到什么。<br><img src="https://i.loli.net/2020/12/14/ZiTEfpNPuwHyD4F.jpg" alt="aizu1313"><br>是两个长方形对不对？那么这两个长方形的交是什么？（注意，这时候我们砍的x是一样的）<br><img src="https://i.loli.net/2020/12/14/esO9A8haF537lmn.jpg" alt="aizu1313-1"><br>依然是一个长方形！而且显然在两个棱柱交的地方，对于每一个x砍一刀都有一个长方形。注意题意<strong>“两个保证底面为凸多边形的棱柱”</strong>，这是导致了当前情况的关键，凸多边形使得不会出现下图的情况：<br><img src="https://i.loli.net/2020/12/14/JT6txRlU2VXuaFj.jpg" alt="aizu1313-2"><br>这样砍出来就不是长方形了，不过题目说了是凸多边形，所以不会出现上述情况。<br>那么现在我们要使用辛普森积分了。辛普森积分是形如下图的公式：<br><img src="https://i.loli.net/2020/12/14/wTECJF8r9oqijPB.jpg" alt="aizu1313-3"><br>证明见<a href="https://blog.csdn.net/yyx2000/article/details/71297792">关于辛普森积分法的研究</a>。作为一个咸鱼选手当然只想知道板子怎么用。首先是辛普森积分在什么条件下使用：当我们的积分函数是二次及以下时，辛普森积分能够保证较高的精度。接下来是实际的使用：本题中我们首先将第一个多边形的x和第二个多边形的x全部取出存入一个vector，为什么要这么做？因为在这些x两两之间最后交出来的长方形的边长都是同一线性变化的，或者你看图，理解为我们切割时碰到了x的段点，这个时候长方形之后的边长虽然还是线性变化，却已经不是之前的变化函数了所以需要重新计算。而对于边长同一线性变化的区间，或者说两个相邻的x，我们就能使用辛普森积分进行计算。辛普森积分需要的是左端点(x1),右端点(x2),左端点函数值(fa,即在x1点我们切割两个棱柱得到的长度相乘。我们直接枚举棱柱的边求交，然后找y最大值-y最小值就是长度(z同理)，表现为代码中的width)，右段点（同理），中点（同理），有了这些函数值后我们就能获得面积沿x的积分，也就是这段的体积，最后我们逐段体积相加即可。<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7fffffffffffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset(a,val,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sqr(x) ((x)*(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="function">ll <span class="title">quickpow</span><span class="params">(ll a,ll b,ll MOD)</span></span>&#123;ll ans=<span class="number">1</span>;<span class="keyword">while</span>(b)&#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ans*a)%MOD;a=a*a%MOD,b&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a%b==<span class="number">0</span>?b:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//head</span></span><br><span class="line"><span class="comment">//#define LOCAL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">150</span>;</span><br><span class="line"><span class="keyword">double</span> X1[MAXN],Y1[MAXN];</span><br><span class="line"><span class="keyword">double</span> X2[MAXN],Z2[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getMin</span><span class="params">(<span class="keyword">double</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mins=<span class="number">1e12</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)mins=<span class="built_in">min</span>(mins,a[i]);</span><br><span class="line">    <span class="keyword">return</span> mins;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getMax</span><span class="params">(<span class="keyword">double</span> *a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> maxs=<span class="number">-1e12</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)maxs=<span class="built_in">max</span>(maxs,a[i]);</span><br><span class="line">    <span class="keyword">return</span> maxs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Remember the problem makes sure that it&#x27;s a convex plogyen</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">width</span><span class="params">(<span class="keyword">double</span> *X,<span class="keyword">double</span> *Y,<span class="keyword">int</span> n,<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> down=<span class="number">1e12</span>,up=<span class="number">-1e12</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> x1=X[i],y1=Y[i],x2=X[(i+<span class="number">1</span>)%n],y2=Y[(i+<span class="number">1</span>)%n];</span><br><span class="line">        <span class="keyword">if</span>(x1!=x2&amp;&amp;(x1-x)*(x2-x)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">double</span> y=y1+(y2-y1)*(x-x1)/(x2-x1);</span><br><span class="line">            down=<span class="built_in">min</span>(down,y);</span><br><span class="line">            up=<span class="built_in">max</span>(up,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0.0</span>,up-down);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// LOCAL</span></span></span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m&amp;&amp;!n)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;X1[i],&amp;Y1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;X2[i],&amp;Z2[i]);</span><br><span class="line">        <span class="keyword">int</span> min1=<span class="built_in">getMin</span>(X1,m),max1=<span class="built_in">getMax</span>(X1,m),min2=<span class="built_in">getMin</span>(X2,n),max2=<span class="built_in">getMax</span>(X2,n);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; xs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)xs.<span class="built_in">push_back</span>(X1[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)xs.<span class="built_in">push_back</span>(X2[i]);</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(xs));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xs.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> a=xs[i],b=xs[i+<span class="number">1</span>],c=(a+b)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(min1&lt;=c&amp;&amp;c&lt;=max1&amp;&amp;min2&lt;=c&amp;&amp;c&lt;=max2)&#123;</span><br><span class="line">                <span class="keyword">double</span> functiona=<span class="built_in">width</span>(X1,Y1,m,a)*<span class="built_in">width</span>(X2,Z2,n,a);</span><br><span class="line">                <span class="keyword">double</span> functionb=<span class="built_in">width</span>(X1,Y1,m,b)*<span class="built_in">width</span>(X2,Z2,n,b);</span><br><span class="line">                <span class="keyword">double</span> functionc=<span class="built_in">width</span>(X1,Y1,m,c)*<span class="built_in">width</span>(X2,Z2,n,c);</span><br><span class="line">                res+=(b-a)/<span class="number">6.0</span>*(functiona+<span class="number">4</span>*functionc+functionb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.10f\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>辛普森积分</category>
      </categories>
      <tags>
        <tag>辛普森积分</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划补档</title>
    <url>/2017/10/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A1%A5%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="一、背包"><a href="#一、背包" class="headerlink" title="一、背包"></a>一、背包</h1><ol>
<li>01背包</li>
<li>完全背包</li>
<li>多重背包</li>
<li>分组背包<span id="more"></span>
<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。<br><em>思路：</em><br>二维数组的方式比较简单不再写了，重点记录下一维数组的dp。一维数组的递推式为dp[j]=max(dp[j],dp[j-w[i]]+v[i])。意思就是在第i次循环时，也就是在考虑是否选取第i个物品的时候，利用之前记录的0-W大小的背包来更新当前情况下j容量的数据。值得注意的是循环的顺序与完全背包正好相反，试想如果我们从0循环到W，那么我们会发现前面如果更新了一次值，在后面的计算中我们就会使用之前更新的值，也就是说我们选了同一个物品2次。这跟01背包每个物品选一次是相悖的。而从W循环到0就没有这种问题了。<br><em>代码:</em><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,mw,v[<span class="number">1000</span>],w[<span class="number">1000</span>],dp[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;mw)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123; <span class="keyword">for</span>(<span class="keyword">int</span> j=mw;j&lt;=w[i];j--)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[mw]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<em>关于初始化</em><blockquote>
<p>我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。</p>
<p>如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。</p>
<p>如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。</p>
<p>为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。</p>
<p>这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。<br><em>HDU - 2602 Bone Collector</em><br><em>思路：</em><br>模板题<br><em>代码：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;   </span><br><span class="line">    <span class="keyword">int</span> n, v, val[<span class="number">1005</span>], vol[<span class="number">1005</span>], dp[<span class="number">1005</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin &gt;&gt; val[i]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)cin &gt;&gt; vol[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123; <span class="keyword">for</span> (<span class="keyword">int</span> j = v;j &gt;= vol[i];j--) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - vol[i]] + val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[v] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>完全背包问题</em><br><em>思路：</em><br>为了解决这个问题，我们通常的想法是修改递推式为dp[i][j]=max(dp[i][j],dp[i][j-k<em>w[i]]+k</em>v[i])但是如果使用这个递推式那么程序中就会有一个三重循环，时间复杂度非常的糟糕。为了减少时间复杂度，我们就要用到之前01背包中使用的对于一维数组操作。01中我们从W到0，在这里我们使用0-W就可以从小到大一个不漏的更新。<br><em>FATE HDU - 2159</em><br><em>思路:</em><br>二维完全背包的题目，限制条件为忍耐度和最多杀怪的数量。递推关系是dp[j][k]=max(dp[j][k],dp[j-end[i]][k—]+exp[i])<br><em>代码:</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, s, end[<span class="number">100</span>], exp[<span class="number">100</span>],dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,l,min=<span class="number">999999999</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; k;i++) &#123; cin &gt;&gt; exp[i] &gt;&gt; end[i];&#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = end[i];j &lt;= m;j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (l = <span class="number">1</span>;l &lt;= s;l++) &#123; dp[j][l] = <span class="built_in">max</span>(dp[j][l], dp[j - end[i]][l - <span class="number">1</span>] + exp[i]); <span class="keyword">if</span> (dp[j][l] &gt;= n&amp;&amp;j &lt; min)min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (min &lt;= m)cout &lt;&lt; m-min &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、LIS"><a href="#二、LIS" class="headerlink" title="二、LIS"></a>二、LIS</h2><p><em>Super Jumping! Jumping! Jumping! HDU - 1087</em><br><em>思路:</em><br>把LIS模板中的长度换成和<br><em>代码</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a[<span class="number">1005</span>],dp[<span class="number">1005</span>];</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n&amp;&amp;n) &#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">        dp[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + a[i]); &#125; <span class="keyword">if</span> (dp[i] &gt; res)res = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res&lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC 热身赛A Square Counting</title>
    <url>/2017/11/29/CCPC%20%E7%83%AD%E8%BA%AB%E8%B5%9BA%20Square%20Counting/</url>
    <content><![CDATA[<p>热身赛光荣打铁，只能回来补题。。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目来源Kickstart Round A 2017 Problem A。大致意思是从一个m*n矩形中能选出多少个正方形（这里给的是点数，我们默认m-1,n-1）。对于这个问题我们把斜着的正方形和正常的正方形分开考虑。<br>对于正常的正方形有：<br><img src="https://i.loli.net/2020/12/14/hS2VUwCMbnG8Xrc.png" alt="gs1"><br>对于斜着的正方形有：（画张图考虑后能发现斜着且撑满的正方形只有k-1个，然后从小正方形到大正方形累加）<br><img src="https://i.loli.net/2020/12/16/pe8bATZFcU6Oq9j.png" alt="gs2"><br>化简可得<br><img src="https://i.loli.net/2020/12/14/hAnFYd6ZPUt43Kp.png" alt="gs3"><br>利用平方和公式和立方和公式我们能O(1)求出答案<br><span id="more"></span></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ms(a,val) memset((a),(val),(sizeof(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mint</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">mint</span>():<span class="built_in">x</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="built_in">mint</span>(<span class="keyword">int</span> s)&#123;</span><br><span class="line">        x=s;<span class="keyword">if</span>(x&lt;mod&amp;&amp;x&gt;=<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        x%=mod;<span class="keyword">if</span>(x&lt;<span class="number">0</span>)x+=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mint</span>(ll s)&#123;<span class="keyword">int</span> ts=s%mod;<span class="keyword">if</span>(ts&lt;<span class="number">0</span>)ts+=mod;x=ts;&#125;</span><br><span class="line">    mint&amp; <span class="keyword">operator</span> +=(mint t)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x+=t.x)&gt;=mod)x-=mod;<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mint&amp; <span class="keyword">operator</span> -=(mint t)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x+=mod-t.x)&gt;=mod)x-=mod;<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mint&amp; <span class="keyword">operator</span> *=(mint t)&#123;x=(ll)x*t.x%mod;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    mint&amp; <span class="keyword">operator</span> /=(mint t)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>*=t.<span class="built_in">inv</span>();&#125;</span><br><span class="line">    mint <span class="keyword">operator</span> -()<span class="keyword">const</span> &#123;<span class="keyword">if</span>(x)<span class="keyword">return</span> mod-x;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    mint <span class="keyword">operator</span> +(mint t)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">mint</span>(*<span class="keyword">this</span>)+=t;&#125;</span><br><span class="line">    mint <span class="keyword">operator</span> -(mint t)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">mint</span>(*<span class="keyword">this</span>)-=t;&#125;</span><br><span class="line">    mint <span class="keyword">operator</span> *(mint t)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">mint</span>(*<span class="keyword">this</span>)*=t;&#125;</span><br><span class="line">    mint <span class="keyword">operator</span> /(mint t)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="built_in">mint</span>(*<span class="keyword">this</span>)/=t;&#125;</span><br><span class="line">    <span class="function">mint <span class="title">pow</span><span class="params">(ll k)</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">        mint r=<span class="number">1</span>,a=x;</span><br><span class="line">        <span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,a*=a)<span class="keyword">if</span>(k&amp;<span class="number">1</span>)r*=a;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">mint <span class="title">inv</span><span class="params">()</span><span class="keyword">const</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mint</span>(x).<span class="built_in">pow</span>(mod<span class="number">-2</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    ll tm,tn;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;t;z++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;tm,&amp;tn);</span><br><span class="line">        <span class="function">mint <span class="title">m</span><span class="params">(tm<span class="number">-1</span>)</span>,<span class="title">n</span><span class="params">(tn<span class="number">-1</span>)</span>,<span class="title">mb</span><span class="params">(min(tm<span class="number">-1</span>,tn<span class="number">-1</span>))</span></span>;</span><br><span class="line">        <span class="function">mint <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ans+=(m*n+m+n+<span class="built_in">mint</span>(<span class="number">1</span>))*(<span class="built_in">mint</span>(<span class="number">1</span>)+mb)*mb/<span class="built_in">mint</span>(<span class="number">2</span>)-(m+n+<span class="number">2</span>)*mb*(mb+<span class="built_in">mint</span>(<span class="number">1</span>))*(<span class="built_in">mint</span>(<span class="number">2</span>)*mb+<span class="built_in">mint</span>(<span class="number">1</span>))/<span class="built_in">mint</span>(<span class="number">6</span>)+(mb*(mb+<span class="built_in">mint</span>(<span class="number">1</span>))/<span class="built_in">mint</span>(<span class="number">2</span>))*(mb*(mb+<span class="built_in">mint</span>(<span class="number">1</span>))/<span class="built_in">mint</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,z+<span class="number">1</span>,ans.x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 1762C Binary Strings are Fun</title>
    <url>/2023/01/10/CodeForces%20-%201762C%20Binary%20Strings%20are%20Fun/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>我们定义一个01字符串是good当且仅当每个奇数位index的数字是1-index这个子串的中位数（即这个数字是1-index子串中出现最多的数字）。定义extend操作为对于一个01串，在两两数字之间插入0/1.现给定一个01串，问对于所有的前缀，extend后为good的串有多少。<br><span id="more"></span></p>
<h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>首先我们能够得到以下两个结论：</p>
<ol>
<li>我们首先考虑一个全为0的字符串，长度为k。如果我们要扩展这个字符串，那么对k-1个空我们能够随便填写，因为不论我们怎么填0都已经必然是出现次数最多的，所以答案为2^(k-1)。</li>
<li>现在我们考虑有不同字符的01串。首先我们能够发现，如果是01这种相邻不一样的串，在extend时必须插入1。所以对于这种相邻不一样的串，我们能插入的串是固定的。</li>
</ol>
<p>基于上述结论，假定我们的初始01串为…01（长度k），那么我们就能够反推出唯一的一个extend good串。对于长度为k-1，0结尾的前缀，由于它是一个good串，那么extend后的串中应该有k-1个0，也就是至多k-2个1。对于长度为k，1结尾的前缀，由于他extend后是good，所以extend后的串至少有k个1，在结尾已经有一个1，前面至多k-2个1的情况下，不难知道，0和1中必须放入1.同时，这个结论是能向前递推的，不论之前的串是相同的还是不同的，有兴趣的可以自己推一下，这里不再赘述。</p>
<p>基于上述讨论，我们能够知道，一个01/10这种相邻不同的串就能让最后一位的统计还原为1，同时如果是11，00这种相邻一样的串，每次答案都是上一个答案的2倍。所以最终的算法为，从头开始计算，如果当前数字和上一个一样，计数器变为2倍，否则计数器重制为1.对每一位的计数器累加就是答案。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This template is based on tourist&#x27;s template&lt;Modular&gt;</span></span><br><span class="line"><span class="comment">// Used for modular calculation</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">inverse</span><span class="params">(T a, T mod)</span> </span>&#123;</span><br><span class="line">    T u = <span class="number">0</span>, v = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(a) &#123;</span><br><span class="line">        T t = mod/a;</span><br><span class="line">        mod -= t*a; <span class="built_in">swap</span>(a, mod);</span><br><span class="line">        u -= t*v; <span class="built_in">swap</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modular</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Type = <span class="keyword">typename</span> decay&lt;<span class="keyword">decltype</span>(T::value)&gt;::type;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Modular</span><span class="params">()</span> : value() &#123;</span>&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">Modular</span>(<span class="keyword">const</span> U&amp; x) &#123;</span><br><span class="line">        value = <span class="built_in">normalize</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Modular</span>(<span class="keyword">const</span> Modular &amp;x) &#123;</span><br><span class="line">        value = x.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Type <span class="title">normalize</span><span class="params">(<span class="keyword">const</span> U &amp;x)</span> </span>&#123;</span><br><span class="line">        Type v;</span><br><span class="line">        <span class="keyword">if</span>(-<span class="built_in">mod</span>() &lt;= x &amp;&amp; x&lt;<span class="built_in">mod</span>()) &#123;</span><br><span class="line">            v = <span class="keyword">static_cast</span>&lt;Type&gt;(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v = <span class="keyword">static_cast</span>&lt;Type&gt;(x%<span class="built_in">mod</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            v += <span class="built_in">mod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">static</span> Type <span class="title">mod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> T::value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Type&amp; <span class="title">operator</span> <span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">U</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;U&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line">    Modular&amp; <span class="keyword">operator</span> +=(<span class="keyword">const</span> Modular&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span>((value+=other.value)&gt;=<span class="built_in">mod</span>()) &#123;</span><br><span class="line">            value-=<span class="built_in">mod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Modular&amp; <span class="keyword">operator</span> -=(<span class="keyword">const</span> Modular&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span>((value-=other.value)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            value+=<span class="built_in">mod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    Modular&amp; <span class="keyword">operator</span> +=(<span class="keyword">const</span> U&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>+=<span class="built_in">Modular</span>(other);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    Modular&amp; <span class="keyword">operator</span> -=(<span class="keyword">const</span> U&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-=<span class="built_in">Modular</span>(other);    </span><br><span class="line">    &#125;</span><br><span class="line">    Modular&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Modular&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Modular <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="function">Modular <span class="title">result</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        *<span class="keyword">this</span>+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Modular <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="function">Modular <span class="title">result</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        *<span class="keyword">this</span>-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Modular <span class="keyword">operator</span>-() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Modular</span>(-value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U = T&gt;</span><br><span class="line">    <span class="keyword">typename</span> enable_if&lt;is_same&lt;<span class="keyword">typename</span> Modular&lt;U&gt;::Type, <span class="keyword">int</span>&gt;::value, Modular&gt;::type&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Modular&amp; rhs) &#123;</span><br><span class="line">        value = <span class="built_in">normalize</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(value)*<span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(rhs.value));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U = T&gt;</span><br><span class="line">    <span class="keyword">typename</span> enable_if&lt;is_same&lt;<span class="keyword">typename</span> Modular&lt;U&gt;::Type, <span class="keyword">long</span> <span class="keyword">long</span>&gt;::value, Modular&gt;::type&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Modular&amp; rhs) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> q = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt;(value) * rhs.value / <span class="built_in">mod</span>());</span><br><span class="line">        value = <span class="built_in">normalize</span>(value * rhs.value - q * <span class="built_in">mod</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U = T&gt;</span><br><span class="line">    <span class="keyword">typename</span> enable_if&lt;!is_integral&lt;<span class="keyword">typename</span> Modular&lt;U&gt;::Type&gt;::value, Modular&gt;::type&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Modular&amp; rhs) &#123;</span><br><span class="line">        value = <span class="built_in">normalize</span>(value * rhs.value);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Modular&amp; <span class="keyword">operator</span> /=(<span class="keyword">const</span> Modular&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>*=<span class="built_in">Modular</span>(<span class="built_in">inverse</span>(other.value, <span class="built_in">mod</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">const</span> Type&amp; <span class="title">abs</span><span class="params">(<span class="keyword">const</span> Modular&amp; x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Modular&lt;U&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;U&gt;&amp; rhs);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Modular&lt;U&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;U&gt;&amp; rhs);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> V&amp; <span class="keyword">operator</span>&gt;&gt;(V&amp; stream, Modular&lt;U&gt;&amp; number);</span><br><span class="line"></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line">    Type value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> lhs.value == rhs.value; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) &#123; <span class="keyword">return</span> lhs == Modular&lt;T&gt;(rhs); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>==(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) == rhs; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> !(lhs == rhs); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) &#123; <span class="keyword">return</span> !(lhs == rhs); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>!=(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> !(lhs == rhs); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> lhs.value &lt; rhs.value; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Modular&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) += rhs; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) += rhs; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>+(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) += rhs; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Modular&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) -= rhs; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) -= rhs; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>-(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) -= rhs; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Modular&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) *= rhs; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) *= rhs; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>*(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) *= rhs; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Modular&lt;T&gt; <span class="keyword">operator</span>/(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) /= rhs; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>/(<span class="keyword">const</span> Modular&lt;T&gt;&amp; lhs, U rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) /= rhs; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; Modular&lt;T&gt; <span class="keyword">operator</span>/(U lhs, <span class="keyword">const</span> Modular&lt;T&gt;&amp; rhs) &#123; <span class="keyword">return</span> Modular&lt;T&gt;(lhs) /= rhs; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">Modular&lt;T&gt; <span class="title">power</span><span class="params">(<span class="keyword">const</span> Modular&lt;T&gt;&amp; a, <span class="keyword">const</span> U&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(b &gt;= <span class="number">0</span>);</span><br><span class="line">    Modular&lt;T&gt; x = a, res = <span class="number">1</span>;</span><br><span class="line">    U p = b;</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsZero</span><span class="params">(<span class="keyword">const</span> Modular&lt;T&gt;&amp; number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">number</span>() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="keyword">const</span> Modular&lt;T&gt;&amp; number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">to_string</span>(<span class="built_in">number</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// U == std::ostream? but done this way because of fastoutput</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> T&gt;</span><br><span class="line">U&amp; <span class="keyword">operator</span>&lt;&lt;(U&amp; stream, <span class="keyword">const</span> Modular&lt;T&gt;&amp; number) &#123;</span><br><span class="line">    <span class="keyword">return</span> stream &lt;&lt; <span class="built_in">number</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// U == std::istream? but done this way because of fastinput</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> T&gt;</span><br><span class="line">U&amp; <span class="keyword">operator</span>&gt;&gt;(U&amp; stream, Modular&lt;T&gt;&amp; number) &#123;</span><br><span class="line">    <span class="keyword">typename</span> common_type&lt;<span class="keyword">typename</span> Modular&lt;T&gt;::Type, <span class="keyword">long</span> <span class="keyword">long</span>&gt;::type x;</span><br><span class="line">    stream &gt;&gt; x;</span><br><span class="line">    number.value = Modular&lt;T&gt;::<span class="built_in">normalize</span>(x);</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> md = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> Mint = Modular&lt;std::integral_constant&lt;decay&lt;<span class="keyword">decltype</span>(md)&gt;::type, md&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Mint&gt; <span class="title">fact</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;Mint&gt; <span class="title">inv_fact</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">Mint <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; n) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((<span class="keyword">int</span>) fact.<span class="built_in">size</span>() &lt; n + <span class="number">1</span>) &#123;</span><br><span class="line">    fact.<span class="built_in">push_back</span>(fact.<span class="built_in">back</span>() * (<span class="keyword">int</span>) fact.<span class="built_in">size</span>());</span><br><span class="line">    inv_fact.<span class="built_in">push_back</span>(<span class="number">1</span> / fact.<span class="built_in">back</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fact[n] * inv_fact[k] * inv_fact[n - k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line">    <span class="function">Mint <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">Mint <span class="title">cnt</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = str[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur!=last) &#123;</span><br><span class="line">            last = cur;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> T=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">      <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces - 1874B Jellyfish and Math</title>
    <url>/2023/10/02/CodeForces%20-%201874B%20Jellyfish%20and%20Math/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定5个数字a, b, c, d, m, 通过对a,b进行以下4种操作，问最少几步能够将(a, b) 转化为(c, d)</p>
<ul>
<li>x = x &amp; y</li>
<li>x = x | y</li>
<li>y = x ^ y</li>
<li>y = y ^ m</li>
</ul>
<span id="more"></span>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>对于这种位操作求最短路径的题，一个比较通用的方法是bfs。一个最naive的方法就是看我们可以以(a, b)这个二元组出发，每次尝试题目中给出的4组操作，看最终到达(c, d, m)这个三元组需要几步。考虑到数据范围是a, b, c, d, m属于$2^{30}$，总样例数$10^{5}$，我们非常有可能得到TLE。但是即便如此，bfs的方向也是对的，唯一的问题是怎么解决状态数过大的问题。</p>
<p>如果在解题过程中碰到这种状态非常大的题，我们可以考虑是否能够压缩bfs的“状态”。比如对于这题来说$2^{30}$就是一个小提示，因为一般来说题目给的都是10进制的范围，给2进制通常就是提示按位考虑。我们以一位的情况来考虑，令ai, bi, mi为2进制下其第i位的可以发现(ai, bi, mi)一共只有(0|1, 0|1, 0|1) 8种情况。更进一步，我们可以发现：</p>
<blockquote>
<p>对于i != j， 若(ai, bi, mi) = (aj, bj, mj)， 那么一定有(ci, di) = (cj, dj)。否则不可能转换成功。根据给出的4种操作进行验证，显然这个推论是正确的。即任意二进制位(ai, bi, mi)出现在(a, b, m)中，即便位置不同，只要这个三元组相同，不论如何操作，最后答案得到的二进制位(ci, di)也一定相同。</p>
</blockquote>
<p>这个观察给我们的启发是，尽管数字非常大，但只要(ai, bi, mi)这个三元组相同，那么我们可以将其归为一类进行bfs（显然(ai, bi, mi)一共就8个状态，状态数大大减少了）。我们只要从(ai, bi, mi)出发，看怎么走到(ci, di)就行。这个状态数非常小因为答案的(ci, di)一共就4种状态(0|1, 0|1)，深度非常浅所以问题不大。这里过大状态数的问题基本就解决了。</p>
<p>但我们会发现产生了一个新问题，即三元组的所有情况都应该覆盖到。单单对一个二进制bfs是得不到正确答案的。所以最终状态应该覆盖了所有三元组的八种情况类似(000当前(c, d), 001当前(c, d), 010当前(c, d),…)（总长度为8，有一点状态压缩dp的意思了）。(c, d)这个二元组一共有4种情况(0|1, 0|1)。这里要注意，对于不同的a, b来说，有些三元组是不一定存在的。比如a = 111, b = 111, m = 111。这个例子里三元组只有(a=1, b=1, m=1)，其他的三元组情况都没覆盖到。所以最终答案(ci, di)除了基本的4种情况外，还要加一个(a, b, m)三元组不存在的状态，即(4+1) = 5种状态。考虑到之前总长度为8的元组，同时每个位有5个状态，很容易想到用8位5进制数来表达之前的8长度元组。总状态数为$5^{8}=390625$。完美符合时间要求。我们要做的就是按着状态跑一遍bfs就可以了。在实现过程中注意不存在的状态通过常规的二进制操作是更新不到的，但是不存在也代表着，其他位一样就可以了，这位什么状态无所谓。所以遍历一下其他位一样，这一位不一样的状态即可。具体见代码。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MAX_STATE = <span class="number">400005</span>;</span><br><span class="line">ll p5[<span class="number">10</span>];</span><br><span class="line">ll dp[MAX_STATE]; <span class="comment">// 5^8</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getMask</span><span class="params">(ll a, ll b, ll m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&lt;&lt;<span class="number">2</span>) | (b&lt;&lt;<span class="number">1</span>) | m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getTargetMask</span><span class="params">(ll c, ll d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c&lt;&lt;<span class="number">1</span>) | d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getNextState</span><span class="params">(ll mask, ll op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= <span class="number">1</span>; m++) &#123;</span><br><span class="line">                ll subMask = mask / p5[<span class="built_in">getMask</span>(a, b, m)] % <span class="number">5</span>;</span><br><span class="line">                ll c = (subMask &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                ll d = (subMask &amp; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ( op == <span class="number">0</span> ) &#123;</span><br><span class="line">                    c = (c &amp; d);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( op == <span class="number">1</span> ) &#123;</span><br><span class="line">                    c = (c | d);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) &#123;</span><br><span class="line">                    d = (c^d);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    d = (d^m);</span><br><span class="line">                &#125;</span><br><span class="line">                ret += p5[<span class="built_in">getMask</span>(a, b, m)] * <span class="built_in">getTargetMask</span>(c, d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; MAX_STATE; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1e12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p5[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        p5[i] = p5[i<span class="number">-1</span>] * <span class="number">5LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= <span class="number">1</span>; a++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">1</span>; b++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt;= <span class="number">1</span>; m++) &#123;</span><br><span class="line">                mask += p5[<span class="built_in">getMask</span>(a, b, m)] * <span class="built_in">getTargetMask</span>(a, b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[mask] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(mask);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ll cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> op = <span class="number">0</span>; op &lt; <span class="number">4</span>; op++) &#123;</span><br><span class="line">            ll nxt = <span class="built_in">getNextState</span>(cur, op);</span><br><span class="line">            <span class="keyword">if</span> (dp[nxt] == <span class="number">1e12</span>) &#123;</span><br><span class="line">                dp[nxt] = dp[cur] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(nxt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> tmask = <span class="number">0</span>; tmask &lt; p5[<span class="number">8</span>]; tmask++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            ll subMask = (tmask / p5[i])%<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span> (subMask == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">4</span>; x++) &#123;</span><br><span class="line">                    dp[tmask] = <span class="built_in">min</span>(dp[tmask], dp[tmask - x * p5[i]]); <span class="comment">//这行是更新不存在状态的核心</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll a, b, c, d, m;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;m;</span><br><span class="line">    ll mask = p5[<span class="number">8</span>]<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        ll abit = ((a&gt;&gt;i)&amp;<span class="number">1</span>), bbit = ((b&gt;&gt;i)&amp;<span class="number">1</span>), cbit = ((c&gt;&gt;i)&amp;<span class="number">1</span>), dbit = ((d&gt;&gt;i)&amp;<span class="number">1</span>), mbit = ((m&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        ll subMask = (mask / p5[<span class="built_in">getMask</span>(abit, bbit, mbit)]) % <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span> (subMask == <span class="number">4</span>) &#123;</span><br><span class="line">            mask = mask - <span class="number">4</span> * p5[<span class="built_in">getMask</span>(abit, bbit, mbit)] + p5[<span class="built_in">getMask</span>(abit, bbit, mbit)] * <span class="built_in">getTargetMask</span>(cbit, dbit);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subMask != <span class="built_in">getTargetMask</span>(cbit, dbit)) &#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;((dp[mask] &lt; <span class="number">1e12</span>) ? dp[mask] : <span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;./output.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BFS</category>
        <category>状态压缩</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
</search>
